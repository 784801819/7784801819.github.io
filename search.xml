<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>typescript10（语法扩展）</title>
      <link href="2023/03/11/typescript10-yu-fa-kuo-zhan/"/>
      <url>2023/03/11/typescript10-yu-fa-kuo-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="内置类型导入"><a href="#内置类型导入" class="headerlink" title="内置类型导入"></a>内置类型导入</h2><ul><li><p>导入时需要使用type前缀,表明被导入的是一个类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; MyInterface, MyType &#125; <span class="keyword">from</span> <span class="string">&quot;./index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v1: MyType = <span class="string">&quot;wangbowen&quot;</span></span><br><span class="line"><span class="keyword">const</span> v2: MyInterface = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2></li><li><p>tsconfig.json文件是通过<code>tsc --init</code>生成</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&quot;compilerOptions&quot;: &#123;</span><br><span class="line">  &quot;incremental&quot;: true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度</span><br><span class="line">  &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;, // 增量编译文件的存储位置</span><br><span class="line">  &quot;diagnostics&quot;: true, // 打印诊断信息 </span><br><span class="line">  &quot;target&quot;: &quot;ES5&quot;, // 目标语言的版本</span><br><span class="line">  &quot;module&quot;: &quot;CommonJS&quot;, // 生成代码的模板标准</span><br><span class="line">  &quot;outFile&quot;: &quot;./app.js&quot;, // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,</span><br><span class="line">  &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,</span><br><span class="line">  &quot;allowJS&quot;: true, // 允许编译器编译JS，JSX文件</span><br><span class="line">  &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用</span><br><span class="line">  &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录</span><br><span class="line">  &quot;rootDir&quot;: &quot;./&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构</span><br><span class="line">  &quot;declaration&quot;: true, // 生成声明文件，开启后会自动生成声明文件</span><br><span class="line">  &quot;declarationDir&quot;: &quot;./file&quot;, // 指定生成声明文件存放目录</span><br><span class="line">  &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件，而不会生成js文件</span><br><span class="line">  &quot;sourceMap&quot;: true, // 生成目标文件的sourceMap文件</span><br><span class="line">  &quot;inlineSourceMap&quot;: true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中</span><br><span class="line">  &quot;declarationMap&quot;: true, // 为声明文件生成sourceMap</span><br><span class="line">  &quot;typeRoots&quot;: [], // 声明文件目录，默认时node_modules/@types</span><br><span class="line">  &quot;types&quot;: [], // 加载的声明文件包</span><br><span class="line">  &quot;removeComments&quot;:true, // 删除注释 </span><br><span class="line">  &quot;noEmit&quot;: true, // 不输出文件,即编译后不会生成任何js文件</span><br><span class="line">  &quot;noEmitOnError&quot;: true, // 发送错误时不输出任何文件</span><br><span class="line">  &quot;noEmitHelpers&quot;: true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用</span><br><span class="line">  &quot;importHelpers&quot;: true, // 通过tslib引入helper函数，文件必须是模块</span><br><span class="line">  &quot;downlevelIteration&quot;: true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现</span><br><span class="line">  &quot;strict&quot;: true, // 开启所有严格的类型检查</span><br><span class="line">  &quot;alwaysStrict&quot;: true, // 在代码中注入&#x27;use strict&#x27;</span><br><span class="line">  &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型</span><br><span class="line">  &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量</span><br><span class="line">  &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变</span><br><span class="line">  &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化</span><br><span class="line">  &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查</span><br><span class="line">  &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型</span><br><span class="line">  &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错)</span><br><span class="line">  &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错)</span><br><span class="line">  &quot;noFallthroughCasesInSwitch&quot;: true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)</span><br><span class="line">  &quot;noImplicitReturns&quot;: true, //每个分支都会有返回值</span><br><span class="line">  &quot;esModuleInterop&quot;: true, // 允许export=导出，由import from 导入</span><br><span class="line">  &quot;allowUmdGlobalAccess&quot;: true, // 允许在模块中全局变量的方式访问umd模块</span><br><span class="line">  &quot;moduleResolution&quot;: &quot;node&quot;, // 模块解析策略，ts默认用node的解析策略，即相对的方式导入</span><br><span class="line">  &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录</span><br><span class="line">  &quot;paths&quot;: &#123; // 路径映射，相对于baseUrl</span><br><span class="line">    <span class="comment">// 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置</span></span><br><span class="line">    &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.min.js&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错</span><br><span class="line">  &quot;listEmittedFiles&quot;: true, // 打印输出文件</span><br><span class="line">  &quot;listFiles&quot;: true// 打印编译的文件(包括引用的声明文件)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）</span></span><br><span class="line">&quot;include&quot;: [</span><br><span class="line">   <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 指定一个排除列表（include的反向操作）</span></span><br><span class="line"> &quot;exclude&quot;: [</span><br><span class="line">   <span class="string">&quot;demo.ts&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 指定哪些文件使用该配置（属于手动一个个指定文件）</span></span><br><span class="line"> &quot;files&quot;: [</span><br><span class="line">   <span class="string">&quot;demo.ts&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="内置类型声明"><a href="#内置类型声明" class="headerlink" title="内置类型声明"></a>内置类型声明</h2></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> allDiv: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="comment">//读取div 这种需要类型断言 或者加个判断应为读不到返回null</span></span><br><span class="line"><span class="keyword">let</span> div:HTMLElement = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>) <span class="keyword">as</span> HTMLDivElement</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e: MouseEvent</span>) </span>&#123;&#125;);</span><br><span class="line"><span class="comment">//dom元素的映射表</span></span><br><span class="line"><span class="keyword">interface</span> HTMLElementTagNameMap &#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>: HTMLAnchorElement;</span><br><span class="line">  <span class="string">&quot;abbr&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;applet&quot;</span>: HTMLAppletElement;</span><br><span class="line">  <span class="string">&quot;area&quot;</span>: HTMLAreaElement;</span><br><span class="line">  <span class="string">&quot;article&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;aside&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;audio&quot;</span>: HTMLAudioElement;</span><br><span class="line">  <span class="string">&quot;b&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;base&quot;</span>: HTMLBaseElement;</span><br><span class="line">  <span class="string">&quot;bdi&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;bdo&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;blockquote&quot;</span>: HTMLQuoteElement;</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: HTMLBodyElement;</span><br><span class="line">  <span class="string">&quot;br&quot;</span>: HTMLBRElement;</span><br><span class="line">  <span class="string">&quot;button&quot;</span>: HTMLButtonElement;</span><br><span class="line">  <span class="string">&quot;canvas&quot;</span>: HTMLCanvasElement;</span><br><span class="line">  <span class="string">&quot;caption&quot;</span>: HTMLTableCaptionElement;</span><br><span class="line">  <span class="string">&quot;cite&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;col&quot;</span>: HTMLTableColElement;</span><br><span class="line">  <span class="string">&quot;colgroup&quot;</span>: HTMLTableColElement;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: HTMLDataElement;</span><br><span class="line">  <span class="string">&quot;datalist&quot;</span>: HTMLDataListElement;</span><br><span class="line">  <span class="string">&quot;dd&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;del&quot;</span>: HTMLModElement;</span><br><span class="line">  <span class="string">&quot;details&quot;</span>: HTMLDetailsElement;</span><br><span class="line">  <span class="string">&quot;dfn&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;dialog&quot;</span>: HTMLDialogElement;</span><br><span class="line">  <span class="string">&quot;dir&quot;</span>: HTMLDirectoryElement;</span><br><span class="line">  <span class="string">&quot;div&quot;</span>: HTMLDivElement;</span><br><span class="line">  <span class="string">&quot;dl&quot;</span>: HTMLDListElement;</span><br><span class="line">  <span class="string">&quot;dt&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;em&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;embed&quot;</span>: HTMLEmbedElement;</span><br><span class="line">  <span class="string">&quot;fieldset&quot;</span>: HTMLFieldSetElement;</span><br><span class="line">  <span class="string">&quot;figcaption&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;figure&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;font&quot;</span>: HTMLFontElement;</span><br><span class="line">  <span class="string">&quot;footer&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;form&quot;</span>: HTMLFormElement;</span><br><span class="line">  <span class="string">&quot;frame&quot;</span>: HTMLFrameElement;</span><br><span class="line">  <span class="string">&quot;frameset&quot;</span>: HTMLFrameSetElement;</span><br><span class="line">  <span class="string">&quot;h1&quot;</span>: HTMLHeadingElement;</span><br><span class="line">  <span class="string">&quot;h2&quot;</span>: HTMLHeadingElement;</span><br><span class="line">  <span class="string">&quot;h3&quot;</span>: HTMLHeadingElement;</span><br><span class="line">  <span class="string">&quot;h4&quot;</span>: HTMLHeadingElement;</span><br><span class="line">  <span class="string">&quot;h5&quot;</span>: HTMLHeadingElement;</span><br><span class="line">  <span class="string">&quot;h6&quot;</span>: HTMLHeadingElement;</span><br><span class="line">  <span class="string">&quot;head&quot;</span>: HTMLHeadElement;</span><br><span class="line">  <span class="string">&quot;header&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;hgroup&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;hr&quot;</span>: HTMLHRElement;</span><br><span class="line">  <span class="string">&quot;html&quot;</span>: HTMLHtmlElement;</span><br><span class="line">  <span class="string">&quot;i&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;iframe&quot;</span>: HTMLIFrameElement;</span><br><span class="line">  <span class="string">&quot;img&quot;</span>: HTMLImageElement;</span><br><span class="line">  <span class="string">&quot;input&quot;</span>: HTMLInputElement;</span><br><span class="line">  <span class="string">&quot;ins&quot;</span>: HTMLModElement;</span><br><span class="line">  <span class="string">&quot;kbd&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;label&quot;</span>: HTMLLabelElement;</span><br><span class="line">  <span class="string">&quot;legend&quot;</span>: HTMLLegendElement;</span><br><span class="line">  <span class="string">&quot;li&quot;</span>: HTMLLIElement;</span><br><span class="line">  <span class="string">&quot;link&quot;</span>: HTMLLinkElement;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;map&quot;</span>: HTMLMapElement;</span><br><span class="line">  <span class="string">&quot;mark&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;marquee&quot;</span>: HTMLMarqueeElement;</span><br><span class="line">  <span class="string">&quot;menu&quot;</span>: HTMLMenuElement;</span><br><span class="line">  <span class="string">&quot;meta&quot;</span>: HTMLMetaElement;</span><br><span class="line">  <span class="string">&quot;meter&quot;</span>: HTMLMeterElement;</span><br><span class="line">  <span class="string">&quot;nav&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;noscript&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;object&quot;</span>: HTMLObjectElement;</span><br><span class="line">  <span class="string">&quot;ol&quot;</span>: HTMLOListElement;</span><br><span class="line">  <span class="string">&quot;optgroup&quot;</span>: HTMLOptGroupElement;</span><br><span class="line">  <span class="string">&quot;option&quot;</span>: HTMLOptionElement;</span><br><span class="line">  <span class="string">&quot;output&quot;</span>: HTMLOutputElement;</span><br><span class="line">  <span class="string">&quot;p&quot;</span>: HTMLParagraphElement;</span><br><span class="line">  <span class="string">&quot;param&quot;</span>: HTMLParamElement;</span><br><span class="line">  <span class="string">&quot;picture&quot;</span>: HTMLPictureElement;</span><br><span class="line">  <span class="string">&quot;pre&quot;</span>: HTMLPreElement;</span><br><span class="line">  <span class="string">&quot;progress&quot;</span>: HTMLProgressElement;</span><br><span class="line">  <span class="string">&quot;q&quot;</span>: HTMLQuoteElement;</span><br><span class="line">  <span class="string">&quot;rp&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;rt&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;ruby&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;s&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;samp&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;script&quot;</span>: HTMLScriptElement;</span><br><span class="line">  <span class="string">&quot;section&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;select&quot;</span>: HTMLSelectElement;</span><br><span class="line">  <span class="string">&quot;slot&quot;</span>: HTMLSlotElement;</span><br><span class="line">  <span class="string">&quot;small&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;source&quot;</span>: HTMLSourceElement;</span><br><span class="line">  <span class="string">&quot;span&quot;</span>: HTMLSpanElement;</span><br><span class="line">  <span class="string">&quot;strong&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;style&quot;</span>: HTMLStyleElement;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;summary&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;sup&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;table&quot;</span>: HTMLTableElement;</span><br><span class="line">  <span class="string">&quot;tbody&quot;</span>: HTMLTableSectionElement;</span><br><span class="line">  <span class="string">&quot;td&quot;</span>: HTMLTableDataCellElement;</span><br><span class="line">  <span class="string">&quot;template&quot;</span>: HTMLTemplateElement;</span><br><span class="line">  <span class="string">&quot;textarea&quot;</span>: HTMLTextAreaElement;</span><br><span class="line">  <span class="string">&quot;tfoot&quot;</span>: HTMLTableSectionElement;</span><br><span class="line">  <span class="string">&quot;th&quot;</span>: HTMLTableHeaderCellElement;</span><br><span class="line">  <span class="string">&quot;thead&quot;</span>: HTMLTableSectionElement;</span><br><span class="line">  <span class="string">&quot;time&quot;</span>: HTMLTimeElement;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: HTMLTitleElement;</span><br><span class="line">  <span class="string">&quot;tr&quot;</span>: HTMLTableRowElement;</span><br><span class="line">  <span class="string">&quot;track&quot;</span>: HTMLTrackElement;</span><br><span class="line">  <span class="string">&quot;u&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;ul&quot;</span>: HTMLUListElement;</span><br><span class="line">  <span class="string">&quot;var&quot;</span>: HTMLElement;</span><br><span class="line">  <span class="string">&quot;video&quot;</span>: HTMLVideoElement;</span><br><span class="line">  <span class="string">&quot;wbr&quot;</span>: HTMLElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d-ts文件"><a href="#d-ts文件" class="headerlink" title=".d.ts文件"></a>.d.ts文件</h2><ul><li>用来做类型的声明(declare),称之为<code>类型声明</code>或者<code>类型定义</code>文件</li><li>它仅仅用来做类型检测,告知typescript有哪些类型</li><li>第三方库中如果没有声明文件可以使用<code>npm i @types/xxx --save-dev</code>进行下载</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript9（泛型）</title>
      <link href="2023/03/11/typescript9-fan-xing/"/>
      <url>2023/03/11/typescript9-fan-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="类型的参数化"><a href="#类型的参数化" class="headerlink" title="类型的参数化"></a>类型的参数化</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">t: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以手动指定泛型类型</span></span><br><span class="line"><span class="keyword">const</span> v1 = getValue&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> v2 = getValue&lt;&#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;(&#123; <span class="attr">name</span>: <span class="string">&#x27;wangbowen&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者ts自动类型推导</span></span><br><span class="line"><span class="keyword">let</span> v3 = getValue(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// 推导后v3 =&gt; let v3: string</span></span><br></pre></td></tr></table></figure><ul><li>常用的泛型名称<ol><li>T: Type的缩写,类型</li><li>K/V: key和value的缩写,键值对</li><li>E: Element的缩写,元素</li><li>O: Object的缩写,对象</li></ol></li></ul><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型接口可以有默认值</span></span><br><span class="line"><span class="keyword">interface</span> IKun&lt;T = string&gt; &#123;</span><br><span class="line">  name: T</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k: IKun = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1: IKun&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  name: <span class="number">123</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以写多个类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IKun</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: T, <span class="keyword">public</span> age: U</span>)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ts类型推导</span></span><br><span class="line"><span class="keyword">const</span> k = <span class="keyword">new</span> IKun(<span class="string">&#x27;123&#x27;</span>, <span class="number">22</span>)</span><br><span class="line"><span class="comment">// 或者自己指定类型</span></span><br><span class="line"><span class="keyword">const</span> k1 = <span class="keyword">new</span> IKun&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">&#x27;wangbowen&#x27;</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><ul><li><p>希望传入的类型有某些共性,但是这些共性可能不是在同一种类型中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例一:返回传入数据并带有length属性</span></span><br><span class="line"><span class="keyword">interface</span> ILength &#123;</span><br><span class="line">  length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILength</span>&gt;(<span class="params">info: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> info</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = getInfo([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> v1 = getInfo(<span class="string">&#x27;aaa&#x27;</span>) <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> v2 = getInfo(<span class="number">1</span>) <span class="comment">// 不允许,类型“number”的参数不能赋给类型“ILength”的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// keyof 对象时,拿到的就是所有的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObjectValue</span>&lt;<span class="title">O</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">O</span>&gt;(<span class="params">obj: O, key: K</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wanbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = getObjectValue(info, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> address = getObjectValue(info, <span class="string">&#x27;address&#x27;</span>) <span class="comment">// 不允许,类型“&quot;address&quot;”的参数不能赋给类型“&quot;name&quot; | &quot;age&quot;”的参数</span></span><br></pre></td></tr></table></figure><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2></li><li><p>一个类型需要基于另一个类型,可以考虑映射类型</p></li><li><p><code>映射类型</code>建立在<code>索引签名</code>的语法上</p></li><li><p>多是通过<code>keyof</code>创建,然后循环遍历键名创建一个类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射类型不能使用interface定义</span></span><br><span class="line"><span class="keyword">type</span> MapPerson&lt;T&gt; = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> keyof T]: T[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewPerson = MapPerson&lt;Person&gt;;</span><br></pre></td></tr></table></figure><h2 id="映射修饰符"><a href="#映射修饰符" class="headerlink" title="映射修饰符"></a>映射修饰符</h2></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射后的属性既是可选的,也是只读的</span></span><br><span class="line"><span class="keyword">type</span> MapPerson&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof T]?: T[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewPerson = MapPerson&lt;Person&gt;;</span><br></pre></td></tr></table></figure><h2 id="修饰符符号"><a href="#修饰符符号" class="headerlink" title="修饰符符号"></a>修饰符符号</h2><ul><li>你可以通过前缀<code>-</code>或者<code>+</code>删除或者添加这些修饰符，如果没有写前缀，相当于使用了<code>+</code>前缀<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapPerson&lt;T&gt; = &#123;</span><br><span class="line">  <span class="comment">// 意思是去掉属性的只读和可选修饰符</span></span><br><span class="line">  -<span class="keyword">readonly</span> [key <span class="keyword">in</span> keyof T]-?: T[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewPerson = MapPerson&lt;Person&gt; <span class="comment">// type NewPerson = &#123; name: string; age: number; sex: string; &#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript8（枚举类型）</title>
      <link href="2023/03/11/typescript8-mei-ju-lei-xing/"/>
      <url>2023/03/11/typescript8-mei-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举</span></span><br><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  <span class="comment">// 枚举类型的名称一般大写</span></span><br><span class="line">  UP,</span><br><span class="line">  DOWN,</span><br><span class="line">  LEFT,</span><br><span class="line">  RIGHT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d: Direction = Direction.UP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">turnDirection</span>(<span class="params">direction: Direction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> Direction.LEFT:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;向左移动&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Direction.RIGHT:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;向右移动&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> Direction.UP:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;向上移动&#x27;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;向下移动&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举默认值是从1开始递增,或者可以给枚举类型赋值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  LEFT = <span class="number">100</span>,</span><br><span class="line">  RIGHT,</span><br><span class="line">  UP,</span><br><span class="line">  DOWN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Direction1 &#123;</span><br><span class="line">  LEFT = <span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">  RIGHT,</span><br><span class="line">  UP = <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">  DOWN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript7（class类）</title>
      <link href="2023/03/08/typescript7-class-lei/"/>
      <url>2023/03/08/typescript7-class-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在ts中需要声明成员属性</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;wangbowen&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h2 id="类的成员修饰符"><a href="#类的成员修饰符" class="headerlink" title="类的成员修饰符"></a>类的成员修饰符</h2><ul><li><code>public</code>：修饰的是在任何地方可见、公有的属性和方法（默认）</li><li><code>private</code>：修饰的是仅在同一类中可见、私有的属性和方法（类的内部访问）</li><li><code>protected</code>：修饰的是仅在类自身及子类中可见、受保护的属性和方法</li></ul><h2 id="类中的getter和setter"><a href="#类中的getter和setter" class="headerlink" title="类中的getter和setter"></a>类中的getter和setter</h2><ul><li>对属性的访问进行拦截操作</li></ul><h2 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h2><ul><li>可以把一个构造函数参数转成一个同名同值得类属性</li><li>通过在<strong>构造函数参数前添加一个可见性修饰符public、private、protected或readonly来创建参数属性，属性字段也会得到这些修饰符</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&quot;wangbowen&quot;</span>, <span class="number">18</span>)</span><br><span class="line">p.name <span class="comment">// wangbowen</span></span><br></pre></td></tr></table></figure><h2 id="抽象类abstract"><a href="#抽象类abstract" class="headerlink" title="抽象类abstract"></a>抽象类abstract</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法必须出现在抽象类中，类前面也需要加abstract关键字</span></span><br><span class="line"><span class="comment">// 抽象类不能被实例化</span></span><br><span class="line"><span class="comment">// 抽象类可以包含抽象方法，也可以包含有实现体的方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 抽象类中的方法，子类必须要实现</span></span><br><span class="line">  <span class="keyword">abstract</span> getArea(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 子类实现抽象类中的方法</span></span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getarea</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> shape.getArea()</span><br><span class="line">&#125;</span><br><span class="line">getarea(<span class="keyword">new</span> Circle())</span><br><span class="line">getarea(<span class="keyword">new</span> Rectangle())</span><br></pre></td></tr></table></figure><h2 id="鸭子类型检测"><a href="#鸭子类型检测" class="headerlink" title="鸭子类型检测"></a>鸭子类型检测</h2><ul><li>只关心属性和行为,不关心具体是不是对应的类型<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">running</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">running</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">params: Person</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过demo发现,类型为Person但是并未进行校验</span></span><br><span class="line">printInfo(<span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">18</span>))</span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="对象类型的属性修饰符"><a href="#对象类型的属性修饰符" class="headerlink" title="对象类型的属性修饰符"></a>对象类型的属性修饰符</h2></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IKun = &#123;</span><br><span class="line">  <span class="comment">// 可选属性</span></span><br><span class="line">  name?: <span class="built_in">string</span>,</span><br><span class="line">  <span class="comment">// 只读属性</span></span><br><span class="line">  <span class="keyword">readonly</span> age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript6（组合类型）</title>
      <link href="2023/03/04/typescript6-zu-he-lei-xing/"/>
      <url>2023/03/04/typescript6-zu-he-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><ul><li>联合类型是<code>由两个或多个其他类型组成的类型</code></li><li>表示<code>可以是这些类型中的任何一种</code></li><li>联合类型使用<code>|</code>符号表示</li><li>传入给一个联合类型的值非常简单，只要保证是联合类型中的某一个类型<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UnitFn</span>(<span class="params">v: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理联合类型需要缩小联合</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果联合类型过长，可以使用`类型别名`的方式提升代码的可读性</span></span><br><span class="line"><span class="keyword">type</span> Info = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">info: Info</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(info.name, info.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getInfo(&#123;<span class="attr">name</span>: <span class="string">&quot;Wangbowen&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="type和interface的区别"><a href="#type和interface的区别" class="headerlink" title="type和interface的区别"></a>type和interface的区别</h2><ul><li><code>type类型</code>使用范围更广，<code>interface类型</code>只能用来声明对象</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Check = <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> Sex = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure><ul><li>在声明对象时，<code>interface</code>可以多次声明同一个接口名称（合并），<code>type</code>不允许两个相同名称的别名同时存在<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wang: Info = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sex: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 重复标识符“tInfo”。</span></span><br><span class="line"><span class="keyword">type</span> tInfo = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> tInfo = &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>interface类型</code>支持继承</li><li><code>interface类型</code>可以被类实现</li><li>总结：<strong>如果是非对象类型定义使用type类型，如果是对象类型的声明使用interface类型</strong></li></ul><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><ul><li><p>两种或多种类型要同时满足，否则无效</p></li><li><p>交叉类型使用<code>&amp;</code>符号表示</p></li><li><p>通常情况下，是对对象类型进行交叉的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> One &#123;</span><br><span class="line">  ok: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Two &#123;</span><br><span class="line">  cb: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewType = One &amp; Two</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: NewType = &#123;</span><br><span class="line">  ok: <span class="literal">true</span>,</span><br><span class="line">  cb: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言as"><a href="#类型断言as" class="headerlink" title="类型断言as"></a>类型断言as</h2></li><li><p>有时候typescript无法获取具体的类型信息，所以需要使用<code>类型断言</code></p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&quot;.img&quot;</span>) <span class="keyword">as</span> HTMLImageElement</span><br><span class="line"></span><br><span class="line">el.src = <span class="string">&quot;xxx&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>typescript只允许类型断言转换为<code>更具体</code>或者<code>不太具体</code>的类型版本，防止不可能的类型强制转换</li></ul><h2 id="非空类型断言！"><a href="#非空类型断言！" class="headerlink" title="非空类型断言！"></a>非空类型断言！</h2><ul><li>非空断言使用的是！，表示可以确定某个标识符是有值的，跳过ts在编译阶段对它的检测</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notEmpty</span>(<span class="params">message?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message!.toUpperCase())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><ul><li>用于限制一些场景必须传入指定的值，比如:</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不传入指定的get或post则会报错</span></span><br><span class="line"><span class="keyword">type</span> MethodsType = <span class="string">&quot;get&quot;</span> | <span class="string">&quot;post&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url: <span class="built_in">string</span>, methods: MethodsType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(methods) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;get&#x27;</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;post&#x27;</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;post&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">const</span> check: <span class="built_in">never</span> = methods</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">request(<span class="string">&#x27;http://w.com/api/abc&#x27;</span>, <span class="string">&quot;post&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TS细节</span></span><br><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  url: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">  methods: <span class="string">&quot;post&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样是错误的，info.methods获取的是string类型是无法赋值给字面量类型的</span></span><br><span class="line">request(info.url, info.methods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法一：info.methods进行类型断言</span></span><br><span class="line">request(info.url, info.methods <span class="keyword">as</span> <span class="string">&quot;post&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法二：info进行类型断言成const</span></span><br><span class="line"><span class="keyword">const</span> info2 = &#123;</span><br><span class="line">  url: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">  methods: <span class="string">&quot;post&quot;</span></span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line">reuqest(info2.url, info2.methods)</span><br></pre></td></tr></table></figure><h2 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h2><ul><li>可以通过类似于<code>typeof padding === &quot;number&quot;</code>的判断，改变typescript的执行路径</li><li>在给定的执行路径中，可以<code>缩小比声明时更小的类型</code>，这一过程称之为<code>缩小</code></li><li>常见的类型保护:<ol><li>typeof</li><li>平等缩小（===、!==、==、!=）</li><li>instanceof</li><li>in<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISwim &#123;</span><br><span class="line">  swim: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IRun &#123;</span><br><span class="line">  run: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">animal: ISwim | IRun</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断属性是否在对象中时，可以使用in关键字</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;swim&#x27;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal.swim()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fish: ISwim = &#123;</span><br><span class="line">  swim: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">move(fish);</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript5（函数扩展）</title>
      <link href="2023/03/04/typescript5-han-shu-kuo-zhan/"/>
      <url>2023/03/04/typescript5-han-shu-kuo-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数不能多也不能少，要按照约束来传</span></span><br><span class="line">fn(<span class="string">&#x27;wangbowen&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h2 id="函数的可选参数"><a href="#函数的可选参数" class="headerlink" title="函数的可选参数"></a>函数的可选参数</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>, sex?: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sex) &#123;</span><br><span class="line">    <span class="keyword">return</span> name + sex</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> name + age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="string">&#x27;wangbowen&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (name: <span class="built_in">string</span> = <span class="string">&quot;wangbowen&quot;</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><h2 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Add &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn: Add = (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="keyword">interface</span> Info &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = (info: Info): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义剩余参数"><a href="#定义剩余参数" class="headerlink" title="定义剩余参数"></a>定义剩余参数</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (arr: <span class="built_in">number</span>[], ...args: <span class="built_in">any</span>[]): <span class="built_in">any</span>[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [...arr, ...args]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="匿名函数的参数"><a href="#匿名函数的参数" class="headerlink" title="匿名函数的参数"></a>匿名函数的参数</h2><ul><li><code>匿名函数</code>的参数最好不要加类型注解，因为<code>匿名函数</code>会自动推断出类型</li><li>这一过程称之为<code>上下文类型</code>，因为函数执行的上下文可以帮助确定参数和返回值的类型</li></ul><h2 id="函数类型表达式"><a href="#函数类型表达式" class="headerlink" title="函数类型表达式"></a>函数类型表达式</h2><ul><li>如果只是想描述函数类型本身（函数可以被调用），使用函数类型表达式</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fnType = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn: fnType = (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用签名"><a href="#调用签名" class="headerlink" title="调用签名"></a>调用签名</h2><ul><li>如果想描述一个带有属性的函数，可以在一个对象类型中写一个<code>调用签名</code></li><li>如果在描述函数作为对象可以被调用，同时也有其他属性时，使用调用签名<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ISign &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">  <span class="comment">// 函数调用签名</span></span><br><span class="line">  (v: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sign: ISign = (v: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sign.name = <span class="string">&#x27;wangbowen&#x27;</span></span><br><span class="line">sign.age = <span class="number">18</span></span><br><span class="line">sign(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="构造签名"><a href="#构造签名" class="headerlink" title="构造签名"></a>构造签名</h2></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ICTOR &#123;</span><br><span class="line">  <span class="keyword">new</span> (): Person</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personFn</span>(<span class="params">fn: ICTOR</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f = <span class="keyword">new</span> fn()</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><ul><li><p>在typescript中，我们可以去<code>编写不同的重载签名</code>来表示<code>函数可以以不同的方式调用</code></p></li><li><p>一般是<code>编写两个或以上的重载签名</code>，再去<code>编写一个通用的函数以及实现</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先编写重载签名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commonFn</span>(<span class="params">v1: <span class="built_in">number</span>, v2: <span class="built_in">number</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">commonFn</span>(<span class="params">v1: <span class="built_in">string</span>, v2: <span class="built_in">string</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function">// 再编写一个通用的函数，通用函数不能被调用</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">commonFn</span>(<span class="params">v1: <span class="built_in">any</span>, v2: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">return</span> <span class="title">v1</span> + <span class="title">v2</span></span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">commonFn</span>(<span class="params"><span class="number">1</span>, <span class="number">2</span></span>)</span>;</span><br><span class="line">commonFn(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">commonFn(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>); <span class="comment">// 有实现体的函数不能被调用，会报错</span></span><br></pre></td></tr></table></figure><h2 id="this的内置工具"><a href="#this的内置工具" class="headerlink" title="this的内置工具"></a>this的内置工具</h2></li><li><p>ThisType：被用作标记一个上下文的this类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IStore &#123;</span><br><span class="line">  state: IState</span><br><span class="line">  swiming: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  running: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: IStore &amp; ThisType&lt;IState&gt; = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&quot;wangbowen&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  swiming: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过ThisType标记后，可以直接通过this拿到name属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  running: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过ThisType标记后，可以直接通过this拿到age属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript4（接口和对象类型）</title>
      <link href="2023/03/04/typescript4-jie-kou-he-dui-xiang-lei-xing/"/>
      <url>2023/03/04/typescript4-jie-kou-he-dui-xiang-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="对象的类型"><a href="#对象的类型" class="headerlink" title="对象的类型"></a>对象的类型</h2><ul><li><p>在typescript中，我们定义对象的方式要用关键字<code>interface（接口）</code></p></li><li><p>使用<code>interface</code>定义一种约束，让数据的结构满足约束的格式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：使用接口约束的时候不能多也不能少</span></span><br><span class="line"><span class="comment">// 必须和接口保持一致</span></span><br><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wang: People = &#123;</span><br><span class="line">  name: <span class="string">&quot;wangbowen&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果interface重名，会将重名interface进行合并，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>extends</code>关键字可以进行继承操作，如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exObj: B = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>implements</code>关键字可以进行接口的实现操作,如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IKun &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  playBall: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IWang &#123;</span><br><span class="line">  going: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personb</span> <span class="title">implements</span> <span class="title">IKun</span>, <span class="title">IWang</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">playBall</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">going</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ikun = <span class="keyword">new</span> Person();</span><br><span class="line">ikun.playBall()</span><br><span class="line">ikun.going()</span><br></pre></td></tr></table></figure><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2></li><li><p>使用?操作符表示该属性可以存在，也可以不存在</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sex为可选属性，所以不写也不会报错</span></span><br><span class="line"><span class="keyword">const</span> wang: People = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h2></li><li><p>通过<code>[key: string | number]</code>来表示索引签名，其中key可以根据自己的喜好取名</p></li><li><p>一个索引签名的属性必须是<code>string或number类型中的一种</code>,但数字索引的返回类型一定要是字符索引返回类型的子类型</p></li><li><p><strong>一旦定义了索引签名，那么确定的属性和可选属性的类型必须是他的类型的子类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span>,</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p: A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  sex: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2></li><li><p>通过<code>readonly</code>表示该属性只能读取，无法赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">  sex?: <span class="built_in">string</span>,</span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people: A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  habby: <span class="string">&#x27;sing&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(people.name); <span class="comment">// wangbowen</span></span><br><span class="line">people.name = <span class="string">&quot;lxd&quot;</span>; <span class="comment">// 这样是不被允许的，因为name为只读属性</span></span><br></pre></td></tr></table></figure><h2 id="添加函数"><a href="#添加函数" class="headerlink" title="添加函数"></a>添加函数</h2></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span>,</span><br><span class="line">  cb: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people: A = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wangbowen&#x27;</span>,</span><br><span class="line">  cb: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;lxd&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript3（数组类型）</title>
      <link href="2023/03/04/typescript3-shu-zu-lei-xing/"/>
      <url>2023/03/04/typescript3-shu-zu-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型[]"></a>类型[]</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 如果这样定义会报错，因为只能传数字类型</span></span><br><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="comment">// 这样也会报错</span></span><br><span class="line"><span class="keyword">const</span> arr2: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr2.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以定义其他类型的数组</span></span><br><span class="line"><span class="keyword">const</span> arr4: <span class="built_in">string</span>[] = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr5: <span class="built_in">boolean</span>[] = [<span class="literal">true</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">const</span> arr6: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure><h2 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="用接口表示数组"><a href="#用接口表示数组" class="headerlink" title="用接口表示数组"></a>用接口表示数组</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ArrayNumber &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr: ArrayNumber = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="arguments类数组"><a href="#arguments类数组" class="headerlink" title="arguments类数组"></a>arguments类数组</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args: <span class="built_in">any</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// arguments是类数组，不能这样定义</span></span><br><span class="line">  <span class="keyword">const</span> arr: <span class="built_in">number</span>[] = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="comment">// 需要使用ts内置对象IArguments</span></span><br><span class="line">  <span class="comment">// IArguments &#123;</span></span><br><span class="line">  <span class="comment">//   [index: number]: any;</span></span><br><span class="line">  <span class="comment">//   length: number;</span></span><br><span class="line">  <span class="comment">//   callee: Function</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">const</span> arr1: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript2（任意类型）</title>
      <link href="2023/02/21/typescript2-ren-yi-lei-xing/"/>
      <url>2023/02/21/typescript2-ren-yi-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h3><ul><li>没有强制限定哪种类型,可以随时切换类型。可以对any进行任何操作</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  anys: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">anys = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">anys = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>如果声明时没有指定类型默认为any</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anys;</span><br><span class="line"></span><br><span class="line">anys = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">anys = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="unknown类型"><a href="#unknown类型" class="headerlink" title="unknown类型"></a>unknown类型</h3><ul><li><code>unknown类型</code>是typescript中比较特殊的一种类型，它用于描述类型的不确定的变量</li><li>和<code>any类型</code>有点类似，但是unknown类型的值上做任何事情都是不合法的</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unknownTest: unknown</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unknownTest.length); <span class="comment">// 会报错“unknownn”的类型为“未知”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要操作unknown类型的属性，要进行类型判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> unknownTest === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(unknownTest.length); <span class="comment">// 这样就可以正常使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">mes: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(<span class="keyword">typeof</span> mes) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">      <span class="comment">// 程序员1的逻辑</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">      <span class="comment">// 程序员2的逻辑</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 如果程序员3未进行逻辑处理，会导致报错 Type &#x27;boolean&#x27; is not assignable to type &#x27;never&#x27;.</span></span><br><span class="line">      <span class="keyword">const</span> check: <span class="built_in">never</span> = message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleMessage(<span class="number">1</span>); <span class="comment">// 被允许</span></span><br><span class="line">handleMessage(<span class="string">&#x27;2&#x27;</span>); <span class="comment">// 被允许</span></span><br><span class="line">handleMessage(<span class="literal">true</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="元组类型（tuple）"><a href="#元组类型（tuple）" class="headerlink" title="元组类型（tuple）"></a>元组类型（tuple）</h3><ul><li><p><strong>数组中通常建议存放相同类型的元素，不同类型的元素是不推荐存放在数组中</strong>（可以放到对象或元组中）</p></li><li><p><strong>元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型</strong></p></li><li><p>在函数中使用<code>元组类型</code>是最多的（函数的返回值）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">T</span>&gt;(<span class="params">state: T</span>): [<span class="title">T</span>, (<span class="params">newValue: T</span>) =&gt; <span class="title">void</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stateValue = state;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setValue</span>(<span class="params">newValue: T</span>) </span>&#123;</span><br><span class="line">    stateValue = newValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [stateValue, setValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就很容易区分，函数的返回值里各个元素的类型</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line">setCount(<span class="number">1</span>);</span><br><span class="line">count(); <span class="comment">// Type &#x27;Number&#x27; has no compatible call signatures.</span></span><br></pre></td></tr></table></figure><h3 id="keyof-any"><a href="#keyof-any" class="headerlink" title="keyof any"></a>keyof any</h3></li><li><p><code>keyof any</code>返回一个固定的约束类型: <strong>type key = string | number | symbol</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript1（基础类型）</title>
      <link href="2023/02/21/typescript1-ji-chu-lei-xing/"/>
      <url>2023/02/21/typescript1-ji-chu-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&quot;wang&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用es6的字符串模板</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>支持十六进制、十进制、八进制和二进制</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nan: <span class="built_in">number</span> = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> inf: <span class="built_in">number</span> = <span class="literal">Infinity</span>;</span><br><span class="line"><span class="keyword">let</span> decimal: <span class="built_in">number</span> = <span class="number">6</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> hex: <span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> binary: <span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br></pre></td></tr></table></figure><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>需要注意,使用构造函数Boolean创建的对象不是布尔值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cb: <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>); <span class="comment">// new Boolean()返回的是一个实例对象</span></span><br><span class="line"><span class="comment">// 正确定义</span></span><br><span class="line"><span class="keyword">let</span> cb: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bl: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> bl1: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="空值类型"><a href="#空值类型" class="headerlink" title="空值类型"></a>空值类型</h2><ul><li>在typescript中,通过void来表示没有返回值的函数</li><li>如果我们不希望调用者关心函数返回值的情况下,比如通常的异步回调函数。可以使用void类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>void也可以定义undefined和null类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> un: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="built_in">void</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="null和undefined类型"><a href="#null和undefined类型" class="headerlink" title="null和undefined类型"></a>null和undefined类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><code>undefined</code>和<code>null</code>是所有类型的子类型,如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将undefined和null赋值给其他类型不会报错</span></span><br><span class="line"><span class="keyword">let</span> nu: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">num = nu</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="keyword">let</span> un: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> num1: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line">num1 = num1;</span><br></pre></td></tr></table></figure><p><strong>如果配置tsconfig.json严格模式时,null不能赋值void类型</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3相关知识点</title>
      <link href="2022/10/20/vue3-xiang-guan-zhi-shi-dian/"/>
      <url>2022/10/20/vue3-xiang-guan-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="全局事件总线mitt库"><a href="#全局事件总线mitt库" class="headerlink" title="全局事件总线mitt库"></a>全局事件总线mitt库</h2><ul><li><p>安装mitt库: npm install mitt</p></li><li><p>封装一个eventBus.js,如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emitter = mitt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter;</span><br></pre></td></tr></table></figure></li><li><p>进行兄弟组件的通讯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兄弟1</span></span><br><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;./utils/eventBus.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      emitter.emit(<span class="string">&#x27;事件名&#x27;</span>, <span class="string">&#x27;需要发送的数据&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 兄弟2</span></span><br><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;./utils/eventBus.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    emitter.on(<span class="string">&#x27;事件名&#x27;</span>, <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我接收到兄弟1发送过来的数据了&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 监听全部事件</span></span><br><span class="line">    emitter.on(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">type, params</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 其中 type为传递过来的事件名</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mitt的事件取消</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消emitter中所有监听</span></span><br><span class="line">emitter.all.clear()</span><br><span class="line"><span class="comment">// 取消单个监听,fn为定义的函数</span></span><br><span class="line">emitter.off(<span class="string">&#x27;foo&#x27;</span>, fn);</span><br></pre></td></tr></table></figure><h2 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h2></li><li><p>通过<code>v-slot:[dynamicSlotName]</code>方式动态绑定一个名称，缩写为<code>#[dynamicSlotName]</code></p></li></ul><h2 id="动态组件的实现"><a href="#动态组件的实现" class="headerlink" title="动态组件的实现"></a>动态组件的实现</h2><ul><li>动态组件是使用<code>component组件</code>,通过一个特殊的<code>attribute is</code>来实现: <code>&lt;component :is=&quot;current&quot;&gt;&lt;/component&gt;</code></li><li>current的值需要的内容可以是<ol><li>可以是通过<strong>component函数注册</strong>的组件;</li><li>在一个<strong>组件对象的components对象</strong>中注册的组件;</li></ol></li><li>动态组件的传值和普通父子组件一样,只是需要将<strong>属性和监听事件</strong>放到component上使用</li></ul><h2 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h2><ul><li>开发中如果希望继续保持组件的状态,而不是销毁掉。可以使用<strong>内置组件:keep-alive</strong></li><li>keepAlive的一些属性:<ol><li><strong>include</strong>(string|RegExp|Array)。只有名称匹配的组件会被缓存</li><li><strong>exclude</strong>(string|RegExp|Array)。任何名称匹配的组件都不会被缓存</li><li><strong>max</strong>(number|string)。最多可以缓存多少组件实例,一点到达这个数字,那么缓存组件中最近没有被访问的实例会被销毁。</li></ol></li><li>include和exclude prop允许组件有条件的缓存<ol><li>两者都可以用<strong>逗号分隔字符串、正则表达式或一个数组</strong>来表示</li><li>匹配首先检测组件自身的name选项</li></ol></li></ul><h2 id="webpack的代码分包"><a href="#webpack的代码分包" class="headerlink" title="webpack的代码分包"></a>webpack的代码分包</h2><ul><li><p>打包时,代码的分包</p><ol><li>对于一些不需要立即使用的组件,我们可以单独对它们进行拆分,拆分成一些小的代码块chunk.js</li><li>这些chunk.js会在需要时从服务器加载下来,并且运行代码,显示对的内容</li></ol></li><li><p>webpack如何可以对代码进行分包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./utils/math&quot;</span>).then(<span class="function">(<span class="params">&#123; sum &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue中实现异步组件"><a href="#Vue中实现异步组件" class="headerlink" title="Vue中实现异步组件"></a>Vue中实现异步组件</h2></li><li><p>如果项目过大,对于某些组件我们希望<code>通过异步的方式进行加载</code>(目的是可以对其进行分包处理)</p></li><li><p>Vue中提供了一个函数,<strong>defineAsyncComponent</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">// 写法一: 传入一个工厂函数</span></span><br><span class="line"><span class="keyword">const</span> AsyncCategory = defineAsyncComponent(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;组件路径地址&quot;</span>))</span><br><span class="line"><span class="comment">// 写法二: 传入一个对象</span></span><br><span class="line"><span class="keyword">const</span> AsyncCategory = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./AsyncCategory.vue&quot;</span>),</span><br><span class="line">  <span class="comment">// 组件还没加载时,可以传入一个loading组件进行占位</span></span><br><span class="line">  loadingComponent: <span class="string">&quot;./Loading.vue&quot;</span>,</span><br><span class="line">  <span class="comment">// 组件加载失败时,可以传入一个error组件进行占位</span></span><br><span class="line">  errorComponent: <span class="string">&quot;./Error.vue&quot;</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * err: 错误信息,</span></span><br><span class="line"><span class="comment">   * retry: 函数,调用retry尝试重新加载</span></span><br><span class="line"><span class="comment">   * fail: 函数,指示加载程序结束退出</span></span><br><span class="line"><span class="comment">   * attempts: 记录尝试次数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onError: <span class="function"><span class="keyword">function</span>(<span class="params">err, retry, fail, attempts</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="异步组件和suspense"><a href="#异步组件和suspense" class="headerlink" title="异步组件和suspense"></a>异步组件和suspense</h2></li><li><p>suspense是一个内置的全局组件,该组件有两个插槽</p><ol><li>default: 如果default可以显示,那么显示default的内容</li><li>fallback: 如果default无法显示,那么会显示fallback插槽的内容<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">suspense</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    hello!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span><br><span class="line">    失败!</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">suspense</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="transition动画"><a href="#transition动画" class="headerlink" title="transition动画"></a>transition动画</h2><ul><li>过渡动画class<ol><li>v-enter-from: 定义进入过渡的开始状态。元素被插入之前生效,在元素被插入后的下一帧移除。</li><li>v-enter-active: 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用,在元素被插入之前生效,在过渡/动画完成后移除。这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数。</li><li>v-enter-to: 定义进入过渡的结束状态。在元素被插入后下一帧生效,在过渡/动画完成后移除。</li><li>v-leave-from: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效,下一帧被移除。</li><li>v-leave-active: 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用,在离开过渡被触发时立刻生效,在过渡/动画完成后移除。这个类可以被用来定义进入过渡的过程时间、延迟和曲线函数。</li><li>v-leave-to: 离开过渡的结束状态。在离开过渡被触发之后下一帧生效,在过度/动画完成后移除。</li></ol></li><li>class的name命名规则<ol><li>如果我们使用的是一个没有name的transition,那么所有的class是以v-作为默认前缀</li><li>如果添加了name属性,比如<code>&lt;transition name=&quot;wang&quot;&gt;</code>,那么所有的class要以wang-开头</li></ol></li></ul><h3 id="同时设置过渡-transition-和动画-animation"><a href="#同时设置过渡-transition-和动画-animation" class="headerlink" title="同时设置过渡(transition)和动画(animation)"></a>同时设置过渡(transition)和动画(animation)</h3><ul><li><p>一般这种情况下,可以设置type属性为animation或者transition来明确告知Vue监听的类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">type</span>=<span class="string">&quot;animation/transition&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="过渡模式mode"><a href="#过渡模式mode" class="headerlink" title="过渡模式mode"></a>过渡模式mode</h3></li><li><p>如果不希望同时执行进入和离开动画,那么我们需要设置transition的过渡模式</p><ol><li><code>in-out</code>: 新元素先进行过渡,完成后当前元素过渡离开</li><li><code>out-in</code>: 当前元素先进行过渡,完成后新元素过渡进入</li></ol></li></ul><h3 id="appear初次渲染"><a href="#appear初次渲染" class="headerlink" title="appear初次渲染"></a>appear初次渲染</h3><ul><li><p>默认情况下,首次渲染的时候是没有动画的,可以增加一个属性appear</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span>&gt;</span><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript钩子"><a href="#JavaScript钩子" class="headerlink" title="JavaScript钩子"></a>JavaScript钩子</h3></li><li><p>transition组件提供了八种钩子,可以帮助我们监听动画执行到什么阶段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加:css=&quot;false&quot;会让Vue跳过css的检测,性能会提升以及避免css影响过渡动画 --&gt;</span></span><br><span class="line">&lt;transition</span><br><span class="line">  @before-enter=&quot;beforeEnter&quot;</span><br><span class="line">  @enter=&quot;enter&quot;</span><br><span class="line">  @after-enter=&quot;afterEnter&quot;</span><br><span class="line">  @enter-cancelled=&quot;enterCancelled&quot;</span><br><span class="line">  @before-leave=&quot;beforeLeave&quot;</span><br><span class="line">  @leave=&quot;leave&quot;</span><br><span class="line">  @after-leave=&quot;afterLeave&quot;</span><br><span class="line">  @leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class="line">  :css=&quot;false&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在使用JavaScript来执行过渡动画时,需要<code>进行done回调</code>,否则它们将会被同步调用，过渡会立即完成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">enter</span>(<span class="params">el, done</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;进入&quot;</span>)</span><br><span class="line">  done();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">leave</span>(<span class="params">el, done</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;离开&quot;</span>);</span><br><span class="line">  done();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2></li><li><p>Mixin用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mixin/mDemo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mixins = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&quot;hello mixin&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xxx.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">&quot;./Mixin/mDemo.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mixins: [mixins],</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.message); <span class="comment">// hello mixin</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是data函数的返回值对象</p><ol><li>返回值对象默认情况下会进行合并</li><li>如果data返回值对象的属性发生了冲突,那么会保留组件自身的数据</li></ol></li><li><p>如果是生命周期钩子函数</p><ol><li>生命周期的钩子函数会被合并到数组中,都会被调用</li></ol></li><li><p>值为对象的选项,例如methods、components和directives,将被合并为同一个对象</p><ol><li>比如都有methods选项,并且都定义了方法,那么都会生效</li><li>但是如果对象的key相同,那么<strong>会取组件对象的键值对</strong></li></ol></li><li><p>如果组件中的某些选项,是所有组件都需要的,那么可以使用全局mixin(一旦注册,那么全局混入的选项将会影响每一个组件)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.mixin(&#123;</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我会在所有组件中打印&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><ul><li>set函数有两个参数分别是<code>props</code>和<code>context</code>,<strong>setup中不可以通过this去获取</strong></li><li>props就是<strong>父组件传递过来的属性会被放到props对象中</strong>,我们在setup中如果需要使用,就可以通过props参数获取</li><li>context包含三个属性<ol><li>attrs: 所有的非props的attribute</li><li>slots: 父组件传递过来的插槽</li><li>emit: 当组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）</li></ol></li></ul><h3 id="setup函数的返回值"><a href="#setup函数的返回值" class="headerlink" title="setup函数的返回值"></a>setup函数的返回值</h3><ul><li><p>setup是一个函数,那么它也可以有返回值</p><ol><li>setup的返回值可以在<strong>模板template中被使用</strong></li><li>也就是说可以<strong>通过setup的返回值来替代vue2中的data选项</strong></li></ol></li><li><p>甚至可以返回一个执行函数来替代在methods中定义的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&quot;wbw&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> decrement = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">      counter,</span><br><span class="line">      increment,</span><br><span class="line">      decrement</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setup不可以使用this"><a href="#setup不可以使用this" class="headerlink" title="setup不可以使用this"></a>setup不可以使用this</h3></li><li><p>在setup中应该避免使用<code>this</code>,因为他不会找到组件实例。setup的调用发生在<code>data property</code>、<code>computed property</code>或<code>methods</code>被解析之前,所以它们无法在setup中被获取。</p></li></ul><h3 id="Reactive-API"><a href="#Reactive-API" class="headerlink" title="Reactive API"></a>Reactive API</h3><ul><li>可以使用reactive对定义的数据提供响应式的特性</li><li>reactive API对传入的类型是有限制的,必须传入<code>数组或对象类型</code></li></ul><h3 id="Ref-API"><a href="#Ref-API" class="headerlink" title="Ref API"></a>Ref API</h3><ul><li>ref会返回一个<code>可变的响应式对象</code>,该对象作为一个响应式的引用维护着它内部的值。</li><li>它内部的值是在<code>ref的value属性</code>中被维护的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      count.value++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      increment</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<code>模板中引入ref的值</code>时,Vue会<code>自动帮助我们进行解包</code>操作,所以我们并不需要在模板中通过<code>ref.value</code>的方式</li><li>但在setup函数内部,它依然是一个ref引用,所以对其进行操作时,我们依然需要使用ref.value的方式</li></ul><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><ul><li>传入给其他地方(组件)的这个响应式对象希望在另一个地方(组件)被使用,但不能被修改时可以使用<code>readonly</code></li><li><code>readonly</code>返回原生对象的只读代理</li></ul><h3 id="Reactive判断的API"><a href="#Reactive判断的API" class="headerlink" title="Reactive判断的API"></a>Reactive判断的API</h3><ul><li>isProxy: 检查对象是否是由reactive或readonly创建的proxy</li><li>isReactive: 检查对象是否是由reactive创建的响应式代理。如果该代理是readonly创建的,但包裹了由reactive创建的另一个代理,它也会返回true</li><li>isReadonly: 检查对象是否由readonly创建的只读代理</li><li>shallowReactive: 创建一个响应式代理,但<code>不执行嵌套对象的深层响应式转换</code>（深层还是原生对象）</li><li>shallowReadonly: 创建一个proxy,使其自身的property只读,但<code>不执行嵌套对象的深度只读转换</code>（深度还是可读、可写的）</li></ul><h3 id="toRefs和toRef"><a href="#toRefs和toRef" class="headerlink" title="toRefs和toRef"></a>toRefs和toRef</h3><ul><li><p>Vue提供了一个<code>toRefs函数</code>,可以将<strong>reactive返回的对象中的属性都转成ref</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      name: <span class="string">&quot;wbw&quot;</span>,</span><br><span class="line">      age: <span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 这样解构reactive返回的对象数据就不再是响应式的了</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = state;</span><br><span class="line">    <span class="comment">// 通过toRefs包裹后,解构出来的name和age就是ref的</span></span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = toRefs(state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">      age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这种做法相当于已经在state.name和ref.value之间建立了连接,<strong>任何一个修改都会引起另一个变化</strong></p></li><li><p>如果只希望转换一个reactive对象中的属性为ref,可以使用<code>toRef函数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      name: <span class="string">&quot;wbw&quot;</span>,</span><br><span class="line">      age: <span class="number">18</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> name = toRef(state, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> changeName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      state.name = <span class="string">&quot;lxd&quot;</span>;</span><br><span class="line">      <span class="comment">// 或者</span></span><br><span class="line">      <span class="comment">// name.value = &quot;lxd&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">      changeNameq</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ref其他的API"><a href="#ref其他的API" class="headerlink" title="ref其他的API"></a>ref其他的API</h3></li><li><p>unref: 相当于<code>val = isRef(val) ? val.value : val;</code>的语法糖</p></li><li><p>isRef: 判断值是否是一个ref对象</p></li><li><p>shallowRef: 创建一个浅层的ref对象</p></li><li><p>triggerRef: 手动触发和shallowRef相关联的副作用</p></li></ul><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> value = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> counter.value++;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> value = computed(&#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> counter.value++;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">values</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect和watch"><a href="#watchEffect和watch" class="headerlink" title="watchEffect和watch"></a>watchEffect和watch</h3><ul><li><code>watchEffect</code>会自动收集响应式的依赖<ol><li>watchEffect传入的函数会被立即执行一次,并且在执行过程中会收集依赖;</li><li>只有收集的依赖发生变化时,watchEffect传入的函数才会再次执行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> name = ref(<span class="string">&quot;wbw&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> age = ref(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">  watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;watchEffect&quot;</span>, name.value, age.value)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>如果在发生某些情况下希望停止侦听,可以<code>获取到watchEffect的返回值函数并调用</code></li><li>watchEffect清除副作用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  watchEffect(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="comment">// 在这个函数中可以做一些清理相关的工作</span></span><br><span class="line">      onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li>watch<ol><li>侦听单个数据源<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; watch, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> info = reactive(&#123;</span><br><span class="line">    name: <span class="string">&quot;wbw&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法一：侦听watch时,传入一个getter函数</span></span><br><span class="line">  watch(<span class="function">() =&gt;</span> info.name, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newValue, oldValue); <span class="comment">// lxd wbw</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法二：传入一个可响应对象：reactive对象/ref对象</span></span><br><span class="line">  <span class="comment">// 如果传入的是reactive对象时,新旧值是reactive对象</span></span><br><span class="line">  watch(info, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newValue, oldValue); <span class="comment">// &#123; name: &quot;lxd&quot;, age: 18 &#125; &#123; name: &quot;wbw&quot;, age: 18 &#125;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果希望reactive的新旧值是普通对象</span></span><br><span class="line">  watch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;...info&#125;</span><br><span class="line">  &#125;, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 如果传入的是ref对象时,新旧值是value值本身</span></span><br><span class="line">  <span class="keyword">const</span> name = ref(<span class="string">&quot;wbw&quot;</span>);</span><br><span class="line">  watch(name, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newValue, oldValue); <span class="comment">// lxd wbw</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    info.name = <span class="string">&quot;lxd&quot;</span>;</span><br><span class="line">    <span class="comment">// 如果是ref对象时</span></span><br><span class="line">    name.value = <span class="string">&quot;lxd&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>侦听多个数据源<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123; ref, reactive, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> name = ref(<span class="string">&quot;wbw&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> info = reactive(&#123;</span><br><span class="line">    name: <span class="string">&quot;wbw&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  watch([info, name], <span class="function">(<span class="params">[newInfo, newName], [oldInfo, oldName]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    info.name = <span class="string">&quot;lxd&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>watch侦听器的第三个参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch(() = (&#123;...info&#125;), <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  deep: <span class="literal">true</span> <span class="comment">// 如果传入的是一个reactive对象,默认为深度监听;其他则需要手动设置深度监听模式</span></span><br><span class="line">  immediate: <span class="literal">true</span> <span class="comment">// 是否立即执行,和vue2的监听器一样</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Provide和Inject"><a href="#Provide和Inject" class="headerlink" title="Provide和Inject"></a>Provide和Inject</h3></li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, provide, readonly &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = ref(<span class="string">&quot;wbw&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果使用provide向子孙组件传递数据时,最好使用readonly包裹一下,避免子孙组件修改父组件传递过去的值。不符合单向数据流规则</span></span><br><span class="line">    provide(<span class="string">&quot;name&quot;</span>, readonly(name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      name.value = <span class="string">&quot;lxd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      increment,</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name = inject(<span class="string">&quot;name&quot;</span>); <span class="comment">// 第二个参数可以设置一个默认值</span></span><br></pre></td></tr></table></figure><h3 id="使用localStorage存取数据的hook"><a href="#使用localStorage存取数据的hook" class="headerlink" title="使用localStorage存取数据的hook"></a>使用localStorage存取数据的hook</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useStorage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; watch, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = ref(value);</span><br><span class="line">  <span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="built_in">window</span>.localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data.value = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watch(data, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h3><ul><li><p>render函数如何写插槽,以及如何使用作用域插槽</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(myComponent, &#123;&#125;, &#123;</span><br><span class="line">      <span class="comment">// 作用域插槽</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> h(<span class="string">&quot;span&quot;</span>, &#123;&#125;, <span class="string">`你好,<span class="subst">$&#123;props.name&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&quot;div&quot;</span>, &#123;&#125;, [</span><br><span class="line">      h(<span class="string">&quot;h3&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;1&quot;</span>),</span><br><span class="line">      <span class="comment">// 这里是插槽，插槽调用可以通过传参的方式给父组件提供数据</span></span><br><span class="line">      <span class="built_in">this</span>.$slot.default ? <span class="built_in">this</span>.$slot.default(&#123;</span><br><span class="line">        name: <span class="string">&quot;世界&quot;</span></span><br><span class="line">      &#125;) : <span class="string">&quot;我是默认值&quot;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jsx的Babel配置"><a href="#jsx的Babel配置" class="headerlink" title="jsx的Babel配置"></a>jsx的Babel配置</h3></li><li><p>安装Babel支持Vue的jsx插槽：npm install @vue/babel-plugin-jsx -D</p></li><li><p>在babel.config.js中配置插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">&quot;@vue/babel-plugin-jsx&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>jsx编写方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myComponent <span class="keyword">from</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> <span class="built_in">this</span>.counter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;当前计数：&#123; <span class="built_in">this</span>.counter &#125;&lt;/h2&gt;</span><br><span class="line">        &lt;button onClick=&#123;increment&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">        &lt;myComponent /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue3中获取ref"><a href="#vue3中获取ref" class="headerlink" title="vue3中获取ref"></a>vue3中获取ref</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// &lt;input ref=&quot;input&quot;&gt;&lt;/input&gt;</span></span><br><span class="line">    <span class="keyword">const</span> input = ref(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">onMounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(input.value); <span class="comment">// 会获取到input输入框的DOM信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      input</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue3自定义指令的钩子函数"><a href="#vue3自定义指令的钩子函数" class="headerlink" title="vue3自定义指令的钩子函数"></a>vue3自定义指令的钩子函数</h3></li><li><p>created: 在绑定元素的attribute或事件监听器被应用之前调用</p></li><li><p>beforeMount: 当指令第一次绑定到元素并且挂载父组件之前调用</p></li><li><p>mounted: 在绑定元素的父组件被挂载后调用</p></li><li><p>beforeUpdate: 在更新包含组件的vnode之前调用</p></li><li><p>updated: 在包含组件的vnode及其子组件的vnode更新后调用</p></li><li><p>beforeUnmount: 在卸载绑定元素的父组件之前调用</p></li><li><p>unmounted: 当指令与元素解除绑定且父组件已卸载时,只调用一次</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack、VueCLI以及vite</title>
      <link href="2022/08/16/webpack-he-vite/"/>
      <url>2022/08/16/webpack-he-vite/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack.config.js</p><h3 id="配置css"><a href="#配置css" class="headerlink" title="配置css"></a>配置css</h3><ol><li><p>下载<code>style-loader</code>、<code>css-loader</code>和<code>less-loader</code>,并在<code>module配置</code>中添加这些loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install --save-dev style-loader css-loader</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>, <span class="comment">// 设置模式,一般有开发模式和生产模式(production)</span></span><br><span class="line">  devtool: <span class="string">&quot;source-map&quot;</span>, <span class="comment">// 设置source-map,建立js映射文件,方便调试代码和错误</span></span><br><span class="line">  entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;./build&quot;</span>),</span><br><span class="line">    <span class="comment">// js/xxx.js可以将js文件放到指定文件夹下</span></span><br><span class="line">    filename: <span class="string">&quot;js/bundle.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则表达式</span></span><br><span class="line">        <span class="comment">// loader: &quot;css-loader&quot; 语法糖</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// loader执行顺序是从右向左(从下到上或从后往前),所以style-loader写在前面</span></span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;postcss-loader&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// less-loader</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          <span class="string">&quot;less-loader&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// postcss.config.js 将postcss配置信息抽离</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * PostCSS工具：可以进行一些css的转换和适配（自动添加前缀、css样式重置）</span></span><br><span class="line"><span class="comment">   * 安装`postcss`和`postcss-cli`: npm install postcss postcss-cli -D</span></span><br><span class="line"><span class="comment">   * 因为需要添加前缀,所以要安装autoprefixer: npm install autoprefixer -D</span></span><br><span class="line"><span class="comment">   * postcss-preset-env内置了autoprefixer,功能更强大: npm install postcss-preset-env -D</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// require(&quot;autoprefixer&quot;)</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置图片"><a href="#配置图片" class="headerlink" title="配置图片"></a>配置图片</h3></li><li><p>处理jpg、png等格式的图片,需要用到<code>file-loader</code>: <strong>npm install file-loader -D</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            <span class="comment">// 可以给打包的图片指定文件夹名称</span></span><br><span class="line">            <span class="comment">// outputPath: &quot;imgs&quot;,</span></span><br><span class="line">            <span class="comment">// 打包后图片的名称(imgs/的作用和outputPath一样,是一种简写)</span></span><br><span class="line">            name: <span class="string">&quot;imgs/[name]_[hash:6].[ext]&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将较小的文件转成base64和URI,需要用到<code>url-loader</code>: <strong>npm install url-loader -D</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 注意：如配置了url-loader则不需要再配置file-loader</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&quot;url-loader&quot;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            <span class="comment">// 可以给打包的图片指定文件夹名称</span></span><br><span class="line">            <span class="comment">// outputPath: &quot;imgs&quot;,</span></span><br><span class="line">            <span class="comment">// 打包后图片的名称(imgs/的作用和outputPath一样,是一种简写)</span></span><br><span class="line">            name: <span class="string">&quot;imgs/[name]_[hash:6].[ext]&quot;</span>,</span><br><span class="line">            limit: <span class="number">100</span> * <span class="number">1024</span> <span class="comment">// 表示小于100kb时才会做base64处理</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asset-module-type"><a href="#asset-module-type" class="headerlink" title="asset module type"></a>asset module type</h3></li><li><p>webpack5开始,可以直接使用**资源模块类型(asset module type)**替代loader</p></li></ol><ul><li><code>asset/resource</code>发送一个单独的文件并导出URL，之前通过使用file-loader实现</li><li><code>asset/inline</code>导出一个资源的data URI，之前通过使用url-loader实现</li><li><code>asset</code>在导出一个data URI和发送一个单独的文件之间自动选择。之前使用url-loader并配置资源体积实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;img/[name]_[hash:6][ext]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: <span class="number">100</span> * <span class="number">1024</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载字体文件"><a href="#加载字体文件" class="headerlink" title="加载字体文件"></a>加载字体文件</h3></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(eot|ttf|woff2?)$/</span>,</span><br><span class="line">        type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&quot;font/[name]_[hash:6][ext]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// use: &#123;</span></span><br><span class="line">        <span class="comment">//   loader: &quot;file-loader&quot;,</span></span><br><span class="line">        <span class="comment">//   options: &#123;</span></span><br><span class="line">        <span class="comment">//     // 可以给打包的图片指定文件夹名称</span></span><br><span class="line">        <span class="comment">//     // outputPath: &quot;font&quot;,</span></span><br><span class="line">        <span class="comment">//     // 打包后图片的名称(imgs/的作用和outputPath一样,是一种简写)</span></span><br><span class="line">        <span class="comment">//     name: &quot;font/[name]_[hash:6].[ext]&quot;</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><ol><li>CleanWebpackPlugin</li></ol><ul><li>自动删除dist文件夹</li><li>npm install clean-webpack-plugin -D<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>HtmlWebpackPlugin</li></ol><ul><li>在项目部署时,需要有对应的入口文件index.html。利用<code>HtmlWebpackPlugin</code>对index.html进行打包处理</li><li>npm install HtmlWebpackPlugin -D<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&quot;./public/index.html&quot;</span>, <span class="comment">// 可自定义生成模板的格式,vue中就是在public下的index.html指定了特定模板</span></span><br><span class="line">      title: <span class="string">&quot;我是标题&quot;</span>, <span class="comment">// 用于修改浏览器中显示的标题信息</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>DefinePlugin</li></ol><ul><li>webpack内置插件,一般在模版中还会使用到一个<code>BASE_URL</code>的常量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">      BASE_URL: <span class="string">&quot;&#x27;./&#x27;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>CopyWebpackPlugin</li></ol><ul><li>作用：文件的拷贝(静态资源)，打包阶段使用</li><li>npm install copy-webpack-plugin<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 从哪里复制</span></span><br><span class="line">          <span class="keyword">from</span>: <span class="string">&quot;public&quot;</span>,</span><br><span class="line">          <span class="comment">// 复制到的路径</span></span><br><span class="line">          to: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">          globOptions: &#123;</span><br><span class="line">            <span class="comment">// 要忽略的文件</span></span><br><span class="line">            ignore: [</span><br><span class="line">              <span class="string">&quot;**/index.html&quot;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3></li></ul><ol><li>如果要使用Babel,需要安装<code>@babel/core(核心代码)</code>和<code>@babel/cli(可以在命令行使用Babel)</code>,<strong>npm install @babel/core @babel/cli -D</strong></li><li>使用Babel处理源代码:</li></ol><ul><li>src: 源文件的目录;</li><li>–out-dir: 指定要输出的文件夹, npx babel src –out-dir dist;</li><li>–out-file: 指定要输出的文件, npx babel test.js;</li></ul><ol start="3"><li>转换箭头函数,可以直接使用</li></ol><ul><li>npm install @babel/plugin-transform-arrow-functions -D</li><li>npx babel src –out-dir dist –plugin=@babel/plugin-transform-arrow-functions</li></ul><ol start="4"><li>转换const/let为var,可以直接使用</li></ol><ul><li>npm install @babel/plugin-transform-block-scoping -D</li><li>npx babel src –out-dir dist –plugin=@babel/plugin-transform-arrow-functions,@babel/plugin-transform-block-scoping</li></ul><ol start="5"><li>babel的预设preset</li></ol><ul><li>npm install @babel/preset-env -D</li><li>npx babel src –out-dir dist –preset=@babel/preset-env</li></ul><ol start="6"><li>babel-loader</li></ol><ul><li>npm install babel-loader -D<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            <span class="comment">// plugins: [</span></span><br><span class="line">            <span class="comment">//   &quot;@babel/plugin-transform-arrow-functions&quot;,</span></span><br><span class="line">            <span class="comment">//   &quot;@babel/plugin-transform-block-scoping&quot;</span></span><br><span class="line">            <span class="comment">// ]</span></span><br><span class="line">            presets: [</span><br><span class="line">              <span class="string">&quot;@/babel/preset-env&quot;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>Babel的配置文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">&quot;@/babel/preset-env&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为在Babel配置文件中已经配置了, webpack.config.js中只需要</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理Vue"><a href="#处理Vue" class="headerlink" title="处理Vue"></a>处理Vue</h3><ol><li>处理vue3代码</li></ol><ul><li>npm install vue-loader@next -D</li><li>因为vue-loader需要依赖@vue/compiler-sfc,npm install @vue/compiler-sfc -D</li><li>因为vue-loader需要依赖VueLoaderPlugin,如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; VueLoaderPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/dist/index&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">&quot;vue-loader&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin();</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>解决vue3中控制台警告问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; DefinePlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DefinePlugin(&#123;</span><br><span class="line">      BASE_URL: <span class="string">&quot;&#x27;./&#x27;&quot;</span>,</span><br><span class="line">      __VUE_OPTIONS_API__: <span class="literal">true</span>, <span class="comment">// 兼容vue2</span></span><br><span class="line">      __VUE_PROD_DEVTOOLS__: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3></li><li><p>webpack watch模式</p></li></ol><ul><li>该模式下，webpack依赖图中的所有文件，只要有一个<code>发生了更新</code>，那么代码将<code>被重新编译</code></li><li>开启watch方式一：在导出的配置中，添加<strong>watch: true</strong></li><li>方式二：在启动webpack的命令中，添加<code>--watch的标识</code></li></ul><ol start="2"><li>webpack-dev-server</li></ol><ul><li>安装：npm install webpack-dev-server -D</li><li>在package.json的scripts中添加：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;webpack serve&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一般开发阶段编译时，无法拿到public中的静态资源，这时需要配置<code>contentBase</code>告知要从哪里查找静态资源<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&quot;./public&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>webpack-dev-serve在编译后<code>不会写入到任何输出文件</code>,而是将bundle文件<code>保留在内存</code>中。使用的第三方库memfs</li></ul><h3 id="模块热替换-HMR"><a href="#模块热替换-HMR" class="headerlink" title="模块热替换(HMR)"></a>模块热替换(HMR)</h3><ul><li>模块热替换是指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面;</li><li>默认情况下，<code>webpack-dev-server已经支持HMR，只需要开启即可</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 两者同时打开</span></span><br><span class="line">  target: <span class="string">&quot;web&quot;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>HMR的原理<ul><li>webpack-dev-server会创建两个服务: 提供<code>静态资源的服务</code>(express)和<code>Socket服务</code>(net.socket);</li><li>express server负责直接提供静态资源的服务(打包后的资源直接被浏览器请求和解析)</li></ul></li><li>HMR Socket Server,是一个socket长连接:<ul><li>长连接的好处是<code>建立连接后双方可以通信</code>(服务器可以直接发送文件到客户端)</li><li>当服务器监听到对应的模块发生变化时,会生成两个文件.json(mainfest文件)和.js文件(update chunk)</li><li>通过长连接,可以直接将这两个文件主动发送给客户端(浏览器)</li><li>浏览器拿到两个新的文件后,通过HMR runtime机制,加载这两个文件，并且针对修改的文件进行更新</li></ul></li></ul><h3 id="devServer更多设置"><a href="#devServer更多设置" class="headerlink" title="devServer更多设置"></a>devServer更多设置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">// 是否打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设置监听的端口,默认情况下为8080</span></span><br><span class="line">    port: <span class="number">8081</span>,</span><br><span class="line">    <span class="comment">// 是否对资源开启gzip压缩</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 本地解决跨域问题</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        target: <span class="string">&quot;服务器地址:端口号&quot;</span>,</span><br><span class="line">        <span class="comment">// 如果不希望传递/api,则需要重写路径</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve模块解析"><a href="#resolve模块解析" class="headerlink" title="resolve模块解析"></a>resolve模块解析</h3><ul><li><p>如果是一个文件夹，会查看文件名是否具有扩展名，有扩展名则直接打包文件;否则，使用resolve.extensions选项作为文件扩展名解析</p></li><li><p>如果是一个文件夹，会在文件夹中根据resolve.mainFiles(默认值是<code>[&#39;index&#39;]</code>)配置选项中指定的文件顺序查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 配置忽略的文件后缀</span></span><br><span class="line">    extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.mjs&quot;</span>, <span class="string">&quot;.vue&quot;</span>, <span class="string">&quot;.ts&quot;</span>],</span><br><span class="line">    <span class="comment">// 配置路径简写</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.resolve(__dirname, <span class="string">&quot;需要简写的文件路径&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区分开发环境和生产环境"><a href="#区分开发环境和生产环境" class="headerlink" title="区分开发环境和生产环境"></a>区分开发环境和生产环境</h3></li><li><p>config/webpack.comm.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>, <span class="comment">// 设置模式,一般有开发模式和生产模式(production)</span></span><br><span class="line">  devtool: <span class="string">&quot;source-map&quot;</span>, <span class="comment">// 设置source-map,建立js映射文件,方便调试代码和错误</span></span><br><span class="line">  entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;../build&quot;</span>),</span><br><span class="line">    <span class="comment">// js/xxx.js可以将js文件放到指定文件夹下</span></span><br><span class="line">    filename: <span class="string">&quot;js/bundle.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 配置忽略的文件后缀</span></span><br><span class="line">    extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.mjs&quot;</span>, <span class="string">&quot;.vue&quot;</span>, <span class="string">&quot;.ts&quot;</span>],</span><br><span class="line">    <span class="comment">// 配置路径简写</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.resolve(__dirname, <span class="string">&quot;需要简写的文件路径&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 配置信息</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 插件配置</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>config/webpack.dev.config.js并在package.json中设置<strong>serve: “webpack serve –config ./confg/webpack.dev.config.js”</strong>,并通过<code>webpack-merge</code>合并通用配置<strong>npm install webpack-merge -D</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通用配置文件webpack.comm.config.js</span></span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.comm.config.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, &#123;</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  devtool: <span class="string">&quot;source-map&quot;</span>, <span class="comment">// 设置source-map,建立js映射文件,方便调试代码和错误</span></span><br><span class="line">   devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&quot;./public&quot;</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设置监听的端口,默认情况下为8080</span></span><br><span class="line">    port: <span class="number">8081</span>,</span><br><span class="line">    <span class="comment">// 是否对资源开启gzip压缩</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 本地解决跨域问题</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        target: <span class="string">&quot;服务器地址:端口号&quot;</span>,</span><br><span class="line">        <span class="comment">// 如果不希望传递/api,则需要重写路径</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        changeOrigin: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>config/webpack.prod.config.js并在package.json中配置<strong>build: “webpack –config ./config/webpack.prod.config.js”</strong>,并通过<code>webpack-merge</code>合并通用配置<strong>npm install webpack-merge -D</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;copy-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取通用配置文件webpack.comm.config.js</span></span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.comm.config.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, &#123;</span><br><span class="line">  mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 从哪里复制</span></span><br><span class="line">          <span class="keyword">from</span>: <span class="string">&quot;./public&quot;</span>,</span><br><span class="line">          <span class="comment">// 复制到的路径</span></span><br><span class="line">          to: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">          globOptions: &#123;</span><br><span class="line">            <span class="comment">// 要忽略的文件</span></span><br><span class="line">            ignore: [</span><br><span class="line">              <span class="string">&quot;**/index.html&quot;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端部署相关流程</title>
      <link href="2022/04/30/qian-duan-bu-shu-xiang-guan-liu-cheng/"/>
      <url>2022/04/30/qian-duan-bu-shu-xiang-guan-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="nginx相关"><a href="#nginx相关" class="headerlink" title="nginx相关"></a>nginx相关</h2><ol><li><p>查看服务器是否有nginx</p><ul><li><code>whereis nginx</code></li><li>或者输入<code>nginx -v</code>,如出现版本号也代表服务器有nginx</li></ul></li><li><p>如果显示<code>nginx:或没有出现版本号</code>代表服务器没有安装nginx,则执行以下命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><ul><li>如果出现了<code>complete!</code>说明安装成功</li></ul></li><li><p>启动nginx</p><ul><li>在控制台直接输入<code>nginx</code>即可</li><li>如果出现以下错误<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br></pre></td></tr></table></figure></li><li>原因是端口号80被其他文件占用,输入以下命令<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo fuser -k 80/tcp</span><br><span class="line">fuser -k 80/tcp</span><br></pre></td></tr></table></figure></li><li>然后再次启动nginx</li></ul></li><li><p>停止nginx: <code>nginx -s stop</code></p></li><li><p>重启nginx: <code>nginx -s reload</code></p></li><li><p>修改nginx配置文件: <code>vim nginx.conf</code></p><ul><li><p>修改配置文件前,先通过<code>whereis nginx</code>查找存放nginx路径并cd到该路径中</p></li><li><p>找到server下的root重新设置网站存放的文件夹路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       <span class="number">80</span> default_server;</span><br><span class="line">  listen       [::]:<span class="number">80</span> default_server;</span><br><span class="line">  server_name  _;</span><br><span class="line">  root         /home/W_bowen/dist;</span><br><span class="line"></span><br><span class="line">  # Load configuration files for the default server block.</span><br><span class="line">  include /etc/nginx/<span class="keyword">default</span>.d<span class="comment">/*.conf;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  location / &#123;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">    location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">    location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>按键盘中<code>Insert</code>进入修改配置文件模式</p></li><li><p>退出编辑模式: <code>esc</code></p></li><li><p>输入<code>:wq!</code>退出并保存nginx配置文件,只输入<code>:q!</code>标识只退出不保存修改配置</p><ul><li>注意: 保存退出后需要重启nginx</li></ul></li><li><p>新建网站文件夹</p><ul><li>以<code>/home/W_bowen/dist</code>为例,在服务器上新建W_bowen文件夹<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">mkdir W_bowen</span><br></pre></td></tr></table></figure><h2 id="打包部署Vue项目"><a href="#打包部署Vue项目" class="headerlink" title="打包部署Vue项目"></a>打包部署Vue项目</h2></li></ul></li><li><p>使用<code>npm run build</code>命令进行打包生成<code>dist文件夹</code></p></li><li><p>将dist文件进行压缩并放到/home/W_bowen下(MobaXterm)</p></li><li><p>通过<code>unzip dist.zip</code>就可以访问了</p></li></ol><h2 id="ng开启反向代理解决跨域"><a href="#ng开启反向代理解决跨域" class="headerlink" title="ng开启反向代理解决跨域"></a>ng开启反向代理解决跨域</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">add_header Access-Control-Allow-Origin * always;</span><br><span class="line"></span><br><span class="line">add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS always;</span><br><span class="line"></span><br><span class="line">add_header Access-Control-Allow-Credentials true always;</span><br><span class="line"></span><br><span class="line">add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,x-auth-token always;</span><br><span class="line"></span><br><span class="line">add_header Access-Control-Max-Age 1728000 always;</span><br><span class="line"></span><br><span class="line"># 预检请求处理</span><br><span class="line">if ($request_method = OPTIONS) &#123;</span><br><span class="line">  return 204;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue打包优化相关</title>
      <link href="2022/04/21/you-hua-da-bao-xiang-guan-pei-zhi/"/>
      <url>2022/04/21/you-hua-da-bao-xiang-guan-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h2><ul><li><p>在跟文件目录下创建.env.production</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=production</span><br><span class="line"><span class="comment">// 最好使用下面的变量进行判断</span></span><br><span class="line">VUE_APP_DEV=production  </span><br></pre></td></tr></table></figure></li><li><p>在package.json中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build --mode production&quot;</span>,</span><br></pre></td></tr></table></figure><h3 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h3></li><li><p>通过判断是否为生产环境,生产环境下设置为false可提高构建效率</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否为生产环境</span></span><br><span class="line"><span class="keyword">const</span> environment = process.env.VUE_APP_DEV === <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 是否开启sourcemap,设置为false时可加速生产环境构建</span></span><br><span class="line">  productionSourceMap: environment !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复HMR-热更新-失败"><a href="#修复HMR-热更新-失败" class="headerlink" title="修复HMR(热更新)失败"></a>修复HMR(热更新)失败</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 修复HMR</span></span><br><span class="line">  config.resolve.symlinks(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化效率工具"><a href="#优化效率工具" class="headerlink" title="优化效率工具"></a>优化效率工具</h3></li><li><p>编译进度条: progress-bar-webpack-plugin;</p></li><li><p>可视化分析打包: webpack-bundle-analyzer;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i progress-bar-webpack-plugin -D</span></span><br><span class="line"><span class="comment">// npm i webpack-bundle-analyzer -D</span></span><br><span class="line"><span class="comment">// 引入编译进度条</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ProgressBarPlugin = <span class="built_in">require</span>(<span class="string">&#x27;progress-bar-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要在生产环境下开启</span></span><br><span class="line">    <span class="keyword">if</span> (environment) &#123;</span><br><span class="line">      config.plugins.push(</span><br><span class="line">      <span class="comment">// 打包进度条</span></span><br><span class="line">      <span class="keyword">new</span> ProgressBarPlugin(&#123;</span><br><span class="line">        format: <span class="string">`  :msg [:bar] <span class="subst">$&#123;chalk.green.bold(</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="string">&#x27;:percent&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span> (:elapsed s)`</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="comment">// 分析打包</span></span><br><span class="line">      <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建时压缩图片"><a href="#构建时压缩图片" class="headerlink" title="构建时压缩图片"></a>构建时压缩图片</h3></li><li><p>使用image-webpack-loader(其实提升不大)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i image-webpack-loader -D 或 cnpm i image-webpack-loader -D</span></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 生产环境进行压缩图片处理</span></span><br><span class="line">    <span class="keyword">if</span> (environment) &#123;</span><br><span class="line">      <span class="comment">// 图片压缩处理</span></span><br><span class="line">      <span class="keyword">const</span> imgRule = config.module.rule(<span class="string">&#x27;images&#x27;</span>)</span><br><span class="line">      imgRule</span><br><span class="line">        .test(<span class="regexp">/\.(png|jpe?g|gif|webp)(\?.*)?$/</span>)</span><br><span class="line">        .use(<span class="string">&#x27;image-webpack-loader&#x27;</span>)</span><br><span class="line">        .loader(<span class="string">&#x27;image-webpack-loader&#x27;</span>)</span><br><span class="line">        .options(&#123; <span class="attr">bypassOnDebug</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        .end()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除console-log打印和注释"><a href="#清除console-log打印和注释" class="headerlink" title="清除console.log打印和注释"></a>清除console.log打印和注释</h3></li><li><p>使用uglifyjs-webpack-plugin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i uglifyjs-webpack-plugin -D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 只需要在生产环境下使用</span></span><br><span class="line">  <span class="keyword">if</span> (environment) &#123;</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">      output: &#123;</span><br><span class="line">        comments: <span class="literal">false</span>, <span class="comment">// 去掉注释</span></span><br><span class="line">      &#125;,</span><br><span class="line">      warnings: <span class="literal">false</span>,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        drop_console: <span class="literal">true</span>,</span><br><span class="line">        drop_debugger: <span class="literal">false</span>,</span><br><span class="line">        pure_funcs: [<span class="string">&#x27;console.log&#x27;</span>] <span class="comment">//移除console</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件库按需引入"><a href="#组件库按需引入" class="headerlink" title="组件库按需引入"></a>组件库按需引入</h3></li><li><p>在babel.config.js中配置以下代码,或者直接查看ant-design-vue的官方网站</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// antd按需引入</span></span><br><span class="line">plugins: [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;import&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      libraryName: <span class="string">&quot;ant-design-vue&quot;</span>,</span><br><span class="line">      libraryDirectory: <span class="string">&quot;es&quot;</span>,</span><br><span class="line">      style: <span class="string">&#x27;css&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;component&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      libraryName: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">      styleLibraryName: <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在vue.config.js中配置以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// antd按需引入后,less-loader版本过高无法编译,需要加上这段代码</span></span><br><span class="line">css: &#123;</span><br><span class="line">  sourceMap: <span class="literal">false</span>,</span><br><span class="line">  loaderOptions: &#123;</span><br><span class="line">    less: &#123;</span><br><span class="line">      javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开启CDN加速"><a href="#开启CDN加速" class="headerlink" title="开启CDN加速"></a>开启CDN加速</h3></li><li><p>放置将某些import的包打包到bundle中,而是运行时(runtime)去外部获取这些扩展依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> cdn = &#123;</span><br><span class="line">  <span class="comment">// cdn的css链接</span></span><br><span class="line">  css: [</span><br><span class="line">    <span class="comment">// &#x27;https://cdn.jsdelivr.net/npm/ant-design-vue@1.7.8/dist/antd.min.css&#x27;,</span></span><br><span class="line">    <span class="comment">// &quot;//unpkg.com/element-ui@2.10.1/lib/theme-chalk/index.css&quot;,</span></span><br><span class="line">    <span class="comment">// videojs</span></span><br><span class="line">    <span class="string">&quot;//unpkg.com/video.js@7.10.2/dist/video-js.min.css&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// cdn的js链接</span></span><br><span class="line">  js: [</span><br><span class="line">    <span class="comment">// 必须放在第一位,不然会报错</span></span><br><span class="line">    <span class="string">&quot;//unpkg.com/vue@2.6.10/dist/vue.min.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//unpkg.com/vue-router@3.0.6/dist/vue-router.min.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//unpkg.com/vuex@3.1.1/dist/vuex.min.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//unpkg.com/axios@0.19.0/dist/axios.min.js&quot;</span>,</span><br><span class="line">    <span class="comment">// &#x27;https://cdn.jsdelivr.net/npm/ant-design-vue@1.7.8/dist/antd.min.js&#x27;,</span></span><br><span class="line">    <span class="comment">// &quot;//unpkg.com/element-ui@2.10.1/lib/index.js&quot;,</span></span><br><span class="line">    <span class="comment">// lazyload</span></span><br><span class="line">    <span class="string">&quot;//unpkg.com/vue-lazyload/vue-lazyload.js&quot;</span>,</span><br><span class="line">    <span class="comment">// videojs</span></span><br><span class="line">    <span class="string">&quot;//unpkg.com/video.js@7.10.2/dist/video.min.js&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (environment) &#123;</span><br><span class="line">    <span class="comment">// 配置需要cdn的包</span></span><br><span class="line">    config.externals = &#123;</span><br><span class="line">      vue: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vue-router&#x27;</span>: <span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">      <span class="string">&quot;element-ui&quot;</span>: <span class="string">&quot;ELEMENT&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;ant-design-vue&#x27;</span>: <span class="string">&#x27;antd&#x27;</span>,</span><br><span class="line">      axios: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">      vuex: <span class="string">&#x27;Vuex&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vue-lazyload&#x27;</span>: <span class="string">&#x27;VueLazyload&#x27;</span>,</span><br><span class="line">      videojs: <span class="string">&#x27;Videojs&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.when(process.env.VUE_APP_DEV === <span class="string">&#x27;production&#x27;</span>, <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 设置打包入口 */</span></span><br><span class="line">  <span class="comment">// config.entry(&#x27;app&#x27;).clear().add(&#x27;./src/main-prod.js&#x27;)</span></span><br><span class="line">    config.plugin(<span class="string">&#x27;html&#x27;</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// html中添加cdn</span></span><br><span class="line">      args[<span class="number">0</span>].cdn = cdn;</span><br><span class="line">      <span class="keyword">return</span> args;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  config.when(process.env.VUE_APP_DEV === <span class="string">&#x27;development&#x27;</span>, <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// config.entry(&#x27;app&#x27;).clear().add(&#x27;./src/main.js&#x27;)</span></span><br><span class="line">    config.plugin(<span class="string">&#x27;html&#x27;</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//添加参数isProd</span></span><br><span class="line">      args[<span class="number">0</span>].cdn = [];</span><br><span class="line">      <span class="keyword">return</span> args;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在public/index.html中添加以下代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span></span><br><span class="line">&lt;% for (var i in</span><br><span class="line">  htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.css) &#123; %&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">  <span class="comment">&lt;!-- 使用CDN加速的JS文件，配置在vue.config.js下 --&gt;</span></span><br><span class="line">&lt;% for (var i in</span><br><span class="line">  htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.js) &#123; %&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="开启gizp压缩"><a href="#开启gizp压缩" class="headerlink" title="开启gizp压缩"></a>开启gizp压缩</h3></li><li><p>compression-webpack-plugin,对打包体积有很大的缩减,需要配合nginx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm i compression-webpack-plugin -D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 在生产环境下开启gzip</span></span><br><span class="line">  <span class="keyword">if</span> (environment) &#123;</span><br><span class="line">    <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">&quot;[path].gz[query]&quot;</span>,</span><br><span class="line">    algorithm: <span class="string">&quot;gzip&quot;</span>,</span><br><span class="line">    test: <span class="regexp">/\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i</span>,</span><br><span class="line">    threshold: <span class="number">10240</span>,</span><br><span class="line">    minRatio: <span class="number">0.8</span></span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>nginx中相关配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 开启gzip</span><br><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line"># gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明</span><br><span class="line">gzip_comp_level 5;</span><br><span class="line"></span><br><span class="line"># 进行压缩的文件类型。javascript有多种形式，后面的图片压缩不需要的可以自行删除</span><br><span class="line">gzip_types application/atom+xml application/geo+json application/javascript application/x-javascript application/json application/ld+json application/manifest+json application/rdf+xml application/rss+xml application/xhtml+xml application/xml font/eot font/otf font/ttf image/svg+xml text/css text/javascript text/plain text/xml;</span><br><span class="line"></span><br><span class="line"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"># Nginx作为反向代理的时候启用</span><br><span class="line">gzip_proxied any;</span><br><span class="line"></span><br><span class="line"># 将接收压缩文件的浏览器中排除Internet Explorer 6，因为IE6根本不支持gzip</span><br><span class="line">gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line"># 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存,4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line"></span><br><span class="line"># 识别http的协议版本。由于早期的一些浏览器或者http客户端，可能不支持gzip自解压，用户就会看到乱码，所以做一些判断还是有必要的。</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line"></span><br><span class="line"># 设置压缩所需要的缓冲区大小     </span><br><span class="line">gzip_buffers 4 16k;</span><br></pre></td></tr></table></figure><!-- ## BOM</li><li><p>窗口大小</p><ul><li>innerWidth和innerHeight分别返回<code>浏览器窗口中页面视口的宽度和高度</code>(不包含浏览器边框和工具栏)</li><li>outerWidth和outerHeight分别返回<code>浏览器窗口自身的宽度和高度</code></li><li>document.documentElement.clientWidth和document.documentElement.clientHeight分别返回<code>页面视口的宽度和高度(渲染页面的实际大小)</code></li></ul></li><li><p>视口位置</p><ul><li>相对于视口滚动距离的属性有两队,返回相等的值: <code>window.pageXoffset/window.scrollX</code>和<code>window.pageYoffset/window.scrollY</code></li><li>可以使用<code>scroll()、scrollTO()和scrollBy()</code>方法滚动页面,这三个方法都接收表示相对视口距离的x和y坐标。其中scroll()和scrollTo()表示要滚动到的坐标,scrollBy()表示滚动的距离</li><li>也可以传一个对象,写法如下:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollTo(&#123;</span><br><span class="line">  left: <span class="built_in">Number</span>,</span><br><span class="line">  top: <span class="built_in">Number</span>,</span><br><span class="line">  <span class="comment">// 分别表示正常滚动、平滑滚动</span></span><br><span class="line">  behavior: <span class="string">&#x27;auto/smooth&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>导航与打开新窗口</p><ul><li><code>window.open()</code>方法用于导航到指定URL,也可以用于打开新浏览器窗口</li><li><code>window.close()</code>方法用于关闭新打开的窗口</li><li>检查浏览器是否阻止弹框,通过window.open()的返回值是否为null,然后配合try…catch进行判断<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> open =  <span class="built_in">window</span>.open(<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>);</span><br><span class="line">   <span class="keyword">if</span> (open === <span class="literal">null</span>) &#123;</span><br><span class="line">     blocked = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">  <span class="comment">// 弹框被阻止!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>setTimeout循环定时器取消</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置一个最大值</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 存放定时器ID</span></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> incrementNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  num++;</span><br><span class="line">  <span class="comment">// 如果num还没到最大值,再次设置一个超时任务</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(incrementNumber, <span class="number">500</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">timer = <span class="built_in">setTimeout</span>(incrementNumber, <span class="number">500</span>;)</span><br></pre></td></tr></table></figure></li><li><p>location对象</p><ul><li>location提供了当前窗口加载文档的信息,以及通常的导航功能</li><li><code>decodeURIComponent()</code>方法用于解码由<code>encodeURIComponent</code>方法或者其它类似方法编码的部分统一<code>资源标识符（URI）</code>。 –&gt;</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些解决办法</title>
      <link href="2022/03/06/yi-xie-jie-jue-ban-fa/"/>
      <url>2022/03/06/yi-xie-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="echarts使用getZr-事件获取柱状图当前点击列的数据"><a href="#echarts使用getZr-事件获取柱状图当前点击列的数据" class="headerlink" title="echarts使用getZr()事件获取柱状图当前点击列的数据"></a>echarts使用getZr()事件获取柱状图当前点击列的数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="built_in">document</span>.getElementById(<span class="string">&quot;cardChart&quot;</span>);</span><br><span class="line">t.style.width = <span class="built_in">window</span>.offsetWidth + <span class="string">&quot;px&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> cardChart = echarts.init(t),</span><br><span class="line">  options = &#123;</span><br><span class="line">    color: [<span class="string">&#x27;#3398DB&#x27;</span>],</span><br><span class="line">    title: &#123;</span><br><span class="line">      left: <span class="string">&quot;right&quot;</span>,</span><br><span class="line">      <span class="comment">//text: new Date().getFullYear() + &quot;年数据&quot;,</span></span><br><span class="line">      textStyle: &#123;</span><br><span class="line">        color: <span class="string">&quot;#2c2c2c&quot;</span>,</span><br><span class="line">        fontSize: <span class="number">14</span>,</span><br><span class="line">        fontWeight: <span class="number">500</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">      trigger: <span class="string">&#x27;axis&#x27;</span>,</span><br><span class="line">      axisPointer: &#123;            <span class="comment">// 坐标轴指示器，坐标轴触发有效</span></span><br><span class="line">        type: <span class="string">&#x27;shadow&#x27;</span>        <span class="comment">// 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">      left: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">      right: <span class="string">&#x27;4%&#x27;</span>,</span><br><span class="line">      bottom: <span class="string">&#x27;3%&#x27;</span>,</span><br><span class="line">      containLabel: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: [&#123;</span><br><span class="line">      type: <span class="string">&quot;category&quot;</span>,</span><br><span class="line">      data: dataYearCountName,</span><br><span class="line">      axisTick: &#123;</span><br><span class="line">        alignWithLabel: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      axisLabel: &#123;</span><br><span class="line">        interval: <span class="number">0</span>,    <span class="comment">//强制文字产生间隔</span></span><br><span class="line">        rotate: <span class="number">45</span>,     <span class="comment">//文字逆时针旋转45°</span></span><br><span class="line">        textStyle: &#123;    <span class="comment">//文字样式</span></span><br><span class="line">          color: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">          fontSize: <span class="number">14</span>,</span><br><span class="line">          fontFamily: <span class="string">&#x27;Microsoft YaHei&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">      yAxis: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: <span class="string">&quot;value&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      series: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">&quot;例数&quot;</span>,</span><br><span class="line">          type: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">          barWidth: <span class="string">&quot;60%&quot;</span>,</span><br><span class="line">          data: dataYearCountNum</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//-----------------从这里开始 -----------------</span></span><br><span class="line">  <span class="comment">//cardChart 柱状图名称</span></span><br><span class="line">  cardChart.setOption(options);</span><br><span class="line">  cardChart.off(<span class="string">&#x27;click&#x27;</span>); <span class="comment">//防止触发两次点击事件</span></span><br><span class="line">  cardChart.getZr().on(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pointInPixel = [params.offsetX, params.offsetY];</span><br><span class="line">    <span class="keyword">if</span> (cardChart.containPixel(<span class="string">&#x27;grid&#x27;</span>, pointInPixel)) &#123;</span><br><span class="line">      <span class="keyword">const</span> pointInGrid = cardChart.convertFromPixel(&#123;</span><br><span class="line">        seriesIndex: <span class="number">0</span></span><br><span class="line">      &#125;, pointInPixel);</span><br><span class="line">      <span class="keyword">const</span> xIndex = <span class="built_in">Number</span>(pointInGrid[<span class="number">0</span>]); <span class="comment">//索引</span></span><br><span class="line">      <span class="keyword">const</span> seriesObj = cardChart.getOption(); <span class="comment">//图表object对象</span></span><br><span class="line">      <span class="keyword">const</span> op = cardChart.getOption();</span><br><span class="line">      <span class="comment">//获得图表中点击的列</span></span><br><span class="line">      <span class="keyword">const</span> month = op.xAxis[<span class="number">0</span>].data[xIndex];  <span class="comment">//获取点击的列名</span></span><br><span class="line">      <span class="built_in">console</span>.log(month);</span><br><span class="line">      <span class="built_in">console</span>.log(handleIndex, seriesObj);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="vue项目动态监听localStorage或sessionStorage中数据的变化"><a href="#vue项目动态监听localStorage或sessionStorage中数据的变化" class="headerlink" title="vue项目动态监听localStorage或sessionStorage中数据的变化"></a>vue项目动态监听localStorage或sessionStorage中数据的变化</h2><ol><li>首先在main.js中给Vue.prototype注册一个全局方法，然后创建一个StorageEvent方法，当我们执行sessionStorage.setItem(k,val)的时候，初始化事件并派发事件。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; number &#125;</span> </span>type 1 localStorage 2 sessionStorage</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; string &#125;</span> </span>key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123; string &#125;</span> </span>data 要存储的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> Vue.prototype.$addStorageEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, key, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// localStorage</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个StorageEvent事件</span></span><br><span class="line">    <span class="keyword">var</span> newStorageEvent = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;StorageEvent&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> storage = &#123;</span><br><span class="line">      setItem: <span class="function"><span class="keyword">function</span> (<span class="params">k, val</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(k, val);</span><br><span class="line">        <span class="comment">// 初始化创建的事件</span></span><br><span class="line">        newStorageEvent.initStorageEvent(<span class="string">&#x27;setItem&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>, k, <span class="literal">null</span>, val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 派发对象</span></span><br><span class="line">        <span class="built_in">window</span>.dispatchEvent(newStorageEvent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> storage.setItem(key, data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// sessionStorage</span></span><br><span class="line">    <span class="comment">// 创建一个StorageEvent事件</span></span><br><span class="line">    <span class="keyword">var</span> newStorageEvent = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;StorageEvent&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> storage = &#123;</span><br><span class="line">      setItem: <span class="function"><span class="keyword">function</span> (<span class="params">k, val</span>) </span>&#123;</span><br><span class="line">        sessionStorage.setItem(k, val);</span><br><span class="line">        <span class="comment">// 初始化创建的事件</span></span><br><span class="line">        newStorageEvent.initStorageEvent(<span class="string">&#x27;setItem&#x27;</span>, <span class="literal">false</span>, <span class="literal">false</span>, k, <span class="literal">null</span>, val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 派发对象</span></span><br><span class="line">        <span class="built_in">window</span>.dispatchEvent(newStorageEvent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> storage.setItem(key, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在组件A中调用，写入缓存<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$addStorageEvent(<span class="number">1</span>,<span class="string">&#x27;userMess&#x27;</span>,data);</span><br></pre></td></tr></table></figure></li><li>在组件B中监听<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;setItem&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.user = sessionStorage.getItem(<span class="string">&#x27;userMess&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="获取当周从星期一到星期天的日期"><a href="#获取当周从星期一到星期天的日期" class="headerlink" title="获取当周从星期一到星期天的日期"></a>获取当周从星期一到星期天的日期</h2></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeekDay</span>(<span class="params">dateString</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dateStringReg = <span class="regexp">/^\d&#123;4&#125;[/-]\d&#123;1,2&#125;[/-]\d&#123;1,2&#125;$/</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dateString.match(dateStringReg)) &#123;</span><br><span class="line">    <span class="keyword">let</span> presentDate = <span class="keyword">new</span> <span class="built_in">Date</span>(dateString),</span><br><span class="line">      today = presentDate.getDay() !== <span class="number">0</span> ? presentDate.getDay() : <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>), <span class="function"><span class="keyword">function</span>(<span class="params">val, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>(presentDate.getTime() - (today index-<span class="number">1</span>) * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;dateString should be like &quot;yyyy-mm-dd&quot; or &quot;yyyy/mmdd&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">date</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> date.getFullYear() + <span class="string">&#x27;-&#x27;</span> + (date.getMonth() + <span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span> + date.getDate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getWeekDay(<span class="string">&#x27;2018-1-8&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="判断两个日期相差天数-可精确到分秒"><a href="#判断两个日期相差天数-可精确到分秒" class="headerlink" title="判断两个日期相差天数(可精确到分秒)"></a>判断两个日期相差天数(可精确到分秒)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateDifference</span>(<span class="params">faultDate,completeTime</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stime =<span class="keyword">new</span> <span class="built_in">Date</span>(faultDate).getTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> etime = <span class="keyword">new</span> <span class="built_in">Date</span>(completeTime).getTime();</span><br><span class="line">  <span class="comment">//const etime = Date.parse(new Date());</span></span><br><span class="line">  <span class="keyword">const</span> usedTime = etime - stime;  <span class="comment">//两个时间戳相差的毫秒数</span></span><br><span class="line">  <span class="keyword">const</span> days = <span class="built_in">Math</span>.floor(usedTime/(<span class="number">24</span>*<span class="number">3600</span>*<span class="number">1000</span>));</span><br><span class="line">  <span class="comment">//计算出小时数</span></span><br><span class="line">  <span class="comment">// const leave1=usedTime % (24*3600*1000);    //计算天数后剩余的毫秒数</span></span><br><span class="line">  <span class="comment">// const hours=Math.floor(leave1/(3600*1000));</span></span><br><span class="line">  <span class="comment">// //计算相差分钟数</span></span><br><span class="line">  <span class="comment">// const leave2=leave1%(3600*1000);        //计算小时数后剩余的毫秒数</span></span><br><span class="line">  <span class="comment">// const minutes=Math.floor(leave2/(60*1000));</span></span><br><span class="line">  <span class="comment">// const time = days + &quot;天&quot;+hours+&quot;时&quot;+minutes+&quot;分&quot;;</span></span><br><span class="line">  <span class="comment">// const time = days;</span></span><br><span class="line">  <span class="keyword">return</span> days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备判断-Android、iOS、web"><a href="#设备判断-Android、iOS、web" class="headerlink" title="设备判断: Android、iOS、web"></a>设备判断: Android、iOS、web</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDevice</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/(iPhone|iPad|iPod|iOS)/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;iOS&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/(Android)/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Android&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Web&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成随机数范围"><a href="#生成随机数范围" class="headerlink" title="生成随机数范围"></a>生成随机数范围</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(min + <span class="built_in">Math</span>.random() * ((max + <span class="number">1</span>) - min));</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newobj = &#123;&#125;;</span><br><span class="line">idList.reduce(<span class="function">(<span class="params">preVal, curVal</span>) =&gt;</span> &#123;</span><br><span class="line">  newobj[curVal.id] ? <span class="string">&#x27;&#x27;</span> : newobj[curVal.id] = preVal.push(curVal); </span><br><span class="line">  <span class="keyword">return</span> preVal;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="解决IOS端下拉出现大面积空白"><a href="#解决IOS端下拉出现大面积空白" class="headerlink" title="解决IOS端下拉出现大面积空白"></a>解决IOS端下拉出现大面积空白</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overscroll = <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  el.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> top = el.scrollTop</span><br><span class="line">      , totalScroll = el.scrollHeight</span><br><span class="line">      , currentScroll = top + el.offsetHeight;</span><br><span class="line">    <span class="keyword">if</span> (top === <span class="number">0</span>) &#123;</span><br><span class="line">      el.scrollTop = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentScroll === totalScroll) &#123;</span><br><span class="line">      el.scrollTop = top - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  el.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.offsetHeight &lt; el.scrollHeight)</span><br><span class="line">      evt._isScroller = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">overscroll(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.scroll&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!evt._isScroller) &#123;</span><br><span class="line">    evt.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wang_boWen js知识点总结(持续更新)</title>
      <link href="2021/11/03/js-zhi-shi-dian-zong-jie-chi-xu-geng-xin/"/>
      <url>2021/11/03/js-zhi-shi-dian-zong-jie-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h2 id="V8引擎执行流程"><a href="#V8引擎执行流程" class="headerlink" title="V8引擎执行流程"></a>V8引擎执行流程</h2><ol><li>Blink将JavaScript源码交给V8引擎,Stream获取到源码并且进行编码转换;</li><li>Scanner会进行此法分析，词法分析会将代码转换成tokens;</li><li>接下来tokens会被转换成AST树,经过parser和Preparser:<ul><li>parser就是直接将tokens转换成AST树结构;</li><li>Preparser称之为预解析,为什么需要预解析?<ul><li>因为并不是所有JavaScript代码,在一开始时就会被执行。对所有JavaScript代码进行解析,会影响<br>网页运行效率;</li><li>所以V8引擎实现了Lazy Parsing(<code>延迟解析</code>)的方案,它的作用是将不必要的函数进行<code>预解析</code>,也就是<br>解析暂时需要的内容,而对<code>函数的全量解析</code>是在<code>函数被调用时</code>才会进行;</li></ul></li></ul></li><li>生成AST树后,会被Ignition转成字节码,之后的过程就是代码的执行过程。</li></ol><h2 id="作用域规范"><a href="#作用域规范" class="headerlink" title="作用域规范"></a>作用域规范</h2><ol><li>早期版本ECMA的版本规范:</li></ol><ul><li>每个执行上下文会被关联到一个<code>变量对象(variable object, VO)</code>,在源代码中的变量和函数声明会被作为属性添加到VO中。对于函数来说,参数也会被添加到VO中。</li></ul><ol start="2"><li>最新版本ECMA的版本规范:</li></ol><ul><li>每个执行上下文会关联到一个<code>变量环境(variable Environment)</code>中,在执行代码中变量和函数声明会作为<code>环境记录(Environment Record)</code>添加到变量环境中。对于函数来说,参数也会被作为环境记录添加到变量环境中。</li></ul><ol start="3"><li>作用域执行顺序(待完善):<!-- - 首先创建一个GO(GlobalObject)全局 --></li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol><li>js对于<code>基本数据类型内存的分配</code>会在执行时,直接在栈空间进行分配;</li><li>js对于<code>复杂数据类型内存的分配</code>会在堆内存中开辟一块空间,并且将这块空间的指针返回值变量引用;</li></ol><h2 id="常见的GC算法"><a href="#常见的GC算法" class="headerlink" title="常见的GC算法"></a>常见的GC算法</h2><ol><li>引用计数：<ul><li>当一个对象有一个引用指向它时,那么这个对象的引用就+1,当以个对象的引用为0时,这个对象就可以被销毁;</li><li>弊端: 会产生循环引用;</li></ul></li><li>标记清除:<ul><li>设置一个根对象(root object),垃圾回收器会定期从这个根开始,找所有从根开始有引用到的对象,对于那些没有引用到的对象,就认为是不可用的对象;</li><li>能够很好解决循环引用问题;</li></ul></li></ol><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><ol><li><p>一个普通的函数function,如果它可以访问其外层作用域的自由变量,那么这个函数就是一个闭包(内层函数可以访问到其外层函数的作用域);</p></li><li><p>在JavaScript中,每当创建一个函数,闭包就会在函数创建的同时被创建出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;wbw&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = foo();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2></li><li><p>一般包括<code>作用域链(scopeChain)</code>、<code>this</code>、<code>arguments</code>和<code>函数变量对象AO或全局变量对象GO</code>;</p></li><li><p>this</p><ul><li>函数在调用时候,JavaScript会默认给this绑定一个值;</li><li>this的绑定和定义的位置(编写的位置)没有关系;</li><li><code>this的绑定与调用的方式和调用的位置有关系</code>;</li><li>this是在运行时被绑定的;</li></ul></li><li><p>this的绑定规则</p><ul><li>默认绑定: 独立函数调用;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例一:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 案例二:</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo</span><br><span class="line">bar(); <span class="comment">// window, this的绑定与调用的方式及调用的位置有关系</span></span><br></pre></td></tr></table></figure></li><li>隐式绑定: 满足<code>xxx.fn()</code>格式,fn的<code>this</code>指向<code>xxx</code>。如果存在链式调用,<code>this永远指向最后调用它的那个对象</code>;</li><li>隐式绑定条件: 1. 必须在调用的对象内部有一个对函数的引用;2. 没有这个引用,调用时会报错;3.正是通过这个引用,<code>间接将this绑定到了这个对象上</code>;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(); <span class="comment">// this指向的是obj对象</span></span><br></pre></td></tr></table></figure></li><li>显示绑定: 通过call或applay在执行函数时,明确绑定this;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj, n1, n2...); <span class="comment">// this指向call函数第一个传入的值,在这里指向的是obj</span></span><br><span class="line">foo.applay(obj, [n1, n2...]);</span><br></pre></td></tr></table></figure></li><li>显示绑定优先级要高于隐式绑定;</li><li>new绑定: 通过new关键字来调用构造函数,生成一个新对象(this指向创建出来的对象实例);</li></ul></li><li><p>this的其他绑定</p><ul><li>setTimeout、setInterval、forEach、map等函数调用时,this指向的是window。</li><li><code>箭头函数</code>的this指向的是它上一层作用域中的this。</li><li><code>立即执行函数</code>的this指向的是全局对象window。</li><li><code>严格模式</code>下的自指向函数的this指向的是undefined。</li></ul></li><li><p>规则优先级</p><ul><li><code>默认规则(默认绑定)</code>的优先级最低。</li><li><code>显示绑定</code>的优先级是高于<code>隐式绑定</code>的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  foo: foo.bind(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">obj.foo(); <span class="comment">// this打印为abc</span></span><br></pre></td></tr></table></figure></li><li><code>new绑定</code>优先级高于<code>隐式绑定</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> obj.foo(); <span class="comment">// this打印为foo&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><code>new绑定</code>优先级高于<code>显示绑定</code>(注意: new关键字不能和call/apply一起使用)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> bar(); <span class="comment">// 最后打印的this为foo&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>特殊绑定: 忽略显示绑定</p><ul><li>call/apply/bind: 当传入null/undefined时,自动将this绑定成全局对象;</li><li>间接函数引用: this绑定成全局对象;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(b = person.sayName)(); <span class="comment">// window,间接函数引用</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>箭头函数 </p><ul><li>箭头函数不会绑定this、argument属性;</li><li>箭头函数不能作为构造函数使用(不能和new一起使用,会报错);</li></ul></li><li><p>this面试题</p><ul><li>面试题一<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.sayName;</span><br><span class="line">  sss(); <span class="comment">// window,独立函数调用</span></span><br><span class="line">  person.sayName(); <span class="comment">// person,隐式调用</span></span><br><span class="line">  (person.sayName)(); <span class="comment">// person: 隐式调用</span></span><br><span class="line">  (b = person.sayName)(); <span class="comment">// window,间接函数引用(独立函数调用)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>面试题二<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  foo1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo2: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.name),</span><br><span class="line">  foo3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  foo4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">person1.foo1(); <span class="comment">// person1: 隐式调用</span></span><br><span class="line">person1.foo1.call(person2); <span class="comment">// person2: 显示调用,this绑定到person2对象上(显示调用优先级高于隐式调用)</span></span><br><span class="line"></span><br><span class="line">person1.foo2(); <span class="comment">// window: foo2为箭头函数,this指向的是它上级作用域window</span></span><br><span class="line">person1.foo2.call(person2); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">person1.foo3()(); <span class="comment">// window: 独立函数调用</span></span><br><span class="line">person1.foo3.call(person2)(); <span class="comment">// window: 独立函数调用</span></span><br><span class="line">person1.foo3().call(person2); <span class="comment">// person2: 显示调用</span></span><br><span class="line"></span><br><span class="line">person1.foo4()(); <span class="comment">// person1, foo4返回箭头函数,this指向的是上级作用域person1</span></span><br><span class="line">person1.foo4.call(person2)(); <span class="comment">// person2: call先将foo4的this绑定到person2上,返回的箭头函数this指向的是person2</span></span><br><span class="line">person1.foo4().call(person2); <span class="comment">// person1</span></span><br></pre></td></tr></table></figure></li><li>面试题三<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    foo1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    foo2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;person1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;person2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()(); <span class="comment">// window: 独立函数调用</span></span><br><span class="line">person1.obj.foo1.call(person2)(); <span class="comment">// window: 独立函数调用</span></span><br><span class="line">person1.obj.foo1().call(person2); <span class="comment">// person2: 显示调用,将foo1返回的函数的this绑定到person2上</span></span><br><span class="line"></span><br><span class="line">person1.obj.foo2()(); <span class="comment">// obj: 隐式调用,obj.foo2()调用返回箭头函数,因为是通过obj调用,所以箭头函数的this指向的是obj</span></span><br><span class="line">person1.obj.foo2.call(person2)(); <span class="comment">// person2: 显示调用,将foo2的this绑定到person2上,返回的箭头函数this指向的是person2</span></span><br><span class="line">person1.obj.foo2().call(person2); <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><h2 id="call-apply-bind的简单实现"><a href="#call-apply-bind的简单实现" class="headerlink" title="call/apply/bind的简单实现"></a>call/apply/bind的简单实现</h2></li></ul></li><li><p>call的简单实现</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...args为剩余参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取要被执行的函数</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 只能调用函数,否则抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 判断传入的thisArg的类型,如果为undefined/null直接赋值window</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">undefined</span> &amp;&amp; thisArg !== <span class="literal">null</span>) ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 3. 将要被执行的函数赋值到thisArg上</span></span><br><span class="line">  thisArg.fn = fn;</span><br><span class="line">  <span class="comment">// 4. 执行函数并返回</span></span><br><span class="line">  <span class="keyword">let</span> result = thisArg.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>apply的简单实现</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, argArray</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取要被执行的函数</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 只能调用函数,否则抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 判断thisArg的类型,如果为undefined或null直接赋值window</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">undefined</span> &amp;&amp; thisArg !== <span class="literal">null</span>) ? <span class="built_in">Object</span>(thisArg) : <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 3. 将要被执行的函数赋值到thisArg上</span></span><br><span class="line">  thisArg.fn = fn;</span><br><span class="line">  <span class="comment">// 4. 判断argArray是否有值</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  argArray = argArray &amp;&amp; argArray.length ? argArray : [];</span><br><span class="line">  <span class="comment">// 5. 执行函数并返回</span></span><br><span class="line">  result = thisArg.fn(...argArray);</span><br><span class="line">  <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>bind的简单实现</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取要被执行的函数</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 判断fn是否为函数,不为函数抛出错误</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 判断thisArg的类型, 如果为undefined或null直接赋值window</span></span><br><span class="line">  thisArg = (thisArg !== <span class="literal">undefined</span> &amp;&amp; thisArg !== <span class="literal">null</span>) ? thisArg : <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 3. 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="title">funtion</span>(<span class="params">..args</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 将被执行函数赋值到thisArg上</span></span><br><span class="line">    thisArg.fn = fn;</span><br><span class="line">    <span class="comment">// 5. 拼接两个函数的参数</span></span><br><span class="line">    <span class="keyword">let</span> allArr = [...arguments, ...args];</span><br><span class="line">    <span class="comment">// 6. 执行函数并返回</span></span><br><span class="line">    <span class="keyword">let</span> result = thisArg.fn(...allArr);</span><br><span class="line">    <span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>call/apply/bind三者的区别</li></ol><ul><li>call、apply和bind的第一个参数作用一致。</li><li>call和apply的区别在于call的第二个参数为一个<code>参数列表</code>,而apply的第二个参数为一个<code>数组或类数组</code>。</li><li>call和apply会立即调用函数，但bind内部会返回一个新的函数。</li></ul><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ol><li>arguments是一个对应于传递给函数的参数的<code>类数组对象</code>。</li><li>arguments为什么是类数组?</li></ol><ul><li>它拥有数组的一些特性,比如length、可以通过index索引获取值。</li><li>但是没有数组的一些方法,比如forEach、map等。</li></ul><ol start="3"><li>将arguments转成数组的方法</li></ol><ul><li>通过for循环遍历,将遍历的各个项push到一个新数组中。</li><li>通过<code>Array.prototype.slice.call(arguments)</code>或[].slice.call(arguments)。</li><li>通过ES6语法<code>Array.from(arguments)</code>。</li><li>通过展开运算符: <code>[...arguments]</code>。</li></ul><h2 id="JavaScript纯函数"><a href="#JavaScript纯函数" class="headerlink" title="JavaScript纯函数"></a>JavaScript纯函数</h2><ol><li>纯函数定义:</li></ol><ul><li>相同的输入,一定会产生相同的输出。</li><li>函数在执行过程中,不能产生<code>副作用</code>。</li><li><code>副作用</code>表示在执行一个函数时,除了<code>返回函数值</code>之外,还对调用函数产生了附加的影响,比如<code>修改了全局变量</code>,<code>修改参数或者改变外部的存储</code>。</li></ul><h2 id="JavaScript柯里化"><a href="#JavaScript柯里化" class="headerlink" title="JavaScript柯里化"></a>JavaScript柯里化</h2><ol><li>柯里化定义:</li></ol><ul><li>只<code>传递函数的一部分参数</code>来调用它,让它<code>返回一个函数去处理剩余的参数</code>;</li><li>这个过程就称之为柯里化</li></ul><ol start="2"><li>柯里化的过程<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> result3 = <span class="function"><span class="params">x</span> =&gt;</span> <span class="function"><span class="params">y</span> =&gt;</span> <span class="function"><span class="params">z</span> =&gt;</span> x + y + z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = foo1(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> result2 = foo2(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result1, result2, result3(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>)); <span class="comment">// 60 60 60</span></span><br></pre></td></tr></table></figure></li><li>柯里化的作用</li></ol><ul><li>让<code>一个函数处理的问题尽可能的单一</code>,而不是将<code>一大堆的处理过程交给单个函数来处理</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">  x = x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    y = y * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 处理逻辑</span></span><br><span class="line">      z = z - <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">10</span>)(<span class="number">20</span>)(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li>逻辑的复用性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="params">date</span> =&gt;</span> <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;date.getHours()&#125;</span>:<span class="subst">$&#123;date.getMinutes()&#125;</span>-<span class="subst">$&#123;type&#125;</span>: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 避免多次调用,固定传参重复书写</span></span><br><span class="line"><span class="keyword">var</span> nowLog = log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">nowLog(<span class="string">&#x27;debug&#x27;</span>)(<span class="string">&#x27;出错了&#x27;</span>); <span class="comment">// 22:52-debug: 出错了</span></span><br><span class="line">nowLog(<span class="string">&#x27;debug&#x27;</span>)(<span class="string">&#x27;连接服务器失败&#x27;</span>); <span class="comment">// 22:52-debug: 连接服务器失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nowTypeLog = log(<span class="keyword">new</span> <span class="built_in">Date</span>())(<span class="string">&#x27;debug&#x27;</span>);</span><br><span class="line">nowTypeLog(<span class="string">&#x27;出错了&#x27;</span>); <span class="comment">// 22:52-debug: 出错了</span></span><br><span class="line">nowTypeLog(<span class="string">&#x27;连接服务器失败&#x27;</span>); <span class="comment">// 22:52-debug: 连接服务器失败</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>函数柯里化的简单实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCurrying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 当传入的参数 大于等于 需要的参数时, 就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class="line">      <span class="comment">// return fn.call(this, ...args);</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当没有达到时,需要返回一个新的函数,继续接收参数</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">curried2</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 接收到参数后,进行递归调用curried,直到满足条件</span></span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, [...args, ...args2]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> curried2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curried;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>组合函数</li></ol><ul><li>组合函数是在JavaScript开发过程中的一种对<code>函数使用的技巧、模式</code>:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composite</span>(<span class="params">fn1, fn2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn2(fn1(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> calcFn = composite(add, square);</span><br><span class="line">calcFn(<span class="number">2</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure></li><li>组合函数的简单实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入多个函数,所以需要用剩余运算符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compositeFns</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断传入的类型,如果不为函数类型,提示错误</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fns[i] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error, type is not function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 该函数接收传入的参数,并返回</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">composite</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> result = fns.length ? fns[index].apply(<span class="built_in">this</span>, args) : args;</span><br><span class="line">    <span class="keyword">while</span>(++index &lt; length) &#123;</span><br><span class="line">      result = fns[index].call(<span class="built_in">this</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h2></li></ul><ol><li>属性描述符</li></ol><ul><li>通过属性描述符可以<code>精准的添加或修改对象的属性</code>。</li><li>属性描述符需要使用<code>Object.defineProperty</code>来对属性进行添加或修改。</li><li>Object.defineProperty(obj, prop, descriptor);可接收三个参数:<ol><li>obj: 要定义属性的对象;</li><li>prop: 要定义或修改的属性的名称或Symbol;</li><li>descriptor: 要定义或修改的属性描述符;</li></ol></li><li>属性描述符的类型有两种:<ol><li><code>数据属性</code>描述符</li><li><code>存取属性</code>描述符</li></ol></li><li>数据描述符有如下四个特性:<ol><li><code>[[Configurable]]</code>: 表示属性是否可以通过delete删除属性,是否可以修改它的特性,或者是否可以将他修改为存取属性描述符。（是否可配置的）</li></ol><ul><li>当直接在一个对象上定义某个属性时,这个属性的<code>[[Configurable]]</code>默认为true;</li><li>当通过属性描述符定义一个属性时,这个属性的<code>[[Configurable]]</code>默认为false;</li></ul><ol start="2"><li><code>[[Enumerable]]</code>: 表示属性是否可以通过for-in或Object.keys()返回该属性。</li></ol><ul><li>当直接在一个对象上定义某个属性时,这个属性的<code>[[Enumerable]]</code>默认为true;</li><li>当通过属性描述符定义一个属性时,这个属性的<code>[[Enumerable]]</code>默认为false;</li></ul><ol start="3"><li><code>[[Writable]]</code>: 表示是否可以修改属性的值</li></ol><ul><li>当直接在一个对象上定义某个属性时,这个属性的<code>[[Writable]]</code>默认为true;</li><li>当通过属性描述符定义一个属性时,这个属性的<code>[[Writable]]</code>默认为false;</li></ul><ol start="4"><li><code>[[value]]</code>: 属性的value值,读取属性时会返回该值,修改属性时,会对其进行修改;</li></ol><ul><li>默认情况下这个值为undefined</li></ul></li><li>存取属性描述符有如下特性:<ol><li>隐藏某一个私有属性不希望直接被外界使用和赋值</li><li>如果希望截获某一个属性它的访问和设置值的过程时,也会使用存取属性描述符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  _address: <span class="string">&#x27;广州市&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;address&#x27;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 获取值</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._address</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接收值并修改</span></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._address = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj._address); <span class="comment">// 广州市</span></span><br><span class="line">obj._address = <span class="string">&#x27;赤壁市&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj._address); <span class="comment">// 赤壁市</span></span><br></pre></td></tr></table></figure></li></ol></li><li>私有属性补充: 如果以_下划线开头定义的属性,统一规范为私有属性。</li><li>给对象定义多个属性描述符, <code>Object.defineProperties()</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  _age: <span class="number">18</span>,</span><br><span class="line">  <span class="comment">// 这种写法默认configurable和enumerable为true</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">age</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>._age = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">&quot;wbw&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这种写法可以更精准的控制configurable和enumerable</span></span><br><span class="line">  age: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._age</span><br><span class="line">    &#125;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>._age = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>创建对象的方法</li></ol><ul><li>工厂模式(缺点: 打印对象的时,类型都为Object类型,无法拿到具体的类型)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> p = &#123;&#125;;</span><br><span class="line">  p.name = name;</span><br><span class="line">  p.age = age;</span><br><span class="line">  p.height = height;</span><br><span class="line">  p.eating = <span class="function"><span class="title">functon</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>在吃东西`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = createPerson(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>, <span class="number">178</span>);</span><br></pre></td></tr></table></figure></li><li>构造函数<ol><li>通过new关键字去调用一个函数时,那么这个函数就是一个构造函数。</li><li>如果一个函数被使用new操作符调用了,那么它会执行以下步骤:</li></ol><ul><li>在内存中创建一个新的对象(空对象);</li><li>这个对象内部的<code>[[prototype]]</code>属性会被赋值为该构造函数的<code>prototype</code>属性;</li><li>构造函数内部的this,会指向创建出来的新对象;</li><li>指向函数的内部代码(函数体代码);</li><li>如果构造函数没有返回非空对象,则返回创建出来的新对象;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.height = height;</span><br><span class="line">  <span class="comment">// this.eating = function() &#123;</span></span><br><span class="line">  <span class="comment">//  console.log(`$&#123;this.name&#125;在吃东西`);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eating = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>在吃东西`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>, <span class="number">178</span>);</span><br><span class="line">p1.eating();</span><br></pre></td></tr></table></figure></li></ul></li><li>对象的原型<ol><li>每个对象(实例对象)中都有一个<code>[[prototype]]</code>属性(即<strong>proto</strong>),这个属性指向的是原型对象(隐式原型)。</li><li>每个构造函数中都有一个prototype属性,这个属性指向的是原型对象(显示原型)。</li><li>给原型对象上添加属性或方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 方式一,添加多个属性或方法时,重复写多次Foo.prototype,可以使用方式二</span></span><br><span class="line">Foo.prototype.name = <span class="string">&#x27;wbw&#x27;</span>;</span><br><span class="line">Foo.prototype.age = <span class="number">18</span>;</span><br><span class="line">Foo.prototype.eating = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Foo.prototype.name&#125;</span>在吃东西`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二,重写原型对象</span></span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  eating = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为原型对象上默认会有一个constructor,且不可枚举</span></span><br><span class="line"><span class="built_in">Object</span>.definProperty(Foo.prototype, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  value: Foo</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="3"><li>Object的原型</li></ol><ul><li>什么地方是原型链的尽头?<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__.__proto__.__proto__); <span class="comment">// 打印的结果为[Object: null prototype] &#123;&#125;</span></span><br><span class="line"><span class="comment">// 1. 事实上[Object: null prototype] &#123;&#125;这个原型就是最顶层的原型</span></span><br><span class="line"><span class="comment">// 2. 从Object直接创建出来的对象的原型都是[Object: null prototype] &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li>[Object: null prototype] {}原型有什么特殊吗?<ol><li>特殊一: 该对象有原型对象，但是通过__proto__指向的已经为null,也就是已经是顶层原型了;</li><li>特殊二: 该对象上有很多默认的属性和方法;</li></ol></li><li><code>原型链最顶端的原型对象就是Object的原型对象</code>;<br><a href="https://imgtu.com/i/T6CwOe"><img src="https://s4.ax1x.com/2021/12/28/T6CwOe.png" alt="T6CwOe.png"></a></li></ul><ol start="4"><li>原型链继承</li></ol><ul><li>弊端一: 打印stu对象，继承的属性不可见。</li><li>弊端二: 创建出两个对象,获取引用时,如果修改了引用中的值,会相互影响。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stu1 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">let</span> stu2 = <span class="keyword">new</span> Son();</span><br><span class="line"></span><br><span class="line">stu1.friend.push(<span class="string">&#x27;lxd&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu1.friend); <span class="comment">// [&#x27;lxd&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(stu2.friend); <span class="comment">// [&#x27;lxd&#x27;]</span></span><br></pre></td></tr></table></figure></li><li>弊端三: 实现类的过程中没有传递参数,且不好处理传参问题。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;wbw&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.eating = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 在吃东西`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这两句代码顺序不能错, 如果写在Son.prototype.studing下面,那么studing方法会在Son之前的原型对象上</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 将Person的实例赋值给Son的原型</span></span><br><span class="line">Son.prototype.studing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 在学习`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(son.name); <span class="comment">// 打印结果为wbw</span></span><br><span class="line">son.eating(); <span class="comment">// 打印结果为wbw 在吃东西</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>借用构造函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 弊端一: 父类构造函数Person至少会被执行两次</span></span><br><span class="line"><span class="comment">* 弊端二: son实例对象的原型上多出不必要的属性,这些属性不应该存在</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, friend</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.friend = friend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.eating = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;在吃东西&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, friend, number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用父类容器,给每个Son构造函数new出来的实例添加对应的属性</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age, friend);</span><br><span class="line">  <span class="built_in">this</span>.number = number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里还是通过原型链将父类的实例赋值给子类的原型</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son1 = <span class="keyword">new</span> Son(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>, [<span class="string">&#x27;lxd&#x27;</span>], <span class="number">111</span>);</span><br><span class="line"><span class="keyword">let</span> son2 = <span class="keyword">new</span> Son(<span class="string">&#x27;lxd&#x27;</span>, <span class="number">18</span>, [<span class="string">&#x27;wbw&#x27;</span>], <span class="number">222</span>);</span><br><span class="line">son1.friend.push(<span class="string">&#x27;qqq&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son1.friend); <span class="comment">// [&#x27;lxd&#x27;, &#x27;qqq&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(son1.friend); <span class="comment">// [&#x27;wbw&#x27;]</span></span><br></pre></td></tr></table></figure></li><li>原型式继承</li></ol><ul><li>弊端: 还是需要手动给每个对象添加属性或方法,如果每个对象的部分属性相同,代码显得比较冗余,不灵活。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject1</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 第一个参数为要设置其原型的对象,第二个参数为对象的新原型(对象或null)</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(newObj, o);</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = createObject1(obj);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__); <span class="comment">// &#123;name: &#x27;wbw&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject2</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Fn.prototype = o;</span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="keyword">new</span> Fn();</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = createObject2(obj);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__); <span class="comment">// &#123;name: &#x27;wbw&#x27;, age: 18&#125;</span></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__); <span class="comment">// &#123;name: &#x27;wbw&#x27;, age: 18&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li>寄生组合式继承(最完善的方法)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  Fn.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritProperty</span>(<span class="params">SubType, SupType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个新的构造函数,将父类的原型赋值给新构造函数的原型,返回该构造函数的实例并赋值给子类原型。避免了修改了子类型原型对象的某个引用类型的时候, 父类型原生对象的引用类型也会被修改的问题。</span></span><br><span class="line">  SubType.prototype = createObject(SupType.prototype);</span><br><span class="line">  <span class="comment">// SubType.prototype = Object.create(SupType.prototype);</span></span><br><span class="line">  <span class="comment">// 将子类原型的constructor重新指回子类构造函数</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(SubType.prototype, <span class="string">&#x27;constructor&#x27;</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: SubType</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, friend</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.friend = friend;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.studing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  cosnole.log(<span class="string">&#x27;studing~&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.running = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;running~&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, friend, num, score</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过call继承父类构造函数Person的属性</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age, friend);</span><br><span class="line">  <span class="built_in">this</span>.num = num;</span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.eating = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;eating~&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Student, Person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>, [<span class="string">&#x27;lxd&#x27;</span>], <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu); <span class="comment">// Student &#123; name: &#x27;wbw&#x27;, age: 18, friend: [&#x27;lxd&#x27;], num: 1, score: 100 &#125;</span></span><br><span class="line">stu.studing(); <span class="comment">// studing~</span></span><br><span class="line">stu.running(); <span class="comment">// running~</span></span><br><span class="line">stu.eating(); <span class="comment">// eating~</span></span><br></pre></td></tr></table></figure></li><li>原型-判断方法的补充</li></ol><ul><li><code>hasOwnProperty()方法</code>: 判断该对象上的属性是否是自身属性而不是原型上的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__</span></span><br><span class="line"><span class="comment"> * 第一个参数为新创建对象的原型对象</span></span><br><span class="line"><span class="comment"> * 第二个参数和defineProperty()方法类似,通过属性描述符在新对象上添加属性。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="built_in">Object</span>.create(obj, &#123;</span><br><span class="line">  address: &#123;</span><br><span class="line">    value: <span class="string">&#x27;广州市&#x27;</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(info.hasOwnProperty(<span class="string">&#x27;address&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(info.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><code>in操作符</code>: 不管在当前对象还是当前对象的原型上都返回true</li><li><code>instanceof</code>: 用于检测<code>构造函数的prototype</code>,是否出现在<code>某个实例对象的原型链</code>上</li></ul><ol start="9"><li><p>原型继承关系</p><p><a href="https://imgtu.com/i/y6hltg"><img src="https://z3.ax1x.com/2021/02/15/y6hltg.png" alt="y6hltg.png"></a></p></li></ol><h2 id="ES6中类的使用"><a href="#ES6中类的使用" class="headerlink" title="ES6中类的使用"></a>ES6中类的使用</h2><ol><li>class的构造方法</li></ol><ul><li>每个类都可以有一个自己的构造函数(方法),这个方法的名称是固定的constructor;</li><li>通过new操作符,操作一个类的时候会调用这个类的构造函数constructor;</li><li>每个类只有一个构造函数,如果包含多个构造函数,那么会抛出异常;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// Person &#123; name: &#x27;wbw&#x27;, age: 18 &#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>class中的方法定义<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>._address = <span class="string">&#x27;广州市&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义普通的实例方法</span></span><br><span class="line">  <span class="comment">//  通过创建出来的对象进行访问的</span></span><br><span class="line">  <span class="function"><span class="title">eating</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;eating!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类的访问器方法</span></span><br><span class="line">  <span class="comment">//  通过创建出来的对象进行访问的</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">address</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">address</span>(<span class="params">newAddress</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._address = newAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类的静态方法</span></span><br><span class="line">  <span class="comment">// 通过类名访问,Person.createPerson()</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">createPerson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;静态方法调用成功&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.eating()); <span class="comment">// eating!</span></span><br><span class="line"><span class="built_in">console</span>.log(p._address); <span class="comment">// 广州市</span></span><br><span class="line">p._address = <span class="string">&#x27;深圳市&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p._address); <span class="comment">// 深圳市</span></span><br><span class="line"><span class="keyword">var</span> pp = Person.createPerson(); <span class="comment">// 静态方法调用成功</span></span><br></pre></td></tr></table></figure></li><li>class中实现继承extends</li></ol><ul><li>super关键字使用方法:<ul><li>在子类的构造函数中<code>使用this或者返回默认对象之前</code>,<code>必须先通过super调用父类的构造函数</code>;</li><li>super的使用位置有三个: 子类的构造函数、实例方法、静态方法;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">running</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;running&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">FaMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, address</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父对象/父类的构造函数: super([arguments])</span></span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">    <span class="built_in">this</span>.address = address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类对父类方法的重写</span></span><br><span class="line">  <span class="function"><span class="title">running</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Student &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27; running&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类对父类方法的重写，但保留父类的方法: super.xxx([arguments])</span></span><br><span class="line">  <span class="function"><span class="title">FaMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.FaMethod();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类重写父类的静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.staticMethod();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;static1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;广州市&#x27;</span>);</span><br><span class="line">stu.running(); <span class="comment">// Student wbw running</span></span><br><span class="line">stu.FaMethod(); <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">Student.staticMethod(); <span class="comment">// static static1 </span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="4"><li>JavaScript中的多态</li></ol><ul><li>不同的数据类型进行同一个操作,表现出不同的行为,就是多态的体系。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + m;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">sum(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>) <span class="comment">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ES6知识点"><a href="#ES6知识点" class="headerlink" title="ES6知识点"></a>ES6知识点</h2></li></ul><ol><li>解构赋值</li></ol><ul><li>数组的解构<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = [<span class="string">&quot;wbw&quot;</span>, <span class="string">&quot;lxd&quot;</span>, <span class="string">&quot;kiko&quot;</span>];</span><br><span class="line"><span class="comment">// 解构数组全部元素</span></span><br><span class="line"><span class="keyword">var</span> [item1, item2, item3] = name;</span><br><span class="line"><span class="built_in">console</span>.log(item1, item2, item3); <span class="comment">// wbw lxd kiko</span></span><br><span class="line"><span class="comment">// 解构指定数组元素</span></span><br><span class="line"><span class="keyword">var</span> [, itema, itemb] = name;</span><br><span class="line"><span class="built_in">console</span>.log(itema, itemb); <span class="comment">// lxd kiko</span></span><br><span class="line"><span class="comment">// 解构的默认值</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c, d = <span class="string">&#x27;dyz&#x27;</span>] = name;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// dyz</span></span><br></pre></td></tr></table></figure></li><li>对象的解构<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; name, age &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">// wbw 18</span></span><br><span class="line"><span class="comment">// 对解构名重新命名</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: newName &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(newName); <span class="comment">// wbw</span></span><br><span class="line"><span class="comment">// 解构的默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; address = <span class="string">&#x27;广州市&#x27;</span> &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(address); <span class="comment">// 广州市</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>let-const的基本使用</li></ol><ul><li>注意事项一: <code>const</code>本质是传递的值不可以修改,但是如果传递的是一个引用类型(内存地址),可以通过引用找到对应的对象,去修改对象内部的属性。</li><li>注意事项二: <code>let/const</code>定义的变量名是不可以重复定义的</li></ul><ol start="3"><li>let/const有没有作用域提升?</li></ol><ul><li><code>作用域提升</code>: 在声明变量的作用域中,如果这个变量可以在声明之前被访问,可以称之为变量提升</li><li>但是<code>let/cons</code>t在声明前无法访问到变量,所以没有进行作用域提升,但是会在执行上下文阶段被创建出来。</li><li>全局通过var来声明的变量,会在Window上添加一个属性;但是let、const是不会在window上添加任何属性的。</li></ul><ol start="4"><li>ES6的块级作用域</li></ol><ul><li>对于let/const/function/class声明的类型是有效的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;demo function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// foo is not defined</span></span><br><span class="line"><span class="comment">// 函数比较特殊,(大部分浏览器为了兼容旧版本,使得function没有块级作用域)</span></span><br><span class="line">demo(); <span class="comment">// demo function</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); <span class="comment">// Person is not defined</span></span><br></pre></td></tr></table></figure></li><li>if语句/switch语句/for循环都是<code>块级作用域</code></li><li><code>暂时性死区</code>: 使用let、const声明的变量,在声明之前,变量都是不可以访问的</li></ul><ol start="5"><li>let、const的选择</li></ol><ul><li>优先使用const,可以保证数据的安全性,不会被随意。</li><li>只有当明确知道一个变量后续需要被重新赋值时,再去使用let。</li></ul><ol start="6"><li>标签模板字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是模块字符串中整个字符串,会被分成多块,放入数组中</span></span><br><span class="line"><span class="comment">// 第二个参数是模板字符串中,第一个$&#123;&#125;里的值,以此类推</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(m, n); <span class="comment">// [&#x27;Hello&#x27;, &#x27;World&#x27;] wbw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;wbw&#x27;</span>;</span><br><span class="line">foo<span class="string">`Hello<span class="subst">$&#123;name&#125;</span>World`</span></span><br></pre></td></tr></table></figure></li><li>函数默认参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">m = <span class="string">&#x27;wbw&#x27;</span>, n = <span class="string">&#x27;lxd&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(m, n);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// wbw lxd</span></span><br><span class="line"><span class="comment">// 默认值为对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">obj = &#123; name: <span class="string">&#x27;wbw&#x27;</span>, age: <span class="number">18</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.name, obj.age);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// wbw 18</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>有默认值的形参最好放最后面</li><li>有默认值的函数的length,该形参(包括)之后的都不会计算再函数长度内<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c = <span class="number">2</span>, d</span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>函数剩余参数</li></ol><ul><li>如果最后一个参数是…为前缀,那么它会将剩余的参数放到该参数中,并作为一个数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">m, n, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(m, n); <span class="comment">// 1 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// [3, 4, 5]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li>剩余参数和arguments的区别?<ul><li>剩余参数只包含那些<code>没有对应形参的实参</code>,而arguments对象包含了<code>传给函数的所有实参</code>;</li><li>剩余参数是一个真正的数组，arguments只是一个类数组,不具有数组的方法;</li><li>剩余参数必须放到最后一个位置,否则会报错。</li></ul></li></ul><ol start="9"><li>展开运算符的三种场景的使用</li></ol><ul><li>函数调用时使用</li><li>将两个数组拼接时使用</li><li>构建对象字面量时使用</li><li><code>展开运算符会进行浅拷贝</code>,只对第一层进行拷贝,内部的数组或对象仅仅是将引用地址进行赋值,会互相影响。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  friend: &#123;</span><br><span class="line">    name: <span class="string">&#x27;lxd&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;...info, <span class="attr">address</span>: <span class="string">&#x27;广州市&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(info); <span class="comment">// &#123;name: &#x27;wbw&#x27;, age: 18, friend: &#123;name: &#x27;lxd&#x27;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一方的friend变化时,另一个对象中的friend也会发生改变</span></span><br><span class="line">obj.friend.name = <span class="string">&#x27;kiko&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(info); <span class="comment">// &#123;name: &#x27;wbw&#x27;, age: 18, friend: &#123;name: &#x27;kiko&#x27;&#125;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="10"><li>Symbol的基本使用</li></ol><ul><li>Symbol用来<code>生成一个独一无二的值</code>;<ul><li>Symbol值是通过Symbol函数来生成的,生成后可以作为<code>属性名</code>;</li><li>在ES6中,对象的属性名可以<code>使用字符串</code>,也可以<code>使用Symbol值</code>;</li></ul></li><li>在创建Symbol值的时候可以传入一个描述description<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol函数不需要new关键字来调用</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;nihao&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym.description); <span class="comment">// nihao</span></span><br></pre></td></tr></table></figure></li><li>Symbol作为key的常用写法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// 写法一,定义对象字面量时</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [s1]: <span class="string">&#x27;Wbw~&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写法二, 新增属性</span></span><br><span class="line">obj[s1] = <span class="string">&#x27;Wbw~&#x27;</span>;</span><br><span class="line"><span class="comment">// 写法三,Object.defineProperty</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, s1, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">&#x27;Wbw~&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[s1]); <span class="comment">// Wbw~</span></span><br></pre></td></tr></table></figure></li><li>使用Symbol作为key的属性名,在<code>遍历/Object.keys</code>是获取不到Symbol值的,需要通过<code>Obect.getOwnPropertySymbols()方法</code>来获取所有Symbol</li></ul><ol start="11"><li>Set的基本使用</li></ol><ul><li>Set是一个新增的数据结构,可以用来保存数据,类似于数组,但是和数组的区别是<code>元素不能重复</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的去重一</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">123</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">const</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newArr.indexOf(i) === -<span class="number">1</span>) &#123;</span><br><span class="line">    newArr.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [11, 22, 33, 123]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的去重二</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">123</span>, <span class="number">11</span>];</span><br><span class="line"><span class="comment">// const newArr = [...new Set(arr)];</span></span><br><span class="line"><span class="keyword">const</span> newArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br></pre></td></tr></table></figure></li><li>Set的属性和方法<ul><li><code>size</code>: 返回Set中元素的个数;</li><li><code>add(value)</code>: 添加某个元素,返回Set对象本身;</li><li><code>has(value)</code>: 判断set中是否存在某个元素,返回Boolean值;</li><li><code>delete(value)</code>: 从set中删除这个值相等的元素,返回Boolean值;</li><li><code>clear()</code>: 清空set中所有元素,无返回值;</li></ul></li><li>可以通过forEach或者for…of进行遍历Set</li></ul><ol start="12"><li>WeakSet的基本使用</li></ol><ul><li>Set和WeakSet的区别?<ul><li>区别一: <code>WeakSet中只能存放对象类型</code>,不能存放基本数据类型;</li><li>区别二: <code>WeakSet对元素的引用是弱引用</code>,如果没有其它引用对某个对象进行引用时,GC会对该对象进行回收处理;</li></ul></li><li>注意点: <strong>WeakSet不能进行遍历！</strong><ul><li>因为WeakSet只是对对象的弱引用,如果遍历获取到其中的元素,可能会造成对象不能正常的销毁</li><li><strong>存储WeakSet中的对象是无法获取的</strong>;</li></ul></li></ul><ol start="13"><li>Map的常用方法</li></ol><ul><li>Map类型以键值对的形式存在;</li><li>Map常用的属性:<ul><li>size: 返回Map中的元素个数;</li></ul></li><li>Map常用的方法:<ul><li><code>set(key, value)</code>: 在Map中添加key、value,并返回整个Map对象;</li><li><code>get(key)</code>: 根据key获取Map中的value;</li><li><code>has(key)</code>: 判断是否包括某个key,返回Boolean类型;</li><li><code>delete(key)</code>: 根据key删除一个键值对,返回Boolean类型;</li><li><code>clear()</code>: 删除所有的元素;</li></ul></li><li>可以通过forEach或者for…of进行遍历Map;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;wbw&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// 往Map中添加元素的两种方法</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [ obj, <span class="string">&#x27;good&#x27;</span> ]</span><br><span class="line">]);</span><br><span class="line">map.set(<span class="string">&#x27;good&#x27;</span>, <span class="string">&#x27;man&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(2) &#123;&#123; name: &#x27;wbw&#x27; &#125; =&gt; &#x27;good&#x27;, &#x27;good&#x27; =&gt; &#x27;man&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="14"><li>WeakMap的使用</li></ol><ul><li>WeakMap和Map的区别?<ul><li>区别一: <strong>WeakMap的key只能使用对象</strong>,不接受其他的类型作为key;</li><li>区别二: WeakMap的key对对象的引用是<code>弱引用</code>,如果没有引用该对象,GC可以回收该对象。</li></ul></li><li>WeakMap没有size属性,打印结果为undefined;WeakMap不能进行遍历;</li></ul><ol start="15"><li>indexOf和includes的区别</li></ol><ul><li><code>indexOf()</code>和<code>includes()</code>都是判断字符串或数组中是否有传入的值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;wbw&#x27;</span>, <span class="string">&#x27;lxd&#x27;</span>, <span class="string">&#x27;kiko&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(<span class="string">&#x27;wbw&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;包含wbw元素&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="string">&#x27;wbw&#x27;</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;包含wbw元素&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>indexOf()</code>方法无法正确判断数组中是否有NaN,但是<code>includes()</code>方法可以判断NaN是否存在。</li></ul><h2 id="ES8知识点"><a href="#ES8知识点" class="headerlink" title="ES8知识点"></a>ES8知识点</h2><ol><li><p><code>Object.keys()</code>: 获取对象中所有的键。</p></li><li><p><code>Object.values()</code>: 获取对象中所有的值。</p></li><li><p><code>Object.entries()</code>: 获取对象中所有的键值对,并以数组的形式返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>,keys(obj); <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// [&#x27;wbw&#x27;, 18]</span></span><br><span class="line"><span class="comment">// 如果传入字符串,会把字符串拆分成单独的每一个,并存入数组中</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="string">&#x27;wbw&#x27;</span>); <span class="comment">// [&#x27;w&#x27;, &#x27;b&#x27;, &#x27;w&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [ [&#x27;name&#x27;, &#x27;wbw&#x27;], [&#x27;age&#x27;, 18] ]</span></span><br></pre></td></tr></table></figure><h2 id="ES10知识点"><a href="#ES10知识点" class="headerlink" title="ES10知识点"></a>ES10知识点</h2></li><li><p><code>flat()</code>方法会按照一个可指定深度递归遍历数组,并将所有元素与遍历到的子数组中的元素合并为一个新的数组返回。</p></li><li><p><code>flatMap()</code>方法首先使用映射函数映射每个元素,然后将结果压缩成一个新数组。</p></li></ol><ul><li>注意一: flatMap是先进行map操作,再flat;</li><li>注意二: flatMap中的flat相当于深度为1;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ [ [<span class="number">0</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">6</span>] ], <span class="number">12</span>, <span class="number">34</span>, [<span class="number">8</span>, <span class="number">99</span>], <span class="number">15</span> ];</span><br><span class="line">nums.flat(<span class="number">1</span>); <span class="comment">// [ [0, 5], [3, 6], 12, 34, 8, 99, 15 ]</span></span><br><span class="line">nums.flat(<span class="number">2</span>); <span class="comment">// [0, 5, 3, 6, 12, 34, 8, 99, 15]</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><code>Object.fromEntries(iterable)</code>方法将键值对列表转换为对象。</li></ol><h2 id="ES11知识点"><a href="#ES11知识点" class="headerlink" title="ES11知识点"></a>ES11知识点</h2><ol><li>BigInt</li></ol><ul><li>大于MAX_SAFE_INTEGER的数值,表示的可能是不正确的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxInt = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maxInt + <span class="number">1</span>); <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="built_in">console</span>.log(maxInt + <span class="number">2</span>); <span class="comment">// 9007199254740992</span></span><br></pre></td></tr></table></figure></li><li>ES11中,引入了新的数据类型BigInt,用于表示大的整数:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bigInt = <span class="number">9007199254740991n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bigInt + <span class="number">1n</span>); <span class="comment">// 9007199254740992n</span></span><br><span class="line"><span class="built_in">console</span>.log(bigInt + <span class="number">2n</span>); <span class="comment">// 9007199254740993n</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>空值合并运算符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">0</span>,</span><br><span class="line">      bar = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为||无法判断0或&quot;&quot;,可以通过??进行判断</span></span><br><span class="line"><span class="built_in">console</span>.log(foo || <span class="string">&#x27;default&#x27;</span>); <span class="comment">// default</span></span><br><span class="line"><span class="built_in">console</span>.log(bar || <span class="string">&#x27;default&#x27;</span>); <span class="comment">// default</span></span><br><span class="line"><span class="built_in">console</span>.log(foo ?? <span class="string">&#x27;default&#x27;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(bar ?? <span class="string">&#x27;default&#x27;</span>); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li>可选链(OptionChaining)</li></ol><ul><li>主要作用是让代码在进行null或undefined判断时更加清晰和简洁:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  girlFriend: &#123;</span><br><span class="line">    name: <span class="string">&#x27;lxd&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以前的写法</span></span><br><span class="line"><span class="keyword">if</span> (obj &amp;&amp; obj.girlFriend) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.girlFriend.name); <span class="comment">// lxd</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES11可选链写法</span></span><br><span class="line"><span class="built_in">console</span>.log(obj?.girlFriend); <span class="comment">// lxd</span></span><br></pre></td></tr></table></figure><h2 id="Proxy-Reflect"><a href="#Proxy-Reflect" class="headerlink" title="Proxy-Reflect"></a>Proxy-Reflect</h2></li></ul><ol><li>监听对象的操作<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = obj[item];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, item, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`监听到<span class="subst">$&#123;item&#125;</span>被访问`</span>);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`监听到<span class="subst">$&#123;item&#125;</span>被设置`</span>);</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 监听到name被访问 wbw</span></span><br><span class="line">obj.name = <span class="string">&#x27;lxd&#x27;</span>; <span class="comment">// 监听到name被设置 &#x27;lxd&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>缺点: 无法监听更加丰富的操作,比如<code>删除属性</code>、<code>新增属性</code>。</li></ul><ol start="2"><li>Proxy基本使用</li></ol><ul><li>如果想要<code>监听一个对象的相关操作</code>,可以先<code>创建一个代理对象(Proxy对象)</code>;</li><li>之后对<code>该对象的所有操作</code>,都通过<code>代理对象来完成</code>,代理对象<code>可以监听我们想要对原对象进行哪些操作</code>;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首先new Proxy对象,并传入需要侦听的对象和一个处理对象,称之为handle</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`obj中的<span class="subst">$&#123;key&#125;</span>属性被访问`</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`obj中的<span class="subst">$&#123;key&#125;</span>属性被设置`</span>);</span><br><span class="line">    target[key] = newValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听in的捕获器</span></span><br><span class="line">  has: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`监听到obj中的<span class="subst">$&#123;key&#125;</span>属性in操作`</span>);</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听delete的捕获器</span></span><br><span class="line">  deleteProperty: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`监听到obj中的<span class="subst">$&#123;key&#125;</span>属性delete操作`</span>);</span><br><span class="line">    <span class="keyword">delete</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接操作Proxy的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// obj中的name被访问 &#x27;wbw&#x27;</span></span><br><span class="line">proxy.name = <span class="string">&#x27;lxd&#x27;</span>; <span class="comment">// obj中的name被设置&#x27;lxd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// 监听到obj中的name属性in操作 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete操作符</span></span><br><span class="line"><span class="keyword">delete</span> proxy.name; <span class="comment">// 监听到obj中的age属性delete操作 false</span></span><br></pre></td></tr></table></figure></li><li>如果要侦听某些具体的操作,可以在handler中添加对应的捕捉器(trap):</li><li><code>set函数</code>有四个参数:<ul><li>target: 目标对象(侦听的对象);</li><li>property: 将要被设置的属性key;</li><li>value: 新属性值;</li><li>receiver: 调用的代理对象;</li></ul></li><li><code>get函数</code>有三个参数:<ul><li>target: 目标对象(侦听的对象);</li><li>property: 被获取的属性key;</li><li>receiver: 调用的代理对象;</li></ul></li><li><code>has函数</code>和<code>deleteProperty函数</code>有两个参数:<ul><li>target: 目标对象(侦听的对象);</li><li>property: 被获取的属性key;</li></ul></li><li>其他函数方法参照MDN: <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(foo, &#123;</span><br><span class="line">  <span class="comment">// 函数调用操作捕获器</span></span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisArg, argArray</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;对foo函数进行了apply调用&#x27;</span>);</span><br><span class="line">    target.apply(thisArg, argArray);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// new操作符捕获器</span></span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, argArray</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;对foo函数进行了new调用&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> target(...argArray);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.apply(&#123;&#125;, [<span class="string">&#x27;wbw&#x27;</span>, <span class="string">&#x27;lxd&#x27;</span>]);</span><br><span class="line"><span class="keyword">new</span> proxy();</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>Reflect的作用</li></ol><ul><li>Reflect是ES6新增的一个API,它是一个<code>对象</code>;</li><li>Reflect的用处?<ul><li>它提供了很多<strong>操作JavaScript对象的方法</strong>,和<strong>Object中操作对象的方法</strong>类似;</li></ul></li><li>Reflect的常见方法与Proxy一一对应,只列出重要的几个:<ul><li><code>Reflect.has(target, propertyKey)</code>: 判断一个对象是否存在某个属性,和in运算符的功能完全相同</li><li><code>Reflect.get(target, propertyKey[,receiver])</code>: 获取对象上某个属性的值,类似于<code>target[name]</code>;</li><li><code>Reflect.set(target, propertyKey, newValue[, receiver]</code>: 将值分配给对应属性的函数;如果更新成功则返回true;</li><li><code>Reflect.deleteProperty(target, propertyKey)</code>: 作为函数的delete操作符,相当于执行<code>delete target[name]</code>;</li></ul></li></ul><ol start="4"><li>Receiver的作用</li></ol><ul><li><strong>如果源对象有getter、setter的访问器属性,那么可以通过receiver来改变this的指向</strong>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  _name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 将this指向proxy代理对象</span></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, newValue, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, newValue, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>Reflect的construct<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="built_in">Reflect</span>.construct(Student, [<span class="string">&#x27;wbw&#x27;</span>, <span class="number">18</span>], Teacher);</span><br><span class="line"><span class="built_in">console</span>.log(stu.__proto__ === Teacher.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><!-- ## Vue3响应式和Vue2响应式 --></li></ol><h2 id="Promise及手写Promise"><a href="#Promise及手写Promise" class="headerlink" title="Promise及手写Promise"></a>Promise及手写Promise</h2><blockquote><ol><li>promise: <a href="https://784801819.github.io/2021/02/17/js-yi-bu-bian-cheng-zhi-shi-dian/#toc-heading-4">https://784801819.github.io/2021/02/17/js-yi-bu-bian-cheng-zhi-shi-dian/#toc-heading-4</a></li></ol></blockquote><blockquote><ol start="2"><li>手写promise: <a href="https://784801819.github.io/2021/02/19/shou-xie-promise/">https://784801819.github.io/2021/02/19/shou-xie-promise/</a></li></ol></blockquote><h2 id="迭代器-可迭代对象-生成器用法"><a href="#迭代器-可迭代对象-生成器用法" class="headerlink" title="迭代器-可迭代对象-生成器用法"></a>迭代器-可迭代对象-生成器用法</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ol><li>在JavaScript中，迭代器也是一个<code>具体的对象</code>，这个对象需要符合<code>迭代器协议</code>:</li></ol><ul><li>在js中这个标准就是一个特定的<code>next方法</code>;</li></ul><ol start="2"><li>next方法有如下要求:</li></ol><ul><li>一个无参数函数,返回一个应当拥有以下两个属性的对象:<ul><li><strong>done(boolean)</strong>: <code>如果迭代器可以产生序列中的下一个值,则为false。如果迭代器已将序列迭代完毕,则为true</code>。这种情况下,value是可选的,如果它依然存在,即为迭代结束的默认返回值</li><li>value: 迭代器返回的任何JavaScript值,done为true时可省略。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: arr[index++] &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="3"><li>可迭代对象</li></ol><ul><li>它和迭代器概念是不同的;</li><li>当一个对象实现了iterable protocol协议时,它就是一个可迭代对象;</li><li>这个对象的要求是必须实现<code>@@iterator</code>方法,在代码中使用<code>Symbol.iterator</code>访问该属性;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObj = &#123;</span><br><span class="line">  friends: [<span class="string">&#x27;wbw&#x27;</span>, <span class="string">&#x27;lxd&#x27;</span>, <span class="string">&#x27;kiko&#x27;</span>],</span><br><span class="line">  [Symbole.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回一个迭代器</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="built_in">this</span>.friends.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.friends[index++] &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> ierableObj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// wbw lxd kiko</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>原生迭代器对象</li></ol><ul><li>String、Array、Map、Set、arguments对象、NodeList集合(DOM);</li></ul><ol start="5"><li>可迭代对象的应用</li></ol><ul><li>JavaScript中的语法: for…of、展开运算符、yield*、解构赋值;</li><li>创建一些对象时: new Map([Iterable])、new WeakMap([Iterable])、new Set([Iterable])、new WeakSet([Iterable]);</li><li>一些方法的调用: Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable);</li></ul><ol start="6"><li>自定义类的迭代</li></ol><ul><li>面向对象开发中,可以通过class定义一个自己的类,这个类可以创建很多对象。</li><li>如果希望自己的类创建出来的对象默认是可迭代的,可以在类里添加@@iterator方法;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classroom</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, address, students</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.address = address;</span><br><span class="line">    <span class="built_in">this</span>.students = students;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">entry</span>(<span class="params">student</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.students.push(student);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里是关键</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="built_in">this</span>.students.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.students[index++] &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 终止迭代器</span></span><br><span class="line">      <span class="keyword">return</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;迭代器终止&#x27;</span>);</span><br><span class="line">        <span class="comment">// 终止需返回一个done为true的对象</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classroom = <span class="keyword">new</span> Classroom(<span class="string">&#x27;111&#x27;</span>, <span class="string">&#x27;222&#x27;</span>, [<span class="string">&#x27;wbw&#x27;</span>, <span class="string">&#x27;lxd&#x27;</span>]);</span><br><span class="line">classroom.entry(<span class="string">&#x27;kiko&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> classroom) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// wbw lxd kiko</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3></li></ul><ol><li>什么是生成器?</li></ol><ul><li>生成器是ES6中新增的一种函数控制、使用的方案,可以灵活控制函数什么时候开始执行、结束执行等。</li><li>生成器函数也是一个函数,和普通函数的区别:<ul><li><strong>生成器函数需要在function后面加一个符号: <code>*</code></strong>;</li><li><strong>生成器函数可以通过yield关键字来控制函数的执行流程</strong></li><li><strong>生成器函数的返回值是一个Generator(生成器),是一个特殊的迭代器</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到yield时暂停函数的执行</span></span><br><span class="line"><span class="comment">// 遇到return时生成器停止执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数执行开始&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value1 = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第一段代码:&quot;</span>, value1);</span><br><span class="line">  <span class="comment">// 如果不希望next返回的是undefined时,在yield后跟需要返回的值即可</span></span><br><span class="line">  <span class="keyword">yield</span> value1</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value2 = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;第二段代码:&quot;</span>, value2);</span><br><span class="line">  <span class="keyword">yield</span> value2</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数执行结束&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;www&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator1 = generator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()) <span class="comment">// 函数执行开始, &#123; done: false, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()); <span class="comment">// 第一段代码: 100 &#123;value: 100, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()); <span class="comment">// 第二段代码: 200 &#123;value: 200, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()); <span class="comment">// 函数执行结束 &#123; value: &quot;www&quot;, done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li>生成器传递参数-next函数</li></ol><ul><li><strong>在调用next函数的时候,可以给他传递参数,那么这个参数会作为上一个yield语句的返回值</strong></li><li>也就是说我们为本次的函数代码块执行提供了一个值;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value1 = <span class="keyword">yield</span> i + <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> value2 = <span class="keyword">yield</span> value1 + <span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> value3 = <span class="keyword">yield</span> value2 + <span class="string">&#x27;ccc&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = foo(<span class="string">&#x27;wbw&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; done: false, value: wbwaaa &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="string">&#x27;lxd&#x27;</span>)); <span class="comment">// &#123; done: false, value: lxdbbb &#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="string">&#x27;kiko&#x27;</span>)); <span class="comment">// &#123; done: false, value: kikoccc &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; done: true &#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>生成器代替迭代器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createArrayIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 写法一</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写法二: yield* + 可迭代对象（语法糖）</span></span><br><span class="line">  <span class="keyword">yield</span>* arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;wbw&#x27;</span>, <span class="string">&#x27;lxd&#x27;</span>, <span class="string">&#x27;kiko&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> generator = createArrayIterator(names);</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; done: false, value: &#x27;wbw&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; done: false, value: &#x27;lxd&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; done: false, value: &#x27;kiko&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 既然生成器是一个迭代器,可以对其进行如下的操作</span></span><br><span class="line"><span class="keyword">const</span> names1 = createArrayIterator(names);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> names1) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names2 = createArrayIterator(names);</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(names2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names3 = createArrayIterator(names);</span><br><span class="line"><span class="built_in">Promise</span>.all(names3).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="异步代码的处理方式"><a href="#异步代码的处理方式" class="headerlink" title="异步代码的处理方式"></a>异步代码的处理方式</h2></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(url);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法: 回调处理,该方法会产生回调地狱,代码的阅读性非常差</span></span><br><span class="line">requestData(<span class="string">&#x27;wbw&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  requestData(<span class="string">`<span class="subst">$&#123;res&#125;</span>lxd`</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    requesData(<span class="string">`<span class="subst">$&#123;res&#125;</span>kiko`</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法: Promise中then的返回值,该方法阅读性也不好</span></span><br><span class="line">requestData(<span class="string">&#x27;wbw&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> requestData(<span class="string">`<span class="subst">$&#123;res&#125;</span>lxd`</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> requestData(<span class="string">`<span class="subst">$&#123;res&#125;</span>kiko`</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方法: Promise + generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">yield</span> requestData(<span class="string">&#x27;wbw&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">yield</span> requestData(<span class="string">`<span class="subst">$&#123;res1&#125;</span>lxd`</span>);</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">yield</span> requestData(<span class="string">`<span class="subst">$&#123;res2&#125;</span>kiko`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(res3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 手动调用</span></span><br><span class="line"><span class="keyword">const</span> generator = getData();</span><br><span class="line">generator.next().value.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  generator.next(res).value.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    generator.next(res).value.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      generator.next(res); <span class="comment">// wbwlxdkiko</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 第三方库 co自动执行</span></span><br><span class="line"><span class="comment">// 先要npm install co将包下载</span></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line">co(getData); <span class="comment">// wbwlxdkiko</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 终极方案 async/await(generator的语法糖)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> requestData(<span class="string">&#x27;wbw&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> requestData(<span class="string">`<span class="subst">$&#123;res1&#125;</span>lxd`</span>);</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> requestData(<span class="string">`<span class="subst">$&#123;res2&#125;</span>kiko`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(res3);</span><br><span class="line">&#125;</span><br><span class="line">getData(); <span class="comment">// wbwlxdkiko</span></span><br></pre></td></tr></table></figure><h2 id="异步函数async-await用法"><a href="#异步函数async-await用法" class="headerlink" title="异步函数async/await用法"></a>异步函数async/await用法</h2><blockquote><p><a href="https://784801819.github.io/2021/02/17/js-yi-bu-bian-cheng-zhi-shi-dian/">https://784801819.github.io/2021/02/17/js-yi-bu-bian-cheng-zhi-shi-dian/</a></p></blockquote><h2 id="Event-Loop-事件循环"><a href="#Event-Loop-事件循环" class="headerlink" title="Event Loop(事件循环)"></a>Event Loop(事件循环)</h2><blockquote><p><a href="https://784801819.github.io/2021/02/19/event-loop/#toc-heading-4">https://784801819.github.io/2021/02/19/event-loop/#toc-heading-4</a></p></blockquote><ol><li>面试题1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout1&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;then4&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;then2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;then1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;queueMicrotask1&quot;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;then3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise1 ==&gt; 2 ==&gt; then1 ==&gt; queueMicrotask1 ==&gt; then3 ==&gt; setTimeout1 ==&gt; then2 ==&gt; then4 ==&gt; setTimeout2</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>分析: 从上至下,首先setTimeout整个会被放到宏任务队列中,往下执行,new Promise会立即执行,promise1会被打印,then1会被放入微任务队列中;随后setTimeout会被放入到宏任务队列中,固第二个打印的必然是2,继续往下执行,queueMicrotask因为是微任务,所以会被放到微任务队列中,最后then3同理,也会被放入到微任务队列中。因为宏任务执行之前,会先清空微任务队列,所以依次打印then1、queueMicrotask、then3;开始执行宏任务队列,setTimeout1会被打印,随后then2、then4依次会被放入到微任务队列中。宏任务执行前清空微任务队列,依次打印then2、then4、setTimeout2</li></ul><ol start="2"><li>面试题二:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start -&gt; async2 end -&gt; Promise -&gt; script end -&gt; async1 end -&gt; promise1 -&gt; promise2 -&gt; setTimeout</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>分析: 从上至下, 因为script start为script代码,必然会立刻执行;继续往下执行,发现async1被调用,async1函数中又调用了async2,所以第二个打印的必然是async2 end;async2执行完毕后,因为函数执行完如果没返回值默认return undefined;等同于resolve(undefined),所以async1 end会被放入微任务队列中;继续执行发现setTimeout,setTimeout会被放入到宏任务队列;new Promise()时,会立即调用,故会打印Promise、且promise1和promise2会被放入微任务队列等待打印;往下发现script end;最后会将微任务队列中所有任务执行完后,最后才会输出宏任务中的setTimeout;</li></ul><ol start="3"><li>面试题三(node)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout0&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>));</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick1&#x27;</span>));</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick2&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// script start ==&gt; async1 start ==&gt; async2 ==&gt; promise1 ==&gt; promise2 ==&gt; script end ==&gt; nextTick1 ==&gt; nextTick2 ==&gt; async1 end ==&gt; promise3 ==&gt; setTimeout0 ==&gt; setImmediate ==&gt; setTimeout2</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>分析: 代码从上往下依次执行,因为async1、async2函数未被调用,代码继续向下执行,第一个打印的必然是script start;继续向下执行,setTimeout0和setTimeout2依次被放入宏任务队列中;setImmediate会放入check中等待调用;继续向下执行,nextTick1被放入到nextTick队列中;开始执行async1,第二个打印的是async1 start,随后async2被调用,第三个打印的是async2,async1 end会被放入到微任务队列中;随后new Promise立即执行,第四个打印的是promise1,promise2被放入微任务队列中,第五个打印promise2,第六个打印script end;nextTick队列永远会在mircotask之前执行,因为nextTick是独立于event loop之外的,所以会优先执行,所以nextTick1、nextTick2被打印;随后开始执行微任务队列,依次打印async1 end、promise3,微任务队列执行完毕,开始执行红任务队列,打印setTimeout0,因为setTimeout2延迟300ms,所以先打印setImmediate,最后才会打印setTimeout2</li></ul><h2 id="异常处理-CommonJS模块化"><a href="#异常处理-CommonJS模块化" class="headerlink" title="异常处理-CommonJS模块化"></a>异常处理-CommonJS模块化</h2><ol><li><p>异常的捕获(try…catch)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// try statements</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// catch statements</span></span><br><span class="line">&#125; [<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// finally statements</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><ul><li>如果有必须要执行的代码,可以使用finally来执行,它类似于promise中的finally</li><li>finally表示最终一定会被执行的代码结构</li><li>注意: 如果try和finally都有返回值,那么会使用finally的返回值</li></ul></li><li><p>什么是模块化开发?</p><ul><li>模块化开发最终目的是将程序划分成一个个小的结构;</li><li>每个结构中编写属于<code>自己的逻辑代码</code>,有<code>自己的作用域</code>,<code>互不干扰</code>;</li><li>这个结构可以将自己希望暴露的变量、函数、对象等导出给其他结构使用。</li><li>也可以通过某种方式,导入另外结构中的变量、函数、对象等;</li></ul></li><li><p>CommonJS</p></li></ol><ul><li><strong>exports是一个对象,可以在这个对象中添加很多属性,这些添加的属性会被导出</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个文件中导出</span></span><br><span class="line"><span class="built_in">exports</span>.name = name;</span><br><span class="line"><span class="built_in">exports</span>.age = age;</span><br><span class="line"><span class="comment">// 另一个文件中导入</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">require</span>(<span class="string">&#x27;./index&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li>上面这行完成的操作如下:<ul><li>require通过各种查找方式,找到了exports对象;</li><li>将exports对象赋值给了obj变量;</li><li><strong>所以,exports对象等于obj变量</strong></li></ul></li><li>module.exports和exports有什么关系和区别?<ul><li>在Node中真正导出的是<code>module.exports</code>,并非<code>exports</code>;</li></ul></li><li>为什么exports可以导出呢?<ul><li>因为module对象的exports属性是exports对象的一个引用</li><li>也就是：<code>module.exports = exports = obj</code>,三者都是引用的同一个地址,相互影响</li></ul></li><li>require细节<ol><li>导入格式为: require(X)</li><li>情况一: X是一个Node核心模块,比如path、http<ul><li>直接返回核心模块,并且停止查找</li></ul></li><li><strong>情况二</strong>: X是以<code>./</code>或<code>../</code>或<code>/(根目录)</code>开头的<ul><li>如果有后缀名,按照后缀名的格式查找对于的文件</li><li><strong>如果没有后缀名: 先查找文件X、如果没有开始查找X.js文件、如果还没有查找到继续查找X.json文件,最后会查找X.node文件</strong></li><li><strong>没有找到对于的文件时,将X作为一个目录。查找目录下的index文件,依次查找index.js、index.json和index.node文件;如果最后没找到,报错not found</strong></li></ul></li><li>情况三: X不是核心模块也不是路径<ul><li>会在node_modules文件下查找,一般用于引入第三方库</li></ul></li></ol></li><li>模块加载过程<ol><li>结论一: 模块在被第一次引入时,模块中的js代码会被运行一次</li><li>结论二: 模块被引入多次时,会有缓存,最终只会加载一次(内部会通过一个loaded属性进行控制是否被加载过)</li></ol></li></ul><h2 id="ESModule模块化"><a href="#ESModule模块化" class="headerlink" title="ESModule模块化"></a>ESModule模块化</h2><ol><li><p>导出的两种方式(export)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: export声明语句</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;wbw&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo导出了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Wang</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: export导出和声明分开</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;wbw&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo导出了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不是ES6的对象字面量增强写法, &#123;&#125;也不是表示为一个对象</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导入的三种方式(import)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: 普通的导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, foo &#125; <span class="keyword">from</span> <span class="string">&#x27;模块&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: 起别名</span></span><br><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> wName, age <span class="keyword">as</span> wAge, foo <span class="keyword">as</span> Foo &#125; <span class="keyword">from</span> <span class="string">&#x27;模块&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三: 将导出的所有内容放到一个标识符中</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> otherName <span class="keyword">from</span> <span class="string">&#x27;模块&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>default用法</p><ul><li>默认导出export时可以不需要指定名字;</li><li>导入的时候不需要使用{},并且可以自定义名字;</li><li>注意: <strong>在一个模块中,只能有一个默认导出(default export)</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认导出一: 命名默认导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> <span class="keyword">default</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出二: 常见默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>export和import结合使用</p><ul><li>在开发和封装一个功能库时,一般希望将暴露的所有接口放在一个文件里。方便指定统一接口规范,方便阅读<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> Wsum &#125; <span class="keyword">from</span> <span class="string">&#x27;模块&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>import函数</p><ul><li>通过import加载一个模块,是不可以放到逻辑代码中</li><li>这是因为这个时候js代码不会被运行</li><li>如果希望动态加载某一个模块,可以使用import()函数进行动态加载<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./modules/a.js&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./modules/b.js&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ESModule的解析流程<br><a href="https://imgtu.com/i/LnXwN9"><img src="https://s1.ax1x.com/2022/04/12/LnXwN9.png" alt="LnXwN9.png"></a></p><ul><li>阶段一:构建(construction),根据地址查找js文件,并且下载,将其解析成<code>模块记录</code>(module record)<br><a href="https://imgtu.com/i/LnxbDK"><img src="https://s1.ax1x.com/2022/04/12/LnxbDK.png" alt="LnxbDK.png"></a></li><li>阶段二:实例化(instantiation),对模块记录进行实例化,并且分配内存空间,解析模块的导入导出语句,把模块指向对应的内存地址</li><li>阶段三:运行代码,计算值,并且将值填充到内存地址中<br><a href="https://imgtu.com/i/LupwND"><img src="https://s1.ax1x.com/2022/04/12/LupwND.png" alt="LupwND.png"></a></li></ul></li></ol><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><ol><li>常见的属性<ul><li>必填的属性: name、version<ul><li>name为项目的名称</li><li>version为当前项目的版本号</li><li>description是描述信息</li><li>author是作者相关信息(发布时用到)</li><li>license是开源协议(发布时用到)</li></ul></li><li>private属性:<ul><li>记录当前项目是否为私有的</li><li>当为true的时候,npm是不能发布的,防止私有项目或模块被发布出去</li></ul></li><li>scripts属性:<ul><li>用于配置一些脚本命令,以键值对的形式存在</li><li>配置后通过npm run 命令的key来执行这个命令</li></ul></li><li>dependencies属性:<ul><li>dependencies属性是指定无论是开发环境还是生产环境都需要依赖的包</li></ul></li><li>devDependencies属性:<ul><li>一些包在生产环境是不需要的,比如webpack、Babel等</li><li>通过<code>npm install package --save-dev</code>,将其安装到devDependencies中</li></ul></li><li>peerDependencies属性:<ul><li>对等依赖,也就是你依赖的一个包,必须是以另外一个宿主包为前提的</li></ul></li></ul></li><li>依赖的版本管理<ul><li>^和~的区别:<ul><li>^x.y.z:表示x是保持不变的,y和z永远安装最新的版本</li><li>~x.y.z:表示x和y保持不变,z永远安装最新的版本</li><li>x和y分别表示主版本号和次版本号,z表示的是修订号</li></ul></li></ul></li><li>npm install命令<ul><li>安装npm包分两种情况:<ul><li>全局安装(global install): <code>npm install package -g</code></li><li>项目安装(local install): <code>npm install package</code></li></ul></li></ul></li><li>卸载某个依赖包: <code>npm uninstall package</code></li><li>发布自己的包<ul><li>在npm注册自己的账号,并在命令行中执行<code>npm login</code></li><li>修改package.json</li><li>执行<code>npm publish</code>发布到npm仓库中</li><li>更新仓库:<ul><li>修改版本号(符合semver规范)</li><li>npm publish</li></ul></li></ul></li></ol><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ol><li>使用JSON序列化深拷贝<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  friends: &#123;</span><br><span class="line">   name: <span class="string">&#x27;lxd&#x27;</span>,</span><br><span class="line">   age: <span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> objString = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="keyword">const</span> info = <span class="built_in">JSON</span>.parse(objString);</span><br><span class="line"><span class="built_in">console</span>.log(info); <span class="comment">// &#123; &quot;name&quot;: &quot;wbw&quot;, &quot;age&quot;: 18, &quot;friends&quot;: &#123; &quot;name&quot;: &quot;lxd&quot;, &quot;age&quot;: 18 &#125;&#125;</span></span><br><span class="line"><span class="comment">// 这里改变了info中friends对象的name属性</span></span><br><span class="line">info.friends.name = <span class="string">&#x27;kiko&#x27;</span>;</span><br><span class="line"><span class="comment">// 可以看出obj中的friends并没有受到影响</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.friends.name); <span class="comment">// lxd</span></span><br></pre></td></tr></table></figure><ul><li>注意: 从上述代码可以看出,foo这个函数不见了,所以JSON实现深拷贝的方法是有缺陷的。<strong>会忽略undefined</strong>、<strong>会忽略symbol</strong>、不<strong>能序列化函数</strong>以及<strong>如果存在对象的循环引用也会报错</strong></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue相关知识点</title>
      <link href="2021/05/19/vue-xiang-guan-zhi-shi-dian/"/>
      <url>2021/05/19/vue-xiang-guan-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h2><p><code>M(数据层)</code>: 负责存储数据,<code>V(视图层)</code>: 负责展示页面,<code>VM(视图模型层)</code>: 用于连接视图层和数据层,将数据层的数据传递给视图层进行展示(<strong>数据绑定</strong>)。将视图层的操作传递给数据层进行持久化(<strong>DOM监听</strong>)。</p><h3 id="Vue没有完全遵循MVVM"><a href="#Vue没有完全遵循MVVM" class="headerlink" title="Vue没有完全遵循MVVM"></a>Vue没有完全遵循MVVM</h3><p>因为严格的MVVM要求<code>视图层</code>不能和<code>数据层</code>直接通信,而Vue提供了<code>$refs</code>这个属性,让<code>数据层</code>可以直接操作<code>视图层</code>,所以Vue没有完全遵守MVVM。</p><h2 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="headerlink" title="为什么data是一个函数"></a>为什么data是一个函数</h2><p>因为对象是引用类型,如果data的值直接是一个对象的话。那么各组件中的data都是引用的同一个对象(因为地址相同),导致相互影响。在函数中return一个对象可以保证每次返回的都是新对象,这样组件之间就不会相互影响,各组件维护自己的数据。</p><h2 id="Vue生命周期函数"><a href="#Vue生命周期函数" class="headerlink" title="Vue生命周期函数"></a>Vue生命周期函数</h2><ol><li><code>beforeCreate()</code>: 实例初始化之后,当前阶段还不能通过vm获取data中的数据。</li><li><code>created()</code>: 实例已经创建完成后被调用,当前阶段可以通过vm获取到data中的数据。这里没有<code>$el</code>,如果非要想与DOM交互,可以通过<code>vm.$nextTick()</code>来访问DOM。</li><li><code>beforeMount()</code>: 在挂载开始之前被调用</li><li><code>mounted()</code>: 在挂载完成后发生,当前阶段真实DOM挂载完毕,可以通过<code>$refs</code>访问到DOM节点。</li><li><code>beforeUpdate()</code>: 数据更新时调用。</li><li><code>updated()</code>: 更新完成后。避免在此阶段改变数据,因为可能会导致无限循环的更新。</li><li><code>beforeDestory()</code>: 实例销毁之前调用。可以在此阶段做一些收尾工作,比如清除定时器。</li><li><code>destoryed()</code>: 实例销毁后调用。</li><li><code>activated()</code>和<code>deactivated()</code>需要配合<code>keep-alive</code>使用。</li></ol><ul><li>activated(): 组件被激活时调用,被复用。</li><li>deactivated(): 组件失活时调用,但没有被销毁。</li></ul><h3 id="异步请求在哪一步发起"><a href="#异步请求在哪一步发起" class="headerlink" title="异步请求在哪一步发起?"></a>异步请求在哪一步发起?</h3><p>在钩子函数<code>created</code>、<code>beforeMount</code>、<code>mounted</code>中进行异步请求都可以。因为这三个钩子函数中,<code>data</code>已经创建可以将服务端返回的数据进行赋值。</p><p>如果异步请求不需要依赖DOM,在<code>created</code>钩子函数中调用异步请求较好,优点为:</p><ul><li>能更快的获取到服务器数据,减少页面loading时间;</li><li>ssr不支持beforeMount、mounted钩子函数,放在created中有助于一致性;</li></ul><h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h2><ol><li><code>v-if</code>: 不满足条件时不渲染此节点(从文档流中删除)。</li><li><code>v-show</code>: 条件不满足时控制样式将对应节点隐藏(display: none)。</li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>如果需要频繁切换使用<code>v-show</code>效率更高,因为不会导致页面的重排。</p><h2 id="Vue组件通信的方式"><a href="#Vue组件通信的方式" class="headerlink" title="Vue组件通信的方式"></a>Vue组件通信的方式</h2><ol><li><code>props</code>父组件向子组件传递数据</li></ol><ul><li>父组件在对应子组件标签中通过<code>v-bind</code>将父组件data中的数据传递给子组件<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">:isOk</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>子组件通过<code>props</code>接收父组件传递过来的数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  isOk: <span class="built_in">String</span>/<span class="built_in">Number</span>/<span class="built_in">Function</span>/<span class="built_in">Object</span>/<span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><code>$emit</code>子组件向父组件传递数据</li></ol><ul><li>子组件通过<code>$emit</code>将数据传递给父组件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;事件名&#x27;</span>, data);</span><br></pre></td></tr></table></figure></li><li>父组件在对应的子组件标签上自定义事件,注意事件名必须一致<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span> @事件名=<span class="string">&quot;myEvent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>父组件在methods中声明并通过参数接收子组件传递的数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">myEvent</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>$attrs和$listeners</li></ol><ul><li><code>$attrs</code> 包含了父作用域中不作为prop被识别(且获取)的attribute绑定（class和style除外）。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定（class和style除外），并且可以通过<code>v-bind=&quot;$attrs&quot;</code>传入内部组件（通俗来讲，就是孙子组件可以直接获取父组件传递过来的数据）</li><li><code>inheritAttrs</code>：配合$attrs使用，默认值 true，继承所有的父组件属性（除 props 的特定绑定）作为普通的HTML特性应用在子组件的根元素上，如果你不希望组件的根元素继承特性设置 inheritAttrs: false</li><li><code>$listeners</code> 包含了父作用域中的v-on事件监听器。可以通过<code>v-bind=&quot;$listeners&quot;</code>传入内部组件。（通俗来讲，就是孙子组件可以直接通过$emit()方法调用父组件里对应的方法）</li><li>这两个方法用于多级组件通信<!-- `$parent`获取当前组件的父组件,`$children`获取当前组件的子组件,官方不推荐使用,更推荐使用`props`和`$emit`来完成父子组件的通信。 --></li></ul><ol start="4"><li><code>$refs</code>在普通DOM元素上使用,引用指向的就是DOM元素;用在组件上,引用的就是组件的实例对象,可以通过<code>this.$refs</code>访问组件上的方法和数据。</li><li><code>eventBus事件总线</code>兄弟组件数据传递</li></ol><ul><li>给Vue原型对象上添加一个属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一:</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Vue.prototype.$eventBus = <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 写法二:</span></span><br><span class="line">Vue.prototype.$eventBus = <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure></li><li>任意A组件分发自定义事件,向目标组件传递数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$evnetBus.$emit(<span class="string">&#x27;自定义事件名&#x27;</span>, data);</span><br></pre></td></tr></table></figure></li><li>任意B组件通过<code>$eventBus</code>绑定自定义事件监听,在回调函数中接收A组件传递的数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$eventBus.$on(<span class="string">&#x27;自定义事件名&#x27;</span>, callback);</span><br></pre></td></tr></table></figure></li><li>解绑自定义事件监听<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$eventBus.$off(<span class="string">&#x27;自定义事件名&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li><code>Vuex</code>集中管理组件之间共同的状态。</li></ol><ul><li><code>state</code>: 用于存储组件中共享的数据,集中管理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store和vuex通信</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="comment">// 必须写在计算属性中</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    xxx: <span class="function"><span class="params">state</span> =&gt;</span> state.xxx</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>mutations</code>: 包含多个可以直接更新state中数据的方法(回调函数)的对象,<strong>mutations中不要写异步代码或者逻辑处理函数</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  <span class="function"><span class="title">myMethods</span>(<span class="params">state, data</span>)</span> &#123;</span><br><span class="line">    state.xxx = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件中通过commit触发调用mutations里的方法</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;myMethods&#x27;</span>, data);</span><br></pre></td></tr></table></figure></li><li><code>actions</code>: 可以包含异步和逻辑代码,通过commit方法将异步获取的结果传递给mutations(间接修改state里的数据)。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">myAsync</span>(<span class="params">&#123;commit&#125;, data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 异步发请求获取数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> getInfo();</span><br><span class="line">    commit(<span class="string">&#x27;myMethods&#x27;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件中通过dispatch触发调用actions里的方法</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;myAsync&#x27;</span>, data);</span><br></pre></td></tr></table></figure></li><li><code>getters</code>: 与Vue中的computed类似,依赖于原数据进行计算得到新数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="comment">// 和mapState一样,需要写在computed里</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// getters只能通过这种方式获取store里的计算属性</span></span><br><span class="line">  ...mapGetters([<span class="string">&#x27;myGetters&#x27;</span>, ...]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>modules</code>: 用于将store分割成不同的模块,每个模块拥有自己的state、mutation、action以及getter,在模块中使用<code>namespaced: true</code>成为带命名空间的模块,解决不同模块命名冲突的问题。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中获取模块下的数据和方法</span></span><br><span class="line"><span class="comment">// 1. 获取state里的数据</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    xxx: <span class="function"><span class="params">state</span> =&gt;</span> state.模块名.xxx;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 获取getter中的计算属性</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters(<span class="string">&#x27;模块名&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;myGetters&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用mutation里的方法</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;模块名/myMethods&#x27;</span>, data);</span><br><span class="line"><span class="comment">// 4. 调用action里的方法</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;模块名/myAsync&#x27;</span>, data);</span><br></pre></td></tr></table></figure></li></ul><ol start="7"><li><p>provide和inject</p><ul><li>父组件和子孙组件通信,不管嵌套多深。但是有一个缺点就是: 不是响应式,父组件改变子孙组件是无法根据改变数据进行重新编译渲染的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// vue2解决方法</span></span><br><span class="line"> <span class="comment">// 父组件中</span></span><br><span class="line"> <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 因为provide/inject传值不是响应式,这样写可以解决响应式问题</span></span><br><span class="line">    <span class="comment">// 或者可以传递一个对象给子孙组件</span></span><br><span class="line">    isRotato: <span class="function">() =&gt;</span> <span class="built_in">this</span>.isPlay,</span><br><span class="line">    timeChange: <span class="function">() =&gt;</span> <span class="built_in">this</span>.music.currentTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 子组件中,拿到父组件传递过来的函数然后通过计算属性调用</span></span><br><span class="line">inject: [<span class="string">&#x27;isRotato&#x27;</span>];</span><br><span class="line"><span class="function"><span class="title">rotato</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.isRotato();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在vue3中，写法如下</span></span><br><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    isRotato: computed(<span class="function">() =&gt;</span> <span class="built_in">this</span>.isPlay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="comment">// 因为通过computed包裹后返回的是一个ref对象,&lt;div&gt;&#123;&#123; isRotato.value &#125;&#125;&lt;/div&gt;</span></span><br><span class="line">inject: [<span class="string">&#x27;isRotato&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="computed和watch的区别及运用场景"><a href="#computed和watch的区别及运用场景" class="headerlink" title="computed和watch的区别及运用场景"></a>computed和watch的区别及运用场景</h2><ol><li><code>computed</code>计算属性</li></ol><ul><li><p>运用场景</p><p>如果显示的结果可以根据现有的数据计算产生,供页面获取显示(别人改变来影响我)。</p></li><li><p>什么时候执行?</p><p>初始化显示执行一次, 然后当依赖项发生变化也会执行。</p></li><li><p>可以通过gette/setter实现数据的显示和监听。</p></li></ul><ol start="2"><li><code>watch</code>监听器,监听到值的变化就会执行回调,在回调中可以进行一些逻辑操作(我改变去影响别人)。</li></ol><h2 id="v-if和v-for为什么不建议一起使用"><a href="#v-if和v-for为什么不建议一起使用" class="headerlink" title="v-if和v-for为什么不建议一起使用"></a>v-if和v-for为什么不建议一起使用</h2><p><code>v-if</code>和<code>v-for</code>不要在同一个标签中使用,因为解析时先解析<code>v-for</code>再解析<code>v-if</code>。如果需要两个同时使用可以通过计算属性的方法。</p><h2 id="Vue2响应式原理"><a href="#Vue2响应式原理" class="headerlink" title="Vue2响应式原理"></a>Vue2响应式原理</h2><ul><li>什么是响应式原理?<br>在改变数据的时候,视图会随着数据的变化而变化。Vue中通过<code>Object.defineProperty()</code>方法里的getter和setter方法的<code>观察者模式</code>来实现。</li><li><code>第一步</code>: 组件初始化的时候,先给每个data的属性都注册getter和setter方法,也就是reactive化。然后再new一个自己的Watcher对象,此时watcher会立即调用组件的render函数去生成虚拟DOM。再调用render的时候,会需要用到data的属性值,此时会触发getter函数,将当前的Watcher函数注册到sub里。</li><li><code>第二步</code>: 当data属性发生改变之后,遍历sub里的所有watcher对象,通知它们去重新渲染组件。</li></ul><h2 id="Vuex页面刷新数据丢失问题"><a href="#Vuex页面刷新数据丢失问题" class="headerlink" title="Vuex页面刷新数据丢失问题"></a>Vuex页面刷新数据丢失问题</h2><ol><li>将数据存放到sessionStorage中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面刷新时,将Vuex中的数据存储到sessionStorage中</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    sessionStorage.setItem(<span class="string">&#x27;persistence&#x27;</span>, <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;vuex中state的值&#x27;</span>) || <span class="string">&#x27;&#123;&#125;&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断sessionStorage是否有persistence,如果有,通过mutation来改变state里的数据</span></span><br><span class="line"><span class="keyword">let</span> per = sessionStorage.getItem(<span class="string">&#x27;persistence&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(per &amp;&amp; per !== <span class="string">&#x27;&#123;&#125;&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;myMethods&#x27;</span>, <span class="built_in">JSON</span>.parse(per));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用<code>vuex-persist</code>插件,解决Vuex持久化存储,不需要手动存取storage。</li></ol><h2 id="Vue的性能优化"><a href="#Vue的性能优化" class="headerlink" title="Vue的性能优化"></a>Vue的性能优化</h2><ol><li>v-if和v-show区分使用场景</li><li>computed和watch区分使用场景</li><li>v-for遍历必须加key唯一标识且最好是id值,尽可能不用index作为key的值。避免和v-if同时使用</li><li>路由懒加载(<code>component: () =&gt; import(&#39;路由路径&#39;)</code>)</li><li>适当采用keep-alive缓存组件,使组件不会被机制销毁</li><li>关闭<code>sourceMap</code>文件生成</li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p><code>nextTick</code>中的回调是在下次DOM更新循环结束后执行的延迟回调。在修改数据之后立即使用该方法。获取更新后的DOM。</p><h2 id="scoped的原理"><a href="#scoped的原理" class="headerlink" title="scoped的原理"></a>scoped的原理</h2><p><code>scoped</code>属性会使样式只在当前组件生效。当前组件的标签会自动添加一个特定的属性(类似于html标签添加一个class属性)。样式的选择器也会添加对应的属性选择</p><h2 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h2><p><code>keep-alive</code>是Vue内置的组件,可以实现组件缓存,当组件切换时不会对当前组件卸载</p><ul><li>常用的两个属性<code>include</code>/<code>exclude</code>,允许组件有条件的进行缓存</li><li>两个生命周期activated/deactivated,用来得知当前组件是否处于激活状态</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中图片转file文件类型</title>
      <link href="2021/05/10/vue-zhong-tu-pian-zhuan-file-wen-jian-lei-xing/"/>
      <url>2021/05/10/vue-zhong-tu-pian-zhuan-file-wen-jian-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>先把<code>图片路径</code>转为<code>base64</code>格式</li><li>再把<code>base64</code>转为<code>File</code>文件</li></ul><h2 id="图片转base64格式"><a href="#图片转base64格式" class="headerlink" title="图片转base64格式"></a>图片转base64格式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将imgURL转为Base64格式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> imageToBase64 = <span class="function">(<span class="params">img</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  canvas.width = img.width;</span><br><span class="line">  canvas.height = img.height;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, img.width, img.height);</span><br><span class="line">  <span class="keyword">var</span> ext = img.src.substring(img.src.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">var</span> dataURL = canvas.toDataURL(<span class="string">&quot;image/jpeg&quot;</span> + ext);</span><br><span class="line">  <span class="keyword">return</span> dataURL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="base64转File文件"><a href="#base64转File文件" class="headerlink" title="base64转File文件"></a>base64转File文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  urlData: base64格式</span></span><br><span class="line"><span class="comment">  fileName: 图片名称(选填)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> base64ToFile = <span class="function">(<span class="params">urlData, fileName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = urlData.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> bytes = atob(arr[<span class="number">1</span>]); <span class="comment">// 解码base64</span></span><br><span class="line">  <span class="keyword">let</span> n = bytes.length</span><br><span class="line">  <span class="keyword">let</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">      ia[n] = bytes.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> File([ia], fileName, &#123; <span class="attr">type</span>: mime &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建image对象"><a href="#创建image对象" class="headerlink" title="创建image对象"></a>创建image对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先引入js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; imageToBase64, base64ToFile &#125; <span class="keyword">from</span> <span class="string">&quot;@/utils/xxx.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">image.crossOrigin = <span class="string">&quot;&quot;</span>;</span><br><span class="line">image.src = <span class="string">&quot;....&quot;</span>;</span><br><span class="line"><span class="comment">// 图片加载完成时执行,不然会拿不到图片的宽高,转base64会失败</span></span><br><span class="line">image.onload = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 图片转为base64</span></span><br><span class="line">  <span class="keyword">let</span> base64 = <span class="keyword">await</span> imageToBase64(image);</span><br><span class="line">  <span class="comment">// base64转为file格式</span></span><br><span class="line">  <span class="keyword">let</span> fileType = base64ToFile(base64, fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文和作用域</title>
      <link href="2021/05/06/zhi-xing-shang-xia-wen-he-zuo-yong-yu/"/>
      <url>2021/05/06/zhi-xing-shang-xia-wen-he-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><ol><li>JavaScript解释执行代码的时候,最先遇到的肯定是全局代码,所以初始化的时候首先就会向执行上下文栈压入一个<code>全局执行上下文</code>,用<code>globalContext</code>标识,并且只有当整个程序结束的时候,<code>执行上下文栈(ECStack)</code>才会被清空。在整个程序结束之前,<code>执行上下文栈(ECStack)</code>中永远都会有<code>globalContext</code>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol start="2"><li>当执行一个函数的时候,就会创建一个<code>执行上下文</code>,并且压入<code>执行上下文栈中</code>,当函数执行完毕后,会将函数执行上下文从栈中弹出。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fn1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先fn2()先执行,会将fn2压入执行上下文栈中</span></span><br><span class="line"><span class="comment">// fn2()执行后,内部调用了fn1(),将fn1压入执行上下文栈中</span></span><br><span class="line">ECStack.push(&lt;fn2&gt; functionContext);</span><br><span class="line">ECStack.push(&lt;fn1&gt; functionContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随后fn1执行完毕,将fn1从执行上下文栈中弹出</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"><span class="comment">// fn2执行完毕,将fn2从执行上下文栈中弹出</span></span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>执行上下文的三个重要属性:</li></ol><ul><li>变量对象(VO)</li><li>作用域链(Scope)</li><li>this</li></ul><h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域,存储了在上下文中定义的变量和函数声明。包括:<code>全局上下文的变量对象</code>和<code>函数上下文的变量对象</code>。</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><ol><li>在JavaScript中全局对象就是<code>Window</code>对象。全局对象是由<code>Object</code>构造函数实例化的一个对象。</li><li><strong>全局上下文中的变量对象就是全局对象</strong></li></ol><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><ol><li>函数上下文中的<code>变量对象</code>在函数被调用后创建,通过函数的<code>arguments</code>属性初始化。<code>arguments</code>属性值是<code>Arguments对象</code>。</li><li>执行过程</li></ol><ul><li><p>进入执行上下文</p><ol><li>进入执行上下文时,代码还没有执行</li><li>变量对象会包括:</li></ol><ul><li>函数的所以形参(如果为函数上下文)<ol><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>如果没有实参,属性值为<code>undefined</code></li></ol></li><li>函数声明<ol><li>由<code>名称和对应值(函数对象)</code>组成一个变量对象的属性</li><li>如果变量对象已经存在相同名称的属性,就会<code>完全替换</code>这个属性</li></ol></li><li>变量声明<ol><li>由<code>名称和对应值(undefined)</code>组成一个变量对象的属性</li><li>如果变量名称跟已经声明的形式参数或函数相同,变量对象<code>不会覆盖</code>已经存在的这些属性</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>进入执行上下文后,创建变量对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数上下文的变量对象假设为AO</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    length: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">undefined</span>,</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码执行</p><ol><li>在执行代码的时候,会顺序执行代码,根据代码修改变量对象的值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    length: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">3</span>,</span><br><span class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  d: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="3"><li>总结变量对象</li></ol><ul><li>全局上下文的变量对象初始化是<code>全局对象</code></li><li>函数上下文的变量对象初始化只包括<code>Arguments对象</code></li><li>在进入执行上下文时会给变量对象添加<code>形参</code>、<code>函数声明</code>、<code>变量声明</code>等初始化属性值</li><li>代码执行阶段,会再次给变量对象的属性赋值</li></ul><p>如下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量AO</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>)&#125;,</span><br><span class="line">  foo: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为变量声明的属性名称和函数声明属性名称相同,所以不会覆盖函数声明的属性。</span></span><br><span class="line"><span class="comment">// 最终打印结果为函数,而不是undefined</span></span><br><span class="line">ƒ <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>查找变量时,会先从当前上下文的变量对象中查找,如果没有找到,就会从父级执行上下文的变量对象中查找,直到找到全局变量对象,<strong>这样由多个执行上下文的变量对象构成的链表就叫作用域链</strong>。</p><h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p>不同于执行上下文,函数上下文是在函数调用的时候创建的(动态),而函数的作用域则是在函数定义的时候就创建了(静态)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义时,各自的<code>[[scope]]</code>为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo的作用域链</span></span><br><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br><span class="line"><span class="comment">// doo的作用域链</span></span><br><span class="line">doo.[[scope]] = [</span><br><span class="line">  fooContext.VO</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>当函数激活时,进入函数上下文,创建变量对象后,就会将活动对象添加到作用域前端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[scope]]);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope2 = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程:</p><ol><li>checkscope函数被创建,保存作用域链到内部属性<code>[[scope]]</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>checkscop函数被执行,创建checkscope函数执行上下文,将checkscop函数执行上下文压入栈中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  checkContext,</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="3"><li>函数并不立即执行,第一步: 复制函数<code>[[scope]]</code>属性创建作用域链</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkContext = &#123;</span><br><span class="line">  Scope: checkscope.[[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>第二步,初始化函数变量对象,加入形参、变量声明、函数声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope2: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: checkscope.[[scope]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>第三步: 将活动对象压入checkscope作用域最前端</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope2: <span class="literal">undefined</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO].concat([[scope]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>开始执行函数,修改函数变量对象的属性值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope2: <span class="string">&quot;local&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO].concat([[scope]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>查找到scope2的值,返回scope2的值后函数执行完毕,将函数上下文从执行上下文栈中弹出</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果为 &#x27;local scope&#x27;</span></span><br></pre></td></tr></table></figure><p>执行过程:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建全局执行上下文,压入栈中</span></span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 2. 初始化全局执行上下文</span></span><br><span class="line">globalContext = &#123;</span><br><span class="line">  VO: &#123;</span><br><span class="line">    scope: <span class="built_in">global</span> scope,</span><br><span class="line">    checkscope: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [globalContext.VO],</span><br><span class="line">  <span class="built_in">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 初始化同时 checkscope函数被创建,创建作用域链保存到内部属性[[scope]]中</span></span><br><span class="line">checkscope.[[scope]] = [</span><br><span class="line">  checkscopeContext.AO</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 4. 进入checkscope函数,创建checkscope函数执行上下文压入栈中</span></span><br><span class="line">ECStack = [</span><br><span class="line">  checkscopeContext,</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 5. checkscope函数执行上下文初始化</span></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope: <span class="literal">undefined</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, globalContext.VO],</span><br><span class="line">  <span class="built_in">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. 初始化的同时,函数f被创建,创建作用域链到内部属性[[scope]]中</span></span><br><span class="line">f.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 7. 执行函数,修改函数变量对象的属性值</span></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scope: <span class="string">&quot;local scope&quot;</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, globalContext.VO],</span><br><span class="line">  <span class="built_in">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8. 进入f函数,创建f函数执行上下文,压栈</span></span><br><span class="line">ECStack = &#123;</span><br><span class="line">  fContext,</span><br><span class="line">  checkscopeContext,</span><br><span class="line">  globalContext</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9 . f函数执行上下文初始化</span></span><br><span class="line">fContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [VO, checkscopeContext.VO, globalContext.AO],</span><br><span class="line">  <span class="built_in">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10. f函数执行,沿着作用域链查找scope值并返回</span></span><br><span class="line"><span class="comment">// 11. f函数执行完毕后,f函数上下文从栈中弹出</span></span><br><span class="line">ECStack = [</span><br><span class="line">  checkscopeContext,</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 12. checkscop函数执行完毕后,该函数上下文栈中弹出</span></span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序笔记</title>
      <link href="2021/04/14/wei-xin-xiao-cheng-xu/"/>
      <url>2021/04/14/wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<!-- ## HTTP和HTTPS1. http和https的基本概念  - http: 是一个客户端和服务器端请求和应答的标准(TCP),用于从WWW服务器传输超文本到本地浏览器的超文本传输协议  - https: 以安全未目标的http通道,在HTTP下加入SSL层进行加密;作用是:建立一个信息安全通道,确保数据的传输,网络的真实性2. 两者优缺点  - HTTPS具有SSL加密传输协议;确保传输过程中被窃取,改变,所以HTTPS更安全  - HTTP默认端口为80;HTTPS默认端口为443  - HTTP连接简单(三次握手),HTTPS会产生7次握手,较为费时,造成白屏时间延长50%  - HTTPS缓存不如HTTP高效,会增加数据开销## TCP和UDP的区别1. TCP是面向连接的,而UDP是面向无连接的2. TCP仅支持单播传输,UDP提供了单播、多播、广播的功能3. TCP的三次握手保证了连接的可靠性;UDP是无连接的、不可靠的,数据可能会丢失。4. UDP的头部开销比TCP更小，数据传输速率更高，实时性较好。## 从输入URL到页面加载的过程1. 浏览器中输入URL2. 查找缓存: 浏览器先查看浏览器缓存## TCP三次握手1. 第一次握手：建立连接，客户端发送包到服务器等待服务器确认2. 第二次握手：服务器收到包并确认## 304过程1. 浏览器请求资源时首先命中资源的Expires和Cache-Control,Expires受限于本地时间浏览器请求资源先命中Expires和cache-control，Expires受本地时间的影响，所以可以通过cache-control：max-age指定最大生命周期。状态返回200但不会请求数据强缓存失效，进入协商缓存阶段。先验证ETag是否改变，Etag确保每个资源唯一，服务器根据if-none-match判断是否命中缓存。 --><h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><ol><li>之前的<code>getUserInfo</code>无法使用,现在需要使用<code>getUserProfile</code>获取用户信息</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wx.getUserProfile(&#123;</span><br><span class="line">  desc: <span class="string">&#x27;用于完善会员资料&#x27;</span>,</span><br><span class="line">  success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取成功&quot;</span>, res);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      userInfo: res.userInfo</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  fail: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取失败&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>多行文本溢出隐藏</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 多行 */</span></span><br><span class="line">  <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line">  <span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line">  <span class="comment">/* 设置对齐模式 */</span></span><br><span class="line">  <span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line">  <span class="comment">/* 设置多行的行数 */</span></span><br><span class="line">  <span class="selector-tag">-webkit-line-clamp</span>: 2 ;</span><br></pre></td></tr></table></figure><ol start="3"><li>scroll-view组件</li></ol><ul><li>如果使用微信小程序<code>scroll-view</code>组件,需要设置<code>enable-flex</code>,不然会导致<code>display: flex;</code>失效。</li><li>如果设置了<code>enable-flex</code>,需要指定高度。</li><li>如果点击使当前tab项排在第一位,需要使用<code>scroll-into-view</code>,它的值不能以数字开头并且<br>值应该和某子元素id一一对应,如下:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-into-view</span>=<span class="string">&quot;&#123;&#123;&#x27;xx&#x27; + id&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123;&#x27;xx&#x27; + id&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>下拉加载更多通过<code>bindrefresherrefresh</code>绑定回调事件,并且需要配合<code>refresher-enabled</code>开启自定义下拉刷新,通过<code>refresher-triggered</code>的true或false控制小圆点的显示隐藏。</li><li>上拉加载更多通过<code>bindscrolltolower</code>绑定回调事件。</li><li>如果是<code>页面刷新</code>,在需要刷新的页面的json中,通过<code>enablePullDownRefresh: true</code>开启,监听用户下拉动作的处理函数为<code>onPullDownRefresh</code>,页面上拉触底事件的处理函数为<code>onReachBottom</code>。</li></ul><ol start="4"><li>前后端交互</li></ol><ul><li>语法: wx.request()</li><li>注意点: <ol><li>协议必须是https协议</li><li>一个接口最多配置20个域名</li><li>并发限制上限是10个</li></ol></li></ul><ol start="5"><li>wx:for注意点</li></ol><ul><li><strong>wx:for语法: wx:for=”“</strong></li><li>与vue不同,vue遍历后<code>:key</code>需要item.xxx来拿到想要的唯一值。</li><li>微信小程序遍历后只需要wx:key=”xxx”直接写,不需要通过item再去取唯一值。</li><li>默认数组的当前项的下标变量名默认为<code> index</code>，数组当前项的变量名默认为<code> item</code>。如果需要嵌套循环那么item就不合理了。需要使用<code>wx:for-item</code>可以指定数组当前元素的变量名,使用<code>wx:for-index</code>可以指定数组当前下标的变量名</li></ul><ol start="6"><li>如果请求参数是一个范围值</li></ol><ul><li>前++和后++的区别<ol><li>如果先看到的是运算符就先运算在赋值</li><li>如果先看到的是值那么就先赋值在运算</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(index &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> request(<span class="string">&quot;...&quot;</span>, &#123;<span class="attr">xxx</span>: index++&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不用等待五次请求发送完,用户体验好,但是会多请求一次</span></span><br><span class="line">  <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    rankList: res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果this.setData放在while循环外面,会等待五次请求发送完,导致白屏的情况,用户体验不好</li></ul><ol start="7"><li>封装组件</li></ol><ul><li>在要引入组件的父组件的json文件引入公共组件的路径<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;usingComponents&quot;: &#123;</span><br><span class="line">  &quot;NavHeader&quot;: &quot;/component/NavHeader/NavHeader&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>内网穿透</li></ol><ul><li>使用utools下载内网穿透插件,配置自己的外网域名并连接<code>https://bowen593w1998.cn.utools.club</code></li><li>在自己封装的请求功能函数中配置该地址<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mobileHost: <span class="string">&quot;https://bowen593w1998.cn.utools.club&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过wx.request()发送请求,将该地址拼接<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;./config&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (url, data=&#123;&#125;, methods=<span class="string">&quot;GET&quot;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: config.mobileHost + url,</span><br><span class="line">      data,</span><br><span class="line">      methods</span><br><span class="line">      success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res.data);</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样可以解决真机调试时获取不到接口数据问题。</li></ul><ol start="9"><li>数据缓存</li></ol><ul><li><code>wx.setStorage(&#123;&#125;)</code>: 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 <code>1MB</code>，所有数据存储上限为 <code>10MB</code>。</li><li><code>wx.setStorageSync(key, data)</code>: wx.setStorage的同步版本。</li><li><code>wx.getStorage(&#123;&#125;)</code>: 从本地缓存中异步读取指定key的内容。</li><li><code>wx.getStorageSync(key, data)</code>: wx.getStorage的同步版本。</li><li>注意点: <ol><li>建议存储JSON格式的数据</li><li>注意数据存储大小,因为数据存储上限为10MB</li><li>同H5中的localStorage一样,永久存储</li></ol></li><li><code>wx.removeStorageSync(&#39;key&#39;)</code>: 删除本地缓存中指定key的内容。</li></ul><ol start="10"><li>wx.navigateTo()</li></ol><ul><li><code>wx.navigateTo()</code>: 保留当前页面，跳转到应用内的某个页面。<code>但是不能跳到 tabbar 页面</code>。</li><li>如果需要跳转到tabbar页面,可以使用<code>wx.switchTab()</code>进行跳转到tabbar页面,并且会关闭其他所有非tabbar页面。</li><li>但是登录的时候有一个问题,因为<code>wx.navigateTo()</code>跳转后,当前页面不被销毁,登录成功后,<code>wx.switchTab()</code>不会触发<code>onLoad</code>生命周期函数,拿到的数据不能及时保存到data里,所以需要使用<code>wx.reLaunch()</code>(关闭所有页面,打开到应用内的某个页面)进行路由跳转。</li><li>或者放在<code>onShow</code>生命周期函数中,但是性能不好。</li></ul><ol start="11"><li>多个视频同时播放问题</li></ol><ul><li>poster</li><li>第一次进入用image代替video</li><li>通过判断唯一标识显示或隐藏</li></ul><ol start="12"><li>路由跳转传参</li></ol><ul><li><code>query</code>参数,然后通过onLoad生命周期函数的<code>options</code>接收传递的参数,默认为<code>&#123;&#125;</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/pages/xxx/xxx?key=&#x27;</span> + value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>注意: 原生小程序中路由传参对参数的长度有限制,如果参数长度过长会自动截取掉导致显示不完整。</li></ul><ol start="13"><li>wx.setNavigationBarTitle()</li></ol><ul><li>用于动态设置当前页面的标题。在小程序插件中使用时,只能在当前插件的页面中调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.setNavigationBarTitle(&#123;</span><br><span class="line">  title: <span class="string">&#x27;当前页面&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ol start="14"><li>wx.getBackgroundAudioManager()</li></ol><ul><li>获取<code>全局唯一</code>的背景音频管理器。小程序切入后台,如果音频处于播放状态,可以继续播放。但是后台状态不能通过调用API操纵音频的播放状态。若需要在小程序切后台后继续播放音频,需要在app.json中配置<code>&quot;requiredBackgroundModes&quot;: [&quot;audio&quot;, &quot;location&quot;]</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过wx.getBackgroundAudioManager()获取实例</span></span><br><span class="line"><span class="keyword">let</span> backgroundAudioManager = wx.getBackgroundAudioManager();</span><br><span class="line"><span class="comment">// 必须设置的属性</span></span><br><span class="line">backgroundAudioManager.src = musicUrl; <span class="comment">// 音频地址</span></span><br><span class="line">backgroundAudioManager.title = musicName; <span class="comment">// 音频的名字</span></span><br></pre></td></tr></table></figure></li><li>播放音乐: <code>backgroundAudioManager.play()</code></li><li>暂停音乐: <code>backgroundAudioManager.pause()</code></li><li>停止音乐: <code>backgroundAudioManager.stop()</code></li><li>监听背景音频播放/暂停事件: <code>backgroundAudioManager.onPlay(callback)</code>/<code>backgroundAudioManager.onPause(callback)</code>解决页面显示是否播放状态和真实音乐播放状态不一致的问题。</li><li>监听背景音频停止事件: <code>backgroundAudioManager.onStop(callback)</code>。</li><li>监听背景音频播放进度更新事件，只有小程序在前台时会回调: <code>backgroundAudioManager.onTimeUpdate(callback)</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backgroundAudioManager.onTimeUpdate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前播放时间</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.backgrounAudioManager.currentTime);</span><br><span class="line">  <span class="comment">// 获取播放总时间</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.backgrounAudioManager.duration);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>监听背景音频播放自然结束事件: <code>backgroundAudioManager.onEnded(callback)</code>。</li></ul><ol start="15"><li>globalData</li></ol><ul><li>整个小程序只有一个App实例,是全部页面共享的。可以通过<code>getApp方法</code>获取到全局唯一的App实例,获取App上的数据或者调用App上注册的函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">globalData: &#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xxx.js</span></span><br><span class="line"><span class="keyword">const</span> appInstance = getApp();</span><br><span class="line">appInstance.globalData.xxx;</span><br></pre></td></tr></table></figure></li></ul><ol start="16"><li>使用第三方插件</li></ol><ul><li>第一步: npm init -y</li><li>第二步: 详情 –&gt; 本地设置 –&gt; 使用npm模块</li><li>第三步: 下载插件并使用</li><li>第四步: 工具 –&gt; 构建npm生成<code>miniprogram_npm</code>,不然会导致路径出错</li></ul><ol start="17"><li>动态获取元素宽高等信息</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> query = wx.createSelectorQuery();</span><br><span class="line">query.select(<span class="string">&#x27;类名&#x27;</span>).boundingClientRect();</span><br><span class="line">query.exec(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>res打印信息如下:</li></ul><p><a href="https://imgtu.com/i/guTrZj"><img src="https://z3.ax1x.com/2021/05/05/guTrZj.png" alt="guTrZj.png"></a></p><ol start="18"><li>显示和隐藏</li></ol><ul><li><code>wx:if wx:elif wx:else</code>等同于Vue中的<code>v-if v-else-if v-else</code></li><li><code>hidden</code>等同于Vue中的<code>v-show</code></li><li>如果需要反复切换使用<code>hidden</code>,否则可以使用<code>wx:if</code></li></ul><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ol><li>什么是事件委托</li></ol><ul><li>将子元素的事件委托(绑定)给父元素</li></ul><ol start="2"><li>事件委托的好处</li></ol><ul><li>减少绑定次数</li><li>后期新添加的元素也可以享受到之前委托的事件</li></ul><ol start="3"><li>事件委托的原理</li></ol><ul><li>通过事件冒泡</li></ul><ol start="4"><li>触发事件的是谁</li></ol><ul><li>子元素</li></ul><ol start="5"><li>如何找到触发事件的对象</li></ol><ul><li>event.target</li><li>currentTarget和target的区别<ol><li>currentTarget要求绑定事件的元素<code>一定</code>是触发事件的元素</li><li>target<code>不一定</code>是触发事件的元素</li></ol></li></ul><ol start="6"><li>小程序向event对象传参的两种方式:</li></ol><ul><li>通过<code>id</code>标识当前组件,<strong>唯一的</strong></li><li>通过<code>id</code>向event传参时会自动将Number转为String类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;target&#x27;</span>: &#123;</span><br><span class="line">  id: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&#x27;currentTarget&#x27;</span>: &#123;</span><br><span class="line">  id: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过<code>data-key=&#39;value&#39;</code>,<strong>需要传入多个数据</strong></li><li>通过<code>data-</code>的形式传参不会自动转换类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;target&#x27;</span>: &#123;</span><br><span class="line">  dataset: &#123;</span><br><span class="line">    key: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&#x27;currentTarget&#x27;</span>: &#123;</span><br><span class="line">  dataset: &#123;</span><br><span class="line">    key: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义事件相关"><a href="#定义事件相关" class="headerlink" title="定义事件相关"></a>定义事件相关</h2></li></ul><ol><li>分类</li></ol><ul><li>标准DOM事件</li><li>自定义事件</li></ul><ol start="2"><li>标准DOM事件</li></ol><ul><li>click、input、change等。</li><li>时间名固定,事件由浏览器触发</li></ul><ol start="3"><li>自定义事件</li></ol><ul><li>绑定事件<ol><li>事件名</li><li>事件的回调</li><li>订阅方: <code>PubSub.subscribe(&#39;事件名&#39;, (msg, data) =&gt; &#123;&#125;)</code></li><li>订阅方是接收数据的一方</li></ol></li><li>触发事件<ol><li>事件名</li><li>提供事件参数对象,等同于原生事件的event对象</li><li>发布方: <code>PubSub.publish(&#39;事件名&#39;, data)</code></li><li>发布方是提供数据的一方</li></ol></li></ul><ol start="4"><li>注意:</li></ol><ul><li>发布和订阅的事件名必须一致。</li><li>因为订阅一次就会往对应的数组中存入一个回调函数,最后会将数组里的回调拿出来执行多次,所以每次订阅之后应该取消一次订阅<code>PubSub.unsubscribe(&#39;事件名&#39;)</code>。</li></ul><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><h3 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h3><pre><code>- 读取指定文件中的内容<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：读取文件的存放路径</span></span><br><span class="line"><span class="comment">// 参数2：读取文件时采用的编码格式，一般默认指定utf8</span></span><br><span class="line"><span class="comment">// 参数3：回调函数，文件读取完成后的回调，参数分别是err(失败),dataStr(成功)</span></span><br><span class="line">fs.readFile(path[, options], callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.text&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, dataStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件失败&#x27;</span> + err.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件成功&#x27;</span> + dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>- 向指定文件中写入内容<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：必选参数，表示文件的存放地址</span></span><br><span class="line"><span class="comment">// 参数2：必选参数，表示要写入的内容</span></span><br><span class="line"><span class="comment">// 参数3：可选参数，以什么格式写入文件内容，一般默认指定utf8</span></span><br><span class="line"><span class="comment">// 参数4：必选参数，文件写入完成后的回调</span></span><br><span class="line">fs.writeFile(path, data[, options], callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">fs.writeFile(<span class="string">&#x27;./1.text&#x27;</span>, <span class="string">&#x27;hellow Node.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果写入成功，则err的值为null</span></span><br><span class="line">  <span class="comment">// 如果写入失败，则err的值为一个失败对象</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;写入失败&#x27;</span>，+ err.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>- 路径动态拼接: `__dirname`表示当前文件所处的目录</code></pre><h3 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h3><ul><li>**path.join()**方法，用于将<code>多个路径片段拼接成一个完整的路径字符串</code><ol><li>注意：**../会抵消前面的路径**</li></ol></li><li>**path.basename(path[, ext])**方法,用于<code>从路径字符串中，将文件名解析出来</code><ol><li>path<string>: 必选参数，表示一个路径的字符串</li><li>ext<string>: 可选参数，表示文件扩展名</li><li>返回路径中最后一部分，例如index.html</li></ol></li><li>**path.extname()**方法，用于获取路径中的文件扩展名<ol><li>path<string>: 必选参数，表示一个路径的字符串</li><li>返回得到的扩展名字符串，例如.html</li></ol></li></ul><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><ul><li>创建基本的web服务器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http  = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建web服务器实例</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定request事件，监听客户端请求</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听</span></span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;server running http://127.0.0.1:8080&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>req请求对象<ol><li>如果想在事件处理函数中，<code>访问客户端相关的数据和属性</code>，可以使用如下方式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取客户端请求的URL地址</span></span><br><span class="line">  <span class="keyword">const</span> url = req.url;</span><br><span class="line">  <span class="comment">// 获取客户端请求的method类型</span></span><br><span class="line">  <span class="keyword">const</span> method = req.method;</span><br><span class="line">  <span class="comment">// 为了防止中文显示乱码问题</span></span><br><span class="line">  <span class="comment">// 需要调用res.setHeader()方法设置响应头Content-Type 的值为text/html; charset=utf-8</span></span><br><span class="line">  res.setHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>)</span><br><span class="line">  <span class="comment">// 调用res.end()方法，向客户端响应一些内容</span></span><br><span class="line">  res.end(<span class="string">`url: <span class="subst">$&#123;url&#125;</span>, method: <span class="subst">$&#123;method&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><ol><li><p>是一种受限的线性表，<code>后进先出</code></p><ul><li>其限制是仅允许在<code>表的一端</code>进行插入和删除运算。这一端被称为<code>栈顶</code>，相对的，另一端成为<code>栈底</code></li><li>向一个栈插入新元素又称为<code>进栈</code>、<code>入栈</code>或<code>压栈</code>。</li><li>从一个栈删除元素又称为<code>出栈</code>或<code>退栈</code>。是把栈顶元素删除掉，使其相邻的元素成为栈顶元素</li></ul></li><li><p>十进制转二进制</p><ul><li>要把十进制转成二进制，可以将该十进制数字和2整除（满二进一），直到结果为0<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec2bin</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = [];</span><br><span class="line">  <span class="keyword">while</span>(decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    items.push(decNumber % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    decNumber = <span class="built_in">Math</span>.floor(decNumber / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span>(items.length) &#123;</span><br><span class="line">    binaryString += items.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3></li></ul></li><li><p>也是一种受限的线性结构，<code>先进先出(FIFO)</code></p><ul><li>受限之处在于它只允许在表的<code>前端</code>进行删除操作</li><li>在表的<code>后端</code>进行插入操作</li></ul></li><li><p>击鼓传花</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>() </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">enqueue</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.push(item)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">dequeue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items.shift();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">front</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passGame</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nameList.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    items.push(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//items = nameList.slice(0);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(items.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      items.push(items.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为最后只会有一个人存在</span></span><br><span class="line">  <span class="keyword">return</span> nameList.indexOf(items[<span class="number">0</span>]);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3></li><li><p>内存空间不是必须连续的，可以充分利用计算机的内存，实现灵活的内存动态管理</p></li><li><p>链表不必在创建时确定大小，并且大小可以无限的延伸</p></li><li><p>链表在插入和删除数据时，时间复杂度可以达到O(1)，相对于数组来说更高效</p></li><li><p>封装链表类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 内部类</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LinkList.prototype.append = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="comment">// 判断是否是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span>(current.next) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">      &#125;</span><br><span class="line">      current.next = newNode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的一些方法...</title>
      <link href="2021/04/12/es6-shu-zu-xin-yu-fa/"/>
      <url>2021/04/12/es6-shu-zu-xin-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组: </p><ul><li>类似数组的对象</li><li>可便利(iterable)的对象(包括ES6新增的数据结构Set和Map)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">&quot;0&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  <span class="string">&quot;1&quot;</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">  <span class="string">&quot;0&quot;</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5写法</span></span><br><span class="line"><span class="comment">// [].slice === Array.prototype.slice都是去原型上找slice()方法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>实际应用中,常见的类似数组的对象是<code>DOM操作返回的NodeList集合</code>,以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p><p>只要是部署了<code>Iterator</code>接口的数据结构,<code>Array.from</code>都能转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串具有iterator接口</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,]</span></span><br></pre></td></tr></table></figure><p>扩展运算符(<code>...</code>)也可以将某些数据结构转为数组。如果一个对象没有部署遍历器接口(<code>Symbol.iterator</code>),就无法转换。Array.from方法还支持转换类似数组的对象(本质就是必须拥有<code>length</code>属性)。但是扩展运算符就无法转换。</p><p><code>Array.from</code>还接收第二个参数,作用类似于数组的<code>map</code>方法,用于对每个元素进行处理,将处理后的值放入返回的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p><code>Array.of()</code>方法用于将一组值,转换为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><p>该方法弥补了数组构造函数<code>Array()</code>的不足。因为参数个数的不同导致<code>Array()</code>的行为有差异。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">2</span>) <span class="comment">// [ , ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure><p>只有当参数个数不少于2时,Array()才会返回由参数组成的新数组。参数只有一个正整数时,实际上指定数组的长度。</p><p><code>Array.of()</code>总是返回参数值组成的数组。如果没有参数,就返回一个空数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Arrayof</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 该方法等同于Array.of()</span></span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>如果想用不同的分隔符分隔数组。可以使用<code>join()</code>方法。该方法接收一个参数,即字符串分隔符,返回包含所有项的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line">arr.join(<span class="string">&quot;||&quot;</span>); <span class="comment">// green||red||blue</span></span><br></pre></td></tr></table></figure><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ol><li><code>concat()</code>方法可以在现有数组全部元素基础上创建一个<code>新数组</code>。首先会创建一个当前数组的副本。然后把它的参数添加到副本末尾,最后返回新数组。<strong>如果传入一个或多个数组,concat()会把这些<code>数组的每一项</code>都添加到结果数组中。如果参数不是数组,直接把他们添加到结果数组末尾</strong>(只能扁平化一层)。</li><li><code>slice()</code>方法用于截取一个包含原数组中一个或多个元素的新数组(<strong>不会影响原数组</strong>)。接收一个或两个参数: 返回元素的<code>开始索引</code>和<code>结束索引</code>。如果只传一个参数,表示从开始索引位置截取到数组最后。如果有两个参数,表示从开始索引位置截取到数组结束索引位置(但不包含结束索引对应的元素)。</li><li><code>splice()</code>方法主要目的是在数组中间插入元素(<strong>会影响原数组</strong>),但有三种不同的方式使用该方法:</li></ol><ul><li><code>删除</code>: 需要给<code>splice()</code>传递两个参数: 要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素。</li><li><code>插入</code>: 需要给splice()传递三个参数: 开始位置、0(要删除的元素数量)、要插入的元素,可以在数组指定位置插入元素。第三个参数之后可以添加任意多个要插入的元素。<code>返回空数组</code>。</li><li><code>替换</code>: 需要给splice()传递三个参数: 开始位置、要删除的元素数量、要插入的任意多个元素。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [4, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="数组实例的indexOf-和includes"><a href="#数组实例的indexOf-和includes" class="headerlink" title="数组实例的indexOf()和includes()"></a>数组实例的indexOf()和includes()</h2></li></ul><p>都接收两个参数: 要查找的元素和一个可选的起始搜索位置。</p><ol><li><code>indexOf()</code>返回要查找元素的在数组中的位置(索引),没找到则返回-1。</li><li><code>includes()</code>返回布尔值,表示是否至少找到一个与指定元素匹配的项。</li><li>在比较第一个参数和数组的每一项时,会使用<code>全等(===)</code>进行比较。</li></ol><h2 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h2><ol><li>find()</li></ol><p><code>find</code>方法,用于找出第一个符合条件的数组成员。它的参数是一个回调函数,所有数组成员依次执行该回调函数,直到找到第一个返回<code>true</code>的成员,并返回该成员。如果没有符合条件的成员,则返回<code>undefined</code>。</p><p><code>find</code>方法的回调函数接收三个参数,依次为当前的值、当前的位置和原数组。</p><ol start="2"><li>findIndex()</li></ol><p><code>findIndex</code>方法与<code>find</code>方法类似,返回第一个符合条件数组成员的位置(索引),如果没找到符合条件的成员,则返回<code>-1</code>。</p><p>这两个方法都接收第二个参数,用来绑定回调函数的<code>this</code>对象。</p><p>这两个方法都可以发现<code>NaN</code>,弥补了数组的<code>indexOf</code>方法的不足。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>代码中,<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员,但是<code>findIndex</code>方法可以通过<code>Object.is</code>方法做到。</p><p><code>Object.is(value1, value2)</code>: 判断两个值是否为同一个值。</p><h2 id="数组实例的entries-keys-和values"><a href="#数组实例的entries-keys-和values" class="headerlink" title="数组实例的entries(),keys()和values()"></a>数组实例的entries(),keys()和values()</h2><p>三个方法用于遍历数组。它们都返回一个遍历器对象,可以用<code>for...of</code>循环进行遍历。<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历、<code>entries()</code>是对键值对的遍历。</p><h2 id="数组实例的flat"><a href="#数组实例的flat" class="headerlink" title="数组实例的flat()"></a>数组实例的flat()</h2><p>数组的成员有时候还是数组,<code>Array.prototype.flat()</code>用于将嵌套的数组’拉平’,变成一维数组。该方法<strong>返回一个新数组</strong>,对原数据没有影响。</p><p><code>flat()</code>默认只会’拉平’一层,如果想要扁平化多层嵌套数组,可以将flat()方法的参数写成一个整数,表示想要扁平化的层数,默认为1。</p><p>如果不管嵌套多少层都要转为一维数组,可以用<code>infinity</code>关键字作为参数。</p><h3 id="Array-prototype-sort-的排序稳定性"><a href="#Array-prototype-sort-的排序稳定性" class="headerlink" title="Array.prototype.sort()的排序稳定性"></a>Array.prototype.sort()的排序稳定性</h3><p>默认情况下,<code>sort()</code>会按照升序重新排列数组元素,即最小的值在前面,最大的值在后面。<code>sort()</code>会在每项上调用String()转型函数,然后比较字符串来决定顺序。即使数组的元素都是数值,也会先把数值转换成字符串再比较、排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>，<span class="number">1</span>，<span class="number">5</span>，<span class="number">10</span>，<span class="number">15</span>];</span><br><span class="line">arr.sort() <span class="comment">// [0, 1, 10, 15, 5] 因为字符串&#x27;10&#x27;在&#x27;5&#x27;前面</span></span><br></pre></td></tr></table></figure><p>所有<code>sort()</code>函数可以接收一个比较函数,用于判断哪个值排在前面。</p><p>比较函数接收两个参数,如果第一个参数应该排在第二个参数前面,就返回负值,否则返回正值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从大到小 把return -1 和 1 交换</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set和Map</title>
      <link href="2021/03/22/set-he-map/"/>
      <url>2021/03/22/set-he-map/</url>
      
        <content type="html"><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6提供新的数据结构Set。它类似于数组,但是<strong>成员的值都是唯一的,没有重复的值</strong>。</p><p><code>Set</code>本身是一个构造函数,用来生成Set数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 2, 3, 5, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过<code>add()</code>方法向Set结构加入成员,结果表明<strong>Set结构不会添加重复的值</strong>。</p><p><code>Set函数</code>可以接收一个数组(或者具有iterable接口的其他数据结构)作为参数,用来初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log([...set]); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set.size) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>Set可以用于去除数组重复成员的方法,也可以用于去除字符串里的重复字符。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br><span class="line"><span class="comment">// 去除字符串重复字符</span></span><br><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&quot;ababbc&quot;</span>).join(<span class="string">&quot;&quot;</span>)]; <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>向Set加入值的时候,不会发生类型转换,所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set内部判断两个值是否不同,类似于全等运算符(<code>===</code>),主要的区别是向Set加入值时认为<code>NaN</code>等于自身,而全等运算符认为<code>NaN</code>不等于自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">NaN</span>;</span><br><span class="line">set.add(a).add(b);</span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set(1) &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure><p>代码向Set添加了两次<code>NaN</code>,但是只会加入一个,这表明,在Set内部两个<code>NaN</code>是相等的。另外,<strong>两个对象总不相等(因为引用地址不同)。</strong></p><h3 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h3><ol><li>Set结构的实例有以下属性。</li></ol><ul><li><code>Set.prototype.constructor</code>: 构造函数,默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>: 返回Set实例的成员个数。</li></ul><ol start="2"><li>Set实例的方法分两大类: <code>操作方法</code>(用于操作数据)和<code>遍历方法</code>(用于遍历成员)</li></ol><ul><li><code>Set.prototype.add(value)</code>: 添加某个值,返回Set结构本身。(<strong>可串联多个add(),只能有一个参数,第二个及以后参数会被自动忽略。</strong>)</li><li><code>Set.prototype.delete(value)</code>: 删除某个值,返回布尔值,表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>: 查询该值是否为<code>Set</code>的成员(值)。返回一个布尔值。</li><li><code>Set.prototype.clear()</code>: 清除所有成员,无返回值。</li></ul><p><code>Object</code>结构和<code>Set</code>结构的在判断是否包括在一个键上写法不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象写法</span></span><br><span class="line"><span class="keyword">const</span> properties = &#123;</span><br><span class="line">  width: <span class="number">1</span>,</span><br><span class="line">  height: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span>(properties[someName]) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set写法</span></span><br><span class="line"><span class="keyword">const</span> properties = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">properties.add(<span class="string">&quot;width&quot;</span>).add(<span class="string">&quot;height&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(properties.has(someName)) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Array.from()</code>方法可以将Set结构转为数组,这就提供了另一种数组去重的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><ol><li>Set结构的实例有四个遍历方法,可以用于遍历成员。</li></ol><ul><li><code>Set.prototype.keys()</code>: 返回<code>键名</code>的遍历器。</li><li><code>Set.prototype.values()</code>: 返回<code>键值</code>的遍历器。</li><li><code>Set.prototype.entries()</code>: 返回<code>键值对</code>的遍历器。</li><li><code>Set.prototype.forEach()</code>: 使用回调函数遍历每个成员。</li></ul><p><strong><code>Set</code>的遍历顺序就是插入顺序。</strong></p><ol start="2"><li><code>keys()</code>、<code>values()</code>、<code>entries()</code></li></ol><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象。由于Set没有键名,只有键值,所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// red  green  blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// red  green  blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// [&quot;red&quot;, &quot;red&quot;]  [&quot;green&quot;, &quot;green&quot;]  [&quot;blue&quot;, &quot;blue&quot;] </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,<code>entries()方法</code>返回的遍历器,同时包括键名和键值,所以每次输出一个数组,它的两个成员完全相等。</p><p>Set结构的实例默认可遍历,它的默认遍历器生成函数就它的<code>values</code>方法。这就意味着,可以省略<code>values</code>方法,直接用<code>for...of</code>循环遍历Set。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>forEach()</code></li></ol><ul><li>Set结构的实例与数组一样,也拥有<code>forEach</code>方法,用于对每个成员执行某种操作,没有返回值。</li><li>forEach方法的参数就是一个处理函数,该函数的参数与数组的<code>forEach</code>一致,依次为<code>键值</code>、<code>键名</code>、<code>集合本身</code>。因为Set结构的键名就是键值,因此第一个参数和第二个参数的值永远是一样的。</li></ul><ol start="4"><li>遍历的应用</li></ol><ul><li>扩展运算符(<code>...</code>)内部使用<code>for...of</code>循环,所以也可以用于Set结构。</li><li>扩展运算符和Set结构结合,就可以去除数组的重复成员。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2, 4]</span></span><br></pre></td></tr></table></figure></li><li>数组的<code>map</code>方法和<code>filter</code>方法也可以间接用于Set。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构: &#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function"><span class="params">item</span> =&gt;</span> (item % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构: &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure></li><li>因此使用Set可以很容易的实现并集(Union)、交集(Intersect)和差集(Difference)。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">const</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// 返回Set结构: &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">const</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// 返回Set结构: &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">const</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// 返回Set结构: &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li>如果想在遍历操作中,同步改变原来的Set结构有两种方法:一种是利用原Set结构映射出一个新的结构,然后赋值给原来的Set结构;另一种是利用<code>Array.from()</code>方法</li><li><code>Array.from(array, mapFn, thisArg)</code>方法从一个类似数组或可迭代对象创建一个新的、浅拷贝的数组实例。<ol><li>第一个参数:想要转换成数组的伪数组对象或可迭代对象</li><li>第二个参数:可选,如果指定了该参数,新数组中的每个元素都会执行该回调函数。</li><li>第三个参数:可选,执行回调函数mapFn时的this对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构: &#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构: &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2></li></ol></li></ul><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>WeakSet结构与Set类似,也是不重复的值的集合。但是,它与Set有两个区别</p><ol><li>WeakSet的成员只能是对象,而不能是其他类型的值</li></ol><p><a href="https://imgtu.com/i/cQje3T"><img src="https://z3.ax1x.com/2021/04/05/cQje3T.png" alt="cQje3T.png"></a></p><ol start="2"><li>WeakSet中的对象都是弱引用,即垃圾回收机制不考虑WeakSet对该对象的引用,也就是说,<strong>如果其他对象都不再引用该对象,那么垃圾回收机制会自动回收该对象所占用的内存,不考虑该对象是否还存在与WeakSet中</strong>。</li></ol><p>因为垃圾回收机制依赖引用计数,如果一个值的引用次数不为<code>0</code>,垃圾回收机制就不会释放这块内存。结束使用该值后,有时候忘记取消引用,可能引发内存泄漏问题。WeakSet里面的引用,都不计入垃圾回收机制,所以不存在这个问题。<strong>WeakSet适合临时存放一组对象,以及存放跟对象绑定的信息。只要这些对象在外部消失,它在WeakSet里的引用就会自动消失。</strong></p><p><strong>ES6规定WeakSet不可遍历。</strong></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>WeakSet是一个构造函数,可以使用<code>new</code>,创建WeakSet数据结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br></pre></td></tr></table></figure><p>作为构造函数,WeakSet可以接收一个数组或或类似数组的对象作为参数。(<strong>任何具有Iterable接口的对象都可以作为WeakSet的参数</strong>)该数组的所有<code>成员</code>(而不是数组本身),都会自动成为WeakSet实例对象的<code>成员</code>。</p><p>WeakSet结构的三个方法:</p><ul><li><code>WeakSet.prototype.add(value</code>): 向WeakSet实例添加一个新成员。</li><li><code>WeakSet.prototype.delete(value)</code>: 清除WeakSet实例的<code>指定</code>成员。</li><li><code>WeakSet.prototype.has(value)</code>: 查询某个值是否在WeakSet实例之中。返回一个布尔值。</li></ul><p>WeakSet没有<code>size</code>属性,没有办法遍历它的成员。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>).add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(obj); <span class="comment">// true</span></span><br><span class="line">ws.has(foo); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>);</span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.size <span class="comment">// undefined</span></span><br><span class="line">ws.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item)); <span class="comment">// Uncaught TypeError: ws.forEach is not a function</span></span><br></pre></td></tr></table></figure><p><strong>WeakSet不能遍历,是因为成员都是弱引用,随时都可能消失,遍历机制无法保证成员的存在。WeakSet的一个用处,是存储DOM节点,不用担心这些节点从文档移除时,引发内存泄漏。</strong></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>ES6提供的Map数据结构。类似于对象,也是键值对的集合,但是键名不限于字符串,各种类型的值(包括对象)都能当作键。</p><p>作为构造函数,<code>Map</code>也可以接收一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>,  <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line">map.size; <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// 张三</span></span><br><span class="line">map.has(<span class="string">&#x27;title&#x27;</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;title&#x27;</span>); <span class="comment">// Author</span></span><br></pre></td></tr></table></figure><p>实际上执行的是以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>,  <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  map.set(item, index)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不仅仅是数组,任何具有Iterator接口、且每个成员都是一个双元素(例如: [‘a’, 1])的数组的数组结构都可以当作<code>Map</code>构造函数的参数(如果数组中只有一个元素,这个元素会被当作键名,键值为undefined)。这就是说,<code>Set</code>和<code>Map</code>都可以用来生成新的<code>Map</code>。</p><p><strong>如果对同一个键多次赋值,后面的值将覆盖前面的值。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   .set(<span class="number">1</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">1</span>); <span class="comment">// bbb</span></span><br></pre></td></tr></table></figure><p>如果读取一个未知的键,则返回<code>undefined</code>。</p><p>只有对同一个对象的引用,Map结构才会将其视为同一个键。不同的对象引用地址不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map.set(k1, <span class="number">111</span>);</span><br><span class="line">map.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1); <span class="comment">// 111</span></span><br><span class="line">map.get(k2); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p><code>Map</code>的键实际上是跟内存地址绑定的,只要内存地址不同,那么就视为两个键。<code>Map</code>解决了同名属性碰撞的问题。</p><p>如果Map的键是一个简单类型的值,则只要两个值<code>严格相等</code>,Map就会将其视为一个键,要注意的是,<code>undefined</code>和<code>null</code>是两个不同的键;两个<code>NaN</code>在Map中视为同一个键。</p><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><ol><li>size属性</li></ol><p><code>size</code>属性返回Map结构的成员总数。</p><ol start="2"><li>Map.prototype.set(key, value)</li></ol><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>,然后返回整个Map结构。如果<code>key</code>已经有值,则键值会被更新,否则就新生成该键。<code>set</code>可以采用链式编程的写法。(<strong>只能传key和value,如果有第三个及以后的参数Map会自动忽略。</strong>)</p><ol start="3"><li>Map.prototype.get(key)</li></ol><p><code>get</code>方法读取<code>key</code>对应的键值,如果找不到<code>key</code>,返回<code>undefined</code>。</p><ol start="4"><li>Map.prototype.has(key)</li></ol><p><code>has</code>方法返回一个布尔值,表示<code>某个键</code>是否在当前Map对象之中。</p><ol start="5"><li>Map.prototype.delete(key)</li></ol><p><code>delete</code>方法删除某个键,返回<code>true</code>。如果删除失败返回<code>false</code>。</p><ol start="6"><li>Map.prototype.clear()</li></ol><p><code>clear</code>方法清除所有成员,没有返回值。</p><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>: 返回键名的遍历器</li><li><code>Map.prototype.values()</code>: 返回键值的遍历器</li><li><code>Map.prototype.entries()</code>: 返回键值对的遍历器,Map结构的默认遍历器接口(<code>Symbol.iterator属性</code>),就是<code>entries</code>方法。</li><li><code>Map.prototype.forEach()</code>: 遍历Map的所有成员</li></ul><p>Map的遍历顺序就是插入顺序:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;no&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;yes&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.keys(); <span class="comment">// MapIterator &#123;&quot;a&quot;, &quot;b&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">map.values(); <span class="comment">// MapIterator &#123;&quot;no&quot;, &quot;yes&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">map.entries(); <span class="comment">// MapIterator &#123;&quot;F&quot; =&gt; &quot;no&quot;, &quot;T&quot; =&gt; &quot;yes&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Map结构转为数组结构,比较快速的方法是使用扩展运算符(<code>...</code>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">[...map.keys()] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.values()] <span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line"></span><br><span class="line">[...map.entries()] <span class="comment">// [ [1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为map.entries()是默认的遍历器接口,可以直接写成</span></span><br><span class="line">[...map]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法,可以实现Map的遍历和过滤(Map本身没有<code>map</code>和<code>filter</code>方法)。</p><h3 id="与其他数据结构的相互转换"><a href="#与其他数据结构的相互转换" class="headerlink" title="与其他数据结构的相互转换"></a>与其他数据结构的相互转换</h3><ol><li>Map转为数组</li></ol><p>Map转为数组最方便的方法,就是使用扩展运算符(<code>...</code>)。</p><ol start="2"><li>数组转为Map</li></ol><p>将数组传入Map构造函数,就可以转为Map。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="string">&quot;foo&quot;</span>, <span class="number">3</span>&#125;, [<span class="string">&quot;abc&quot;</span>]]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&quot;abc&quot;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Map转为对象</li></ol><p>如果所有的Map的键都是字符串,它可以无损的转为对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToObj</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个没有任何属性的对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 或者可写成const myMap = new Map([ [&#x27;yes&#x27;, true], [&#x27;no&#x27;, false] ]);</span></span><br><span class="line"></span><br><span class="line">mapToObj(myMap); <span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>对象转为Map</li></ol><p>对象转为Map可以通过<code>Object.entries(obj)</code>,该方法返回一个给定对象自身<code>可枚举属性</code>的键值对数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure><p>或者可以通过<code>Object.keys(obj)</code>,该方法返回一个给定对象自身<code>可枚举属性</code>组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    map.set(key, obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToMap(&#123; <span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span> &#125;); </span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125; </span></span><br></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似,也是用于生成键值对的集合。<code>WeakMap</code>与<code>Map</code>的区别有两点:</p><ul><li><code>WeakMap</code>只接收对象作为键名(<code>null</code>除外),不接受其他类型的值作为键名。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used as weak map key.</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><code>WeakMap</code>的键名所指向的对象,不计入垃圾回收机制。</li></ul><p><code>WeakMap</code>设计目的在于,有时候想在某个对象上存放一些数据,但是会形成对于这个对象的引用。一旦不再需要该对象,就必须手动删除这个引用(<code>null赋值</code>)。否则会导致内存泄漏问题。</p><p>WeakMap的键名所引用的对象都是弱引用,即垃圾回收机制不将该引用考虑在内。所有,只要所引用的对象的其他引用被清除,垃圾回收机制就会释放该对象所占用的内存。也就是说,WeakMap里面的键名对象和所对应的键值对会自动消失,不用手动删除引用。</p><h3 id="WeakMap的语法"><a href="#WeakMap的语法" class="headerlink" title="WeakMap的语法"></a>WeakMap的语法</h3><p>WeakMap与Map在API的区别主要是两个,一是没有遍历操作(即没有<code>keys()</code>、<code>values()</code>、<code>entries()</code>方法),也没有<code>size</code>属性。因为没有办法列出所有键名,跟垃圾回收机制是否运行相关。为了防止出现不确定性,就统一规定不能取到键名。二是无法清空,即不支持<code>clear</code>方法。因此,WeakMap只有四个方法可用: <code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化琐碎</title>
      <link href="2021/03/02/xing-neng-you-hua/"/>
      <url>2021/03/02/xing-neng-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p>浏览器会从上到下解析文档</p><ul><li>遇到HTML标记,调用HTML解析器解析对应的token(一个token就是一个标签文本的序列化)并构建DOM树。</li><li>遇见style/link标记调用相应的解析器处理CSS标记,并构建出CSS样式树。</li><li>遇见script标记,调用JavaScript引擎处理script标记、绑定事件、修改DOM树/CSS样式树等。</li><li>将DOM树和CSS样式树,合并成一个渲染树。</li><li>根据渲染树来渲染,以计算每个节点的几何信息。</li><li>最终将各个节点绘制到屏幕上。</li></ul><h2 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染"></a>阻塞渲染</h2><ol><li>关于CSS阻塞:</li></ol><ul><li>style标签中的样式:<ol><li>由html解析器进行解析</li><li>不阻塞浏览器渲染(可能产生”闪屏现象”)</li><li>不阻塞DOM解析</li></ol></li><li>link引入的外部CSS样式(推荐方式):<ol><li>由CSS解析器进行解析</li><li>阻塞浏览器渲染(可解决<code>闪屏现象</code>)</li><li>阻塞后续js语句执行</li><li>不阻塞DOM解析</li></ol></li></ul><p>优化核心理念: 尽可能快的提高外部CSS加载速度</p><ul><li>使用CDN节点进行外部资源加速</li><li>对CSS进行压缩(webpack<code>OptimizeCssAssetsPlugin</code>)</li><li>减少HTTP请求数,将多个CSS文件合并</li></ul><ol start="2"><li>关于js阻塞:</li></ol><ul><li><p>阻塞后续DOM解析:</p><p>原因: 浏览器不知道后续脚本的内容,如果先去解析下面的DOM,之后JS操作DOM删除了后面所有的DOM,便是做了无用功！</p></li><li><p>阻塞页面的渲染</p><p>原因: JS野能操作DOM给DOM设置样式,浏览器会等JS脚本执行完毕后,渲染最终的结果。</p></li><li><p>阻塞后续JS执行</p></li></ul><h2 id="CSS图层"><a href="#CSS图层" class="headerlink" title="CSS图层"></a>CSS图层</h2><ol><li>图层创建条件</li></ol><ul><li>拥有具有3D变化的CSS属性(如: transform: translateZ(0))</li><li>使用加速视频解码<code>&lt;video&gt;</code>节点</li><li><code>&lt;canvas&gt;</code>节点</li><li>CSS3动画的节点</li><li>拥有CSS加速属性的元素(如: will-change)</li></ul><ol start="2"><li>重绘</li></ol><ul><li>是一个元素外观的改变所触发的浏览器行为,例如: 改变背景色、outline等属性。</li><li>图层是以图层为单位,如果图层中的某个元素需要重绘,那么整个图层都会重绘</li></ul><ol start="3"><li>重排</li></ol><ul><li>当页面结构或元素大小发生变化时,例如: 改变宽高、display、overflow等。</li></ul><p><strong>重绘不一定需要重排,但重排必定会发生重绘。</strong></p><ol start="4"><li>常见触发重排的操作</li></ol><ul><li>增加、删除、修改DOM节点时,会导致重绘和重排。</li><li>当移动DOM的位置</li><li>当修改CSS样式</li><li><strong>当Resize窗口的时候(移动端不会)</strong></li><li><strong>当修改网页的默认字体时</strong></li><li><strong>获取某些属性时(width、height…)</strong></li></ul><ol start="5"><li>优化方案</li></ol><ul><li><strong>元素位置移动变化时候尽量使用CSS3的transform来替代top、left等操作</strong></li><li><strong>使用opcity去替代visibility,但是opcity必须配合图层(will-change: transform)使用</strong></li><li>避免多次修改DOM样式,预先定义好class,去修改DOM的className</li><li><strong>如果要对一个元素进行复杂操作时,可以先<code>display: none;</code>隐藏,操作完后再显示。该方式只会触发两次重排重绘</strong></li><li>通过<code>documentFragment</code>创建DOM碎片,在它上面批量操作,然后再加到文档中</li></ul><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><h3 id="计算图片大小"><a href="#计算图片大小" class="headerlink" title="计算图片大小"></a>计算图片大小</h3><p>对于一张100 * 100像素的图片来说,图片上有10000个像素点。</p><p>但实习项目中,一张图片可能不需要使用这么多颜色去显示,我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p><p>图片优化的两个思路:</p><ol><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ol><h3 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h3><ol><li>不用图片。很多时候会使用到很多修饰类图片,其实这类修饰图片完全可以用<strong>CSS代替</strong>。</li><li>对于移动端来说,屏幕宽度就那么多,完全没必要去加载原图。一般图片都用<strong>CDN加载</strong>,可以计算出适配屏幕额宽度,然后去请求相应裁剪好的图片。</li><li>小图可以使用<strong>base64格式</strong></li><li>将多个图标文件整合到一张图片中(<strong>精灵图</strong>)</li></ol><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>DNS解析也需要时间,可以通过预解析的方式来预先获取域名所对应的IP。</p><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>在函数需要频繁触发时,在规定时间内,只让最后一次生效,前面的不生效。适合多次事件一次响应的情况。<strong>一般适用于输入框实时搜索联想(keyup/input)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// immediate控制开始是否执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay, immediate = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录定时器Id</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 是否立即执行一次</span></span><br><span class="line">  <span class="keyword">let</span> isRightnow = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="comment">// 第一次进入立即执行一次函数</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !isRightnow) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      isRightnow = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        isRightnow = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 防止内存泄漏</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><p>在函数频繁触发时,函数执行一次后,只有在大于设定的执行周期后才会继续执行下一次操作。适合多次事件按时间做平均分配触发。<strong>一般用于窗口调整(resize)、页面滚动(scroll)或按钮点击(click)等</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval, options = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  begin: <span class="literal">true</span>, <span class="regexp">//</span> 开始是否执行一次</span></span></span><br><span class="line"><span class="function"><span class="params">  end: <span class="literal">false</span>, <span class="regexp">//</span> 结束是否执行一次</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="comment">// 第一次执行的原因是nowTime第一次取值肯定是很大的,但是第一次的lastTime为0,</span></span><br><span class="line">    <span class="comment">// interval减去一个很大的时间戳肯定比0小,所以会立即执行一次。</span></span><br><span class="line">    <span class="keyword">if</span> (!options.begin &amp;&amp; !lastTime) lastTime = nowTime;</span><br><span class="line">    <span class="keyword">const</span> remainTime = interval - (nowTime - lastTime);</span><br><span class="line">    <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      <span class="comment">// 记录上一次时间</span></span><br><span class="line">      lastTime = nowTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器渲染原理</title>
      <link href="2021/02/27/liu-lan-qi-xuan-ran-yuan-li/"/>
      <url>2021/02/27/liu-lan-qi-xuan-ran-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器接收到HTML文件并转换为DOM树"><a href="#浏览器接收到HTML文件并转换为DOM树" class="headerlink" title="浏览器接收到HTML文件并转换为DOM树"></a>浏览器接收到HTML文件并转换为DOM树</h2><p>当我们打开一个网页时,浏览器都会去请求对应的HTML文件。虽然平时我们写代码时都会分为JS、HTML、CSS文件,也就是字符串,但是计算机硬件不理解这些字符串,所以网络中传输的内容其实都是<code>0</code>和<code>1</code>这些字节数据。当浏览器接收到这些字节数据后,它会将这些<strong>字节数据转为字符串</strong>,也就是我们写的代码。</p><p><a href="https://imgtu.com/i/6pKzbd"><img src="https://s3.ax1x.com/2021/02/27/6pKzbd.png" alt="6pKzbd.png"></a></p><p>当数据转换为字符串后,浏览器会先将这些字符串通过词法分析转换为<strong>标记(token)</strong>,这一过程在词法分析中叫做<strong>标记化(tokenization)</strong></p><p><a href="https://imgtu.com/i/6pQ2XF"><img src="https://s3.ax1x.com/2021/02/27/6pQ2XF.png" alt="6pQ2XF.png"></a></p><p>什么是标记?简单来说,标记还是<strong>字符串</strong>,是构成代码的<strong>最小单位</strong></p><p><a href="https://imgtu.com/i/6plR8P"><img src="https://s3.ax1x.com/2021/02/27/6plR8P.png" alt="6plR8P.png"></a></p><p>当结束标记化后,这些标记会紧接着转换为Node,最后这些Node会根据不同Node之前联系构建一颗DOM树。</p><p><a href="https://imgtu.com/i/6p1eqe"><img src="https://s3.ax1x.com/2021/02/27/6p1eqe.png" alt="6p1eqe.png"></a></p><p>以上为浏览器从网络中接收到HTML文件然后一系列的转换过程。</p><p><a href="https://imgtu.com/i/6p1fiR"><img src="https://s3.ax1x.com/2021/02/27/6p1fiR.png" alt="6p1fiR.png"></a></p><h2 id="将CSS文件转换为CSSDOM树"><a href="#将CSS文件转换为CSSDOM树" class="headerlink" title="将CSS文件转换为CSSDOM树"></a>将CSS文件转换为CSSDOM树</h2><p>转换CSS到CSSOM树的过程和上一小节的过程类似</p><p><a href="https://imgtu.com/i/6pIt3j"><img src="https://s3.ax1x.com/2021/02/27/6pIt3j.png" alt="6pIt3j.png"></a></p><p>再这个过程中,浏览器会确定下每一个节点的<strong>样式</strong>到底是什么,并且这一过程其实是很<strong>消耗资源</strong>的。因为样式可以自行设置给某个节点,也可以通过继承获得。在这个过程中,浏览器需要递归CSSOM树,然后确定具体的元素到底是什么样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  div &gt; a &gt; span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于第一种设置样式的方式来说,浏览器只需要找到页面中所有的<code>span</code>标签然后设置颜色,但是对于第二种设置样式的方式来说,浏览器首先需要找到所有的<code>span</code>标签,然后找到<code>span</code>标签上的<code>a</code>标签,最后再去找到<code>div</code>标签,然后给符合这种条件的<code>span</code>标签设置颜色,这样的递归过程就很复杂。所有我们应该尽可能避免去写<strong>过于具体</strong>的CSS选择器,然后对于HTML来说也尽量少的添加无意义标签,保证<strong>层级扁平</strong></p><h2 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h2><p>当生成DOM树和CSSOM树后,就需要将两棵树组合成渲染树</p><p><a href="https://imgtu.com/i/6p70bt"><img src="https://s3.ax1x.com/2021/02/27/6p70bt.png" alt="6p70bt.png"></a></p><p>在这一过程中,不是简单的将两者合并就可以了。渲染树只会包括<strong>需要显示的节点</strong>和<strong>这些节点的样式信息</strong>,如果某个节点是<code>display: none</code>,那么就不会在渲染树中显示</p><p>当浏览器生成渲染树后,就会根据渲染树来进行布局(回流)。然后调用GPU绘制,合成图层,显示在屏幕上</p><h2 id="为什么操作DOM慢"><a href="#为什么操作DOM慢" class="headerlink" title="为什么操作DOM慢"></a>为什么操作DOM慢</h2><p>因为DOM是属于渲染引擎中的东西,而JS又是JS引擎中的东西。当我们通过JS操作DOM的时候,其实这个操作涉及到了两个线程之间的通信,那么势必会带来一些性能上的损耗。操作DOM次数一多,也就等同于一直在进行线程之间的通信,并且操作DOM可能还会带来重绘回流的情况,所以也就导致了性能上的问题。</p><h2 id="什么情况阻塞渲染"><a href="#什么情况阻塞渲染" class="headerlink" title="什么情况阻塞渲染"></a>什么情况阻塞渲染</h2><p>首先渲染的前提是<code>生成渲染树</code>,所以<code>HTML</code>和<code>CSS</code>肯定会阻塞渲染。如果想渲染的越快,就应该降低一开始需要渲染的<strong>文件大小</strong>,并且<strong>扁平层级</strong>,<strong>优化选择器</strong>。</p><p>然后当浏览器在解析到<code>script</code>标签时,会暂停构建DOM,完成后才会从暂停的地方重新开始,<strong>因为浏览器不知道后续脚本的内容,如果先去解析了下面的DOM,随后JS操作DOM删除了后面所有DOM,那么浏览器就做了无用功</strong>。所以说,如果想首屏渲染的越快,就不应该在首屏就加载JS文件,<strong>一般情况下建议将<code>script</code>标签放在<code>body</code>标签的底部</strong></p><h2 id="CSS图层"><a href="#CSS图层" class="headerlink" title="CSS图层"></a>CSS图层</h2><p>图层创建的条件:</p><ol><li>拥有具有3D变化的CSS属性(如: transform: translateZ(0))</li><li><code>&lt;canvas&gt;</code>节点</li><li>CSS3动画节点</li><li>拥有CSS加速属性的元素(如: will-change)</li><li>使用加速视频解码的<code>&lt;video&gt;</code>节点</li></ol><h2 id="重绘-Repaint-和回流-Reflow"><a href="#重绘-Repaint-和回流-Reflow" class="headerlink" title="重绘(Repaint)和回流(Reflow)"></a>重绘(Repaint)和回流(Reflow)</h2><ol><li>重绘<ul><li>是一个元素外观的改变所触发的浏览器行为,例如改变背景色、outline等属性</li><li>重绘是以图层为单位,如果图层中的某个元素需要重绘,那么整个图层都会重绘</li></ul></li><li>重排(又称回流)<ul><li>当页面结构或元素大小发生变化时,例如改变宽高、display、overflow等</li></ul></li></ol><p><strong>重绘不一定需要重排,但是重排大多数情况下会导致重绘</strong></p><ol start="3"><li><p>常见触发重排的操作</p><ul><li>增加、删除、修改DOM节点时,会导致重绘和重排</li><li>当移动DOM的位置时</li><li>当修改CSS样式时</li><li><strong>当Resize窗口的时候(移动端没有这个问题)</strong></li><li><strong>当修改页面的默认字体时</strong></li><li><strong>获取某些属性时(width,height…)</strong></li></ul></li><li><p>减少重绘和重排的方案</p><ul><li><strong>元素位置移动变化时尽量使用CSS3的transform来替代top、left等操作</strong></li><li>使用<code>visibility</code>替换<code>display: none</code>,因为前者只会引起重绘,后者会引发回流(改变了布局)</li><li>CSS选择符<code>从右往左</code>匹配查找,避免节点层级过多</li><li>不要使用<code>table</code>布局,一个小改动可能会造成整个<code>table</code>的重新布局</li><li>动画实现速度的选择,动画速度越快,重排次数就越多,也可以选择使用<code>window.requestAnimationFrame(callback)</code><strong>若想在浏览器下一次重绘前继续更新下一帧动画,那么回调函数自身需要再次调用window.requestAnimationFrame()</strong></li><li>将频繁重绘或重排的节点设置为图层,图层能够阻止该节点的渲染行为影响其他节点。</li></ul></li></ol><blockquote><p>在不考虑缓存和优化网络协议的前提下,考虑可以通过哪些方式来最快的渲染页面?</p></blockquote><ol><li>尽可能避免去写<strong>过于具体</strong>的CSS选择器,然后对于HTML来说也尽量少的添加无意义标签,保证<strong>层级扁平</strong></li><li>尽可能将<code>script</code>标签放到body底部,将<code>link</code>标签写在顶部</li><li>使用图片懒加载</li><li>避免滥用全局变量,减少作用域的查找。不要滥用闭包,避免使用不当造成内存泄漏的问题</li><li>当需要设置的样式很多时设置className,而不是直接操作style</li><li>尽可能少的用js去操作DOM,可能会导致重排或重绘的情况</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="2021/02/26/liu-lan-qi-huan-cun-ji-zhi/"/>
      <url>2021/02/26/liu-lan-qi-huan-cun-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p>缓存可以说是性能优化中简单高效的优化方式了,它可以<strong>显著减少网络传输带来的损耗</strong></p><p>对于一个数据请求来说,可以分别发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如直接使用缓存而不发起请求,或者发起了请求但后端存储的数据和前端一致,那么就没有必要再将数据传回来,这样就减少了响应数据。</p><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>从缓存位置上来说分为四种,并且各自有优先级,当一次查找缓存且都没有命中的时候,才回去请求网络</p><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li><li>网络请求</li></ol><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker的缓存与浏览器其他内建的缓存机制不同,它可以让我们<strong>自由控制</strong>哪些文件、如何匹配缓存、如何读取缓存、并且<strong>缓存是持续性的</strong></p><p>当Service Worker没有命中缓存的时候,我们需要去调用<code>fetch</code>函数获取数据。也就是说,如果我们没有在Service Worker命中缓存的话,会根据缓存查找优先级去查找数据。<strong>但不管我们是从Memory Cache中还是网络请求中获取数据,浏览器都会显示从Service Worker中获取的内容</strong></p><h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>Memory Cache也就是内存中的缓存,读取内存中的数据肯定比磁盘快。<strong>内存缓存虽然读取高效,但是缓存持续性短,会随着进程的释放而释放。</strong>一旦我们关闭Tab页面,内存中的缓存也被释放了。</p><p>当我们访问过页面后,再次刷新页面,会发现很多数据都来自于内存缓存</p><p><a href="https://imgtu.com/i/6SrfU0"><img src="https://s3.ax1x.com/2021/02/27/6SrfU0.png" alt="6SrfU0.png"></a></p><h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache也就是存储在硬盘中的缓存,读取速度慢点,相比于Memory Cache<strong>胜在容量和存储时效性上。</strong></p><p>在所有浏览器缓存中,Disk Cache覆盖面基本是最大的。他会根据HTTP Header中的字段判断哪些资源需要缓存,哪些资源可以不请求直接使用,哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下,相同地址的资源一旦被硬盘缓存下来,就不会再次去请求数据。</strong></p><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>当以上三种缓存都没有命中时,它才会被使用。<strong>并且缓存时间也很短暂,只在会话(session)中存在,一旦会话结束就被释放。</strong></p><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>如果所有缓存都没有命中的话,那么只能发起请求来获取资源了。</p><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p>通常浏览器缓存策略分为: <strong>强缓存</strong>和<strong>协商缓存</strong>并且缓存策略都是通过设置HTTP Header来实现的。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存可以通过设置两种HTTP Header实现:<code>Expires</code>和<code>Cache-Control</code>。强缓存表示在缓存期间不需要请求,直接从本地缓存中获取数据,请求资源的状态码为<code>200 ok(from memory cache)</code></p><h4 id="强缓存的header参数"><a href="#强缓存的header参数" class="headerlink" title="强缓存的header参数"></a>强缓存的header参数</h4><ol><li>expires: 它的值为一个绝对时间的GMT格式的时间字符串<code>Sat, 27 Feb 2021 03:21:51 GMT</code>,如果发送的时间再expires之前,那么本地缓存始终有效,否则就会发送请求到服务器来获取资源。</li><li>cache-control: <code>Cache-control: max-age=30</code>,它的<strong>优先级要高于<code>Expires</code>**。该属性值表示资源会在30秒后过期,需要再次请求。<code>cache-control</code>**可以再请求头或响应头中设置</strong>,并且可以组合使用多种指令</li></ol><table><thead><tr><th>指令</th><th align="center">作用</th></tr></thead><tbody><tr><td>public</td><td align="center">表示响应可以被客户端和代理服务器缓存</td></tr><tr><td>private</td><td align="center">表示响应只能被客户端缓存</td></tr><tr><td>max-age=30</td><td align="center">缓存30秒后过期,需要重新请求</td></tr><tr><td>s-max-age=30</td><td align="center">覆盖max-age,作用一样,只在代理服务器中生效</td></tr><tr><td>no-store</td><td align="center">不缓存任何响应</td></tr><tr><td>no-cache</td><td align="center">资源被缓存,但是立即失效,下次会发起请求验证资源是否过期</td></tr><tr><td>max-stale=30</td><td align="center">30秒内,即使缓存过期,也是用该缓存</td></tr><tr><td>min-fresh=30</td><td align="center">希望在30秒内获取最新的响应</td></tr></tbody></table><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>如果缓存过期了,就需要发起请求验证资源是否更新。协商缓存可以通过设置两种HTTP Header实现:<code>Last-Modified</code>和<code>Etag</code>。</p><p>向服务器发送请求,服务器会根据请求头的资源判断是否命中协商缓存。如果命中,则返回304状态码通知浏览器从缓存中读取数据</p><h4 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h4><p><code>Last-Modified</code>和<code>If-Modified-Since</code>两者的值都是GMT格式的时间字符串</p><ol><li>浏览器第一次跟服务器请求一个资源,服务器在返回这个资源的同时,在<code>response的header</code>加上<code>Last-Modified</code>的header,表示这个资源在服务器上的<strong>最后修改时间</strong></li><li>浏览器再次跟服务器请求这个资源时,在<code>request的header</code>上加上<code>If-Modified-Since</code>的header,这个header的值就是上一次请求时返回的<code>Last-Modified</code>的值</li><li>服务器再次收到请求资源时,根据浏览器传过来的<code>If-Modified-Since</code>和资源在服务器上的最后修改时间判断资源是否有变化,如果没有则返回304状态码,但不会返回资源内容;如果有变化,就正常返回资源内容。当服务器返回304的响应时,response header中不再添加<code>Last-Modified</code>的header,因为资源没有变化,那么<code>Last-Modified</code>也不再改变。</li><li>浏览器接收到304的响应后,就会从缓存中加载资源</li><li>如果协商缓存没有命中,浏览器直接从服务器加载资源时,<code>Last-Modified</code>的header在重新加载的时候会被更新。下次请求时,<code>If-Modified-Since</code>会使用上次返回的<code>Last-Modified</code>的值</li></ol><h4 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a>Etag和If-None-Match</h4><p>Etag类似于文件指纹,If-None-Match会将当前Etag发送给服务器,询问该资源Etag是否变动,有变动的话就将新的资源发送回来。并且<code>Etag</code>优先级比<code>Last-Modified</code>高</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>利用<code>Etag</code>能够<strong>更加准确的控制缓存</strong>,因为<code>Etag</code>是服务器自动生成或者开发者生成的对应资源在服务器的唯一标识符</li><li><code>Last-Modified</code>与<code>Etag</code>是可以一起使用的,服务器会优先验证<code>Etag</code>,一致的情况下,才会继续对比<code>Last-Modified</code>,最后再决定是否返回304。</li></ol><h3 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h3><h4 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h4><p>对于频繁变动的资源,首先需要使用<code>cache-control: no-cache</code>使浏览器每次都请求服务器,然后配合<code>Etag</code>或者<code>Last-Modified</code>来验证资源是否有效。这样做法虽然不能节省请求次数,但是能显著减少响应数据大小。</p><h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><p>这里特指除了HTML外的代码文件,因为HTML文件一班不缓存或者缓存时间短。</p><p>一般来说,现在都会使用工具来打包代码,那么我们就可以对文件名进行哈希处理,只有当代码修改后才会生成新的文件名。我们可以给代码文件设置缓存有效期一年<code>cache-control: max-age=3153600</code>,这样只有当HTML文件中引入的文件名发生变化才会去下载最新的代码文件,否则就一直使用缓存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器基础知识点</title>
      <link href="2021/02/23/liu-lan-qi-ji-chu-zhi-shi-dian/"/>
      <url>2021/02/23/liu-lan-qi-ji-chu-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><blockquote><p>事件的触发过程是怎么样的?什么是事件代理?</p></blockquote><h3 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h3><ol><li>捕获阶段<ul><li><code>window</code>往事件触发处传播(上层传到底层),遇到注册的捕获事件会触发</li></ul></li><li>目标阶段<ul><li>事件到达目标节点时,就到了目标阶段,事件在目标节点上被触发</li></ul></li><li>冒泡阶段<ul><li>从事件触发处往<code>window</code>传播(底层传回上层),遇到注册的冒泡事件会触发</li></ul></li></ol><p>事件触发一般会按照上面的顺序进行,但也有特例,<strong>如果给<code>body</code>中的子节点同时注册冒泡和捕获事件,事件触发会按照注册的顺序执行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后打印捕获</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>通常使用<code>addEventListener</code>注册事件,该函数的第三个参数可以是布尔值,也可以是对象。对于布尔值<code>useCapture</code>参数来说,该参数默认值为<code>false(冒泡)</code>,<code>useCapture</code>决定了注册的事件是<code>捕获事件</code>还是<code>冒泡事件</code>。对于<code>对象参数</code>来说,可以使用以下几个属性</p><ul><li><code>capture</code>: 布尔值,和<code>useCapture</code>作用一样</li><li><code>once</code>: 布尔值,值为<code>true</code>表示该回调只会调用一次,调用后会移除监听</li><li><code>passive</code>: 布尔值,表示永远不会调用<code>preventDefault(阻止元素发生默认行为)</code></li></ul><p>一般来说,如果只希望事件只触发在目标上,这时候可以使用<code>stopPropagation</code>来阻止事件的进一步传播。<code>stopPropagation</code>是用来阻止事件冒泡的,<code>stopImmediatePropagation</code>是用来阻止事件冒泡并且阻止该元素上同事件类型的监听器被触发</p><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>如果一个节点中的子节点是动态生成的,那么子节点需要注册事件的话<strong>应该注册到父节点上</strong></p><p><code>事件代理</code>的本质就是利用<code>事件冒泡</code>的机制把里层所需要响应的事件绑定到外层</p><p>事件代理的方式相比较于直接给目标注册事件来说,有以下优点:</p><ul><li>节省内存空间,减少事件注册,提高性能</li><li>如果有新增元素,不用再重新给父元素绑定事件,实现了动态绑定事件</li></ul><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><blockquote><p>什么是跨域?为什么浏览器要使用同源策略?有哪几种方式可以解决跨域问题?</p></blockquote><p>因为浏览器出于安全考虑,有<code>同源策略</code>。也就是说,如果<code>协议</code>、<code>域名</code>、<code>端口号</code>有一个不同就是跨域,Ajax请求会失败</p><p><strong>那么是出于什么安全考虑才会引入这种机制?</strong><br>其实主要是用来防止CSRF攻击的。简单来说,CSRF攻击是利用用户的登录状态发起恶意请求。</p><p>也就是说,没有同源策略的情况下,A网站可以被任意其他来源的Ajax访问到内容。如果你当前A网站还存在登录状态,那么对方就可以通过Ajax获得你的任何信息。当然跨域并不完全防止CSRF。</p><p><strong>然后我们来考虑一个问题,请求跨域了,那么请求到底发出去没有?</strong><br>请求必然发出去了,但是浏览器拦截了响应。你可能会疑惑明明通过表单的方式可以发起跨域请求,为什么Ajax不会。因为归根结底,<strong>跨域是为了阻止用户读取到另一个域名下的内容,Ajax可以获取响应,浏览器认为这不安全,所以拦截了响应。但是表单并不会获取新的内容,所以可以发起跨域请求。同时也说明了跨域并不能完全阻止CSRF,因为请求已经发出去了</strong></p><p>几种常见的方式解决跨域问题</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><ol><li>原理: 利用script标签发送请求不受同源策略的限制,所以不会产生跨域问题</li><li>套路: 动态构建script节点,利用节点的src属性,发送<code>get</code>请求,从而绕开ajax引擎</li><li>弊端: <ul><li>虽然使用简单且兼容性不错,但只能解决<code>get</code>请求跨域的问题</li><li>后端必须配合前端</li></ul></li></ol><p>通过<code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS需要浏览器和后端同时支持</p><p>浏览器会自动进行CORS通信,实现CORS通信的关键是后端。只要后端实现了CORS,就实现了跨域</p><p>服务器端设置<code>Access-Control-Allow-Origin</code>就可以开启CORS。该属性表示哪些域名可以访问资源,如果设置<code>通配符*</code>则表示所以网站都可以访问资源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;允许放行的地址&#x27;</span>)</span><br></pre></td></tr></table></figure><p>虽然设置CORS和前端没什么关系,但是通过这种方式解决跨域问题的话,会在发送请求时出现两种情况,分别为<strong>简单请求和复杂请求</strong>。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>以Ajax为例,当满足以下条件时,会出发简单请求</p><ol><li>使用下列方法之一:<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>Content-Type的值仅限于下列三者之一:<ul><li><code>text/plain</code></li><li><code>mutatipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul></li></ol><p>请求中的任意 <code>XMLHttpRequestUpload</code>对象均没有注册任何事件监听器;<code>XMLHttpRequestUpload</code>对象可以使用<code>XMLHttpRequest.upload</code>属性访问。</p><h4 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h4><p>如果不符合以上条件的请求就肯定是复杂请求了。</p><p>对于复杂请求来说,首先会发起一个预检请求,该请求是<code>option</code>方法的,通过该请求来知道服务器端是否允许跨域请求。</p><p>对于预检请求来说,如果你使用过Node来设置CORS的话,可能会遇到过坑。</p><p>以下以express框架举例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT,GET,POST,DELETE,OPTIONS&#x27;</span>)</span><br><span class="line">  res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该请求会验证你的<code>Authorization</code>字段,没有的话就会报错</p><p>当前端发起了复杂请求后,你会发现就算代码正确,返回的结果也永远报错。因为预检请求也会进入回调中,也会触发<code>next</code>方法,因为预检请求并不包含<code>Authorization</code>字段,所以服务端会报错。</p><p>解决这个问题,只需要在回调中过滤<code>option</code>方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.statusCode = <span class="number">204</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Content-Length&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p><code>window.postMessage()</code>方法可以安全的实现跨源通信。</p><p><code>window.postMessage()</code>方法提供了一种受控机制来规避同源策略限制,正确使用该方法就很安全</p><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息,另一个页面判断来源并接收消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;http://test.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">mc.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">  <span class="keyword">if</span>(origin === <span class="string">&#x27;http://test.com&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;通过验证&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><blockquote><p>有几种方式可以实现存储功能,分别有什么优缺点?什么是Service Worker?</p></blockquote><h3 id="cookie-localStorage-sessionStorage-indexDB"><a href="#cookie-localStorage-sessionStorage-indexDB" class="headerlink" title="cookie,localStorage,sessionStorage,indexDB"></a>cookie,localStorage,sessionStorage,indexDB</h3><p>先来通过表格学习这几种存储方式的区别</p><table><thead><tr><th>特性</th><th align="center">cookie</th><th align="right">localStorage</th><th align="center">sessionStorage</th><th>indexDB</th></tr></thead><tbody><tr><td>数据生命周期</td><td align="center">一般由服务器生成,可以设置过期时间</td><td align="right">除非被清理,否则一直存在</td><td align="center">页面关闭就清理</td><td>除非被清理,否则一直存在</td></tr><tr><td>数据存储大小</td><td align="center">不能超过4K</td><td align="right">5M,存储量大</td><td align="center">5M,存储量大</td><td>无限</td></tr><tr><td>与服务端通信</td><td align="center">数据始终在同源的http请求中携带,对于请求性能影响</td><td align="right">不参与,仅在本地存储</td><td align="center">不参与,仅在本地存储</td><td>不参与</td></tr></tbody></table><p>从上表可以看到,<code>cookie</code>已经不建议用于存储。如果没有大量数据存储需求的话,可以使用<code>localStorage</code>和<code>sessionStorage</code>。如果不怎么改变的数据尽量使用<code>localStorage</code>,否则用<code>sessionStorage</code>存储。</p><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>Service Worker是运行在浏览器背后的<strong>独立线程</strong>,一般可以用来实现缓存功能。使用Service Worker的话,传输协议必须为<strong>HTTPS</strong>,因为Service Worker中涉及到请求拦截,所以必须使用<code>HTTPS</code>协议保障安全。</p><p>Service Worker实现缓存功能一般分为三个步骤: 首先需要注册Service Worker,然后监听到<code>install</code>事件后就可以缓存需要的文件,那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存,存在缓存的话就可以直接读取缓存文件,否则就去请求数据。以下是这个步骤的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">  <span class="comment">// register方法接收两个参数,第一个是service Worker文件的路径,第二个参数是Service Worker的配置项,可选填,其中比较重要的是scope属性。register返回一个Promise。如果注册失败,可以通过.catch()捕获错误信息;如果注册成功可以通过.then()来获取一个ServiceWorkerRegistration 的实例</span></span><br><span class="line">    .register(<span class="string">&#x27;sw.js&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Service Worker注册成功&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;service worker注册失败&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听install事件,回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">&#x27;my-cache&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;./index.js&#x27;</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经由请求的数据就直接缓存,否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.responseWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;fetch source&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS进阶知识点</title>
      <link href="2021/02/21/js-jin-jie-zhi-shi-dian/"/>
      <url>2021/02/21/js-jin-jie-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="call、apply及bind函数"><a href="#call、apply及bind函数" class="headerlink" title="call、apply及bind函数"></a>call、apply及bind函数</h2><blockquote><p>call、apply及bind函数内部实现是什么样的?</p></blockquote><p>首先从以下几点来考虑如何实现这几个函数</p><ul><li>不传入第一个参数,那么上下文默认为<code>window</code></li><li>调用<code>call</code>和<code>apply</code>的对象,必须是一个函数<code>Function</code></li><li>改变了<code>this</code>指向,让新的对象可以<code>立即执行</code>该函数,并能接收参数</li><li><code>call()</code>的第二个参数为一个<code>参数列表</code>;<code>apply()</code>的第二个参数为一个<code>数组或类数组</code></li></ul><p><code>call</code>的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  obj = obj || <span class="built_in">window</span></span><br><span class="line">  obj.tempFn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result = obj.tempFn(...args)</span><br><span class="line">  <span class="keyword">delete</span> obj.tempFn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析:</p><ul><li><code>obj</code>为可选参数,如果不传默认上下文为<code>window</code></li><li>给<code>obj</code>创建一个<code>tempFn</code>属性,并将值设置为需要调用的函数</li><li>因为<code>call</code>可以传入多个参数作为调用函数的参数,所以需要将参数剥离出来</li><li>然后调用函数并将对象上的函数删除</li></ul><p><code>apply</code>实现,和<code>call</code>区别在于处理参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  obj = obj || <span class="built_in">window</span></span><br><span class="line">  obj.tempFn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 如果第二个参数有值</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = obj.tempFn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    result = obj.tempFn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> obj.tempFn()</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bind</code>实现,需要返回一个新函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> that.apply(obj, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析:</p><ul><li>前面几步和之前实现差不多</li><li><code>bind</code>返回一个函数,新函数内部会调用原来函数,我们需要将两边的参数拼接起来,于是就有了<code>args.concat(...arguments)</code></li></ul><h2 id="apply的一些妙用"><a href="#apply的一些妙用" class="headerlink" title="apply的一些妙用"></a>apply的一些妙用</h2><ol><li>Math.max用来获取数组中最大的一项。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrMax = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array);</span><br></pre></td></tr></table></figure></li><li>Math.min用来获取数组中最小的一项。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrMin = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, array);</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2></li></ol><blockquote><p>new的原理是什么?通过new的方式创建对象和通过字面量创建有什么区别?</p></blockquote><p>再调用new的过程中会发生以上四件事情:</p><ul><li>新生成了一个空对象</li><li>将this指向该空对象</li><li>执行函数给刚创建的对象添加成员属性</li><li>生成实例对象并返回</li></ul><p>根据以上几个过程,可以试着实现一个<code>new</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 通过call将this指向arguments对象,调用数组的shift方法截取arguments的第一个参数拿到构造函数Constructor</span></span><br><span class="line">  Constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 将obj的隐式原型对象指向构造函数的显示原型对象,可以调用构造函数原型上的方法</span></span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  <span class="comment">// 通过apply将this指向obj,obj可以调用构造函数上的属性</span></span><br><span class="line">  <span class="keyword">let</span> result = Constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断构造函数返回的是否是对象</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现new的分析:</p><ul><li>创建一个空对象</li><li>获取构造函数</li><li>设置空对象的原型</li><li>绑定<code>this</code>并执行构造函数</li><li>确保返回值为对象</li></ul><p>对于对象来说,其实都是通过new产生的,无论是<code>function Foo()</code>还是<code>let a = &#123;b : 1&#125;</code></p><p>对于创建一个对象来说,更推荐使用字面量的方式创建对象(无论性能上还是可读性),因为<code>new Object()</code>方式创建对象需要通过作用域链一层层找到<code>Object</code>,但是通过字面量就没有这个问题了</p><h2 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h2><blockquote><p>instanceof的原理是什么?</p></blockquote><p><code>instanceof</code>运算符用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上,返回一个布尔值</p><p>语法: <code>object instanceof constructor</code>。<br><code>object</code>为某个实例对象,<code>constructor</code>为某个构造函数</p><p>对instanceof的简单实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInatanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到右边构造函数的原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> || left === <span class="literal">undefined</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 隐式原型对象 === 显示原型对象</span></span><br><span class="line">    <span class="keyword">if</span>(left === prototype)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left  = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对实现的分析:</p><ul><li>首先获取类型的原型</li><li>然后获取对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型,直到对象原型为<code>null</code>,因为原型链最终为<code>null</code></li></ul><h2 id="为什么0-1-0-2-0-3"><a href="#为什么0-1-0-2-0-3" class="headerlink" title="为什么0.1 + 0.2 != 0.3"></a>为什么0.1 + 0.2 != 0.3</h2><blockquote><p>为什么0.1 + 0.2 != 0.3?如何解决这个问题?</p></blockquote><p>因为JS采用IEEE 754双精度版本</p><p>我们都知道计算机是通过二进制来存储东西的,那么<code>0.1</code>在二进制中会表示为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (0011)表示循环</span></span><br><span class="line"><span class="number">0.1</span> = <span class="number">2</span> ^ -<span class="number">4</span> * <span class="number">1.10011</span>(<span class="number">0011</span>)</span><br></pre></td></tr></table></figure><p>可以发现,<code>0.1</code>在二进制中是无限循环的一些数字,其实不只是<code>0.1</code>,很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题,但是JS采用的浮点数标准会裁掉我们的数字</p><p>那么这些循环的数字被裁剪了,就会出现精度丢失问题,也就造成了<code>0.1</code>不再是<code>0.1</code>,而是变成了<code>0.100000000000000002</code></p><p>同样的,<code>0.2</code>在二进制也是无限循环的,被裁剪后也失去了精度变成了<code>0.200000000000000002</code></p><p>所以这两者相加不等于<code>0.3</code>而是<code>0.300000000000000004</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.300000000000000004</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>解决这个问题,选用原生提供的方式来最简单的解决问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Event Loop</title>
      <link href="2021/02/19/event-loop/"/>
      <url>2021/02/19/event-loop/</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><blockquote><p>进程与线程区别?JS单线程带来的好处?</p></blockquote><p>进程描述了CPU在<strong>运行指令及加载和保存上下文所需的时间</strong>,放在应用上来说就代表了一个程序。线程是进程中更小的单位,描述了执行一段指令所需的时间</p><p>对于浏览器来说,当你打开一个Tab页时,其实就是创建了一个进程,一个进程中可以有多个线程,比如渲染线程、JS引擎线程、HTTP请求线程等。当发起一个请求时,其实就是创建一个线程,当请求结束后,该线程可能就会销毁</p><p>在JS运行时会阻止UI渲染,说明两个线程是<strong>互斥</strong>的。其中的原因是因为JS可以修改DOM,如果在JS执行的时候UI线程还在工作,就可能导致不能安全渲染UI。这也是单线程的好处,可以达到节省内存,节约上下文执行时间。</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ol><li>理解:<ul><li>执行上下文代表了代码执行的环境,包含: 执行环境、变量对象、this、作用域链</li></ul></li><li>流程:<ul><li>js引擎在js代码正式执行前会创建一个执行环境</li><li>进入该环境后创建一个变量对象,该对象用于收集: 函数、变量、函数的参数、this</li><li>确认this的指向</li><li>创建作用域链</li></ul></li><li>重点:<ul><li>执行上下文是<code>动态创建</code>的</li><li>尤其是针对函数,每调用一次函数就会创建一次执行上下文</li></ul></li></ol><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><blockquote><p>什么是执行栈?</p></blockquote><p>可以把执行栈认为是一个<code>存储函数调用的栈结构</code>,遵循<code>先进后出</code>的原则</p><ul><li>在全局代码执行前,js引擎会创建一个<code>栈</code>来存储所有的执行上下文</li><li>在<code>全局执行上下文(window)</code>确定后,将其添加到栈中(压栈)</li><li>在<code>函数执行上下文</code>创建后,将其添加到栈中</li><li>在当前函数执行完毕后,将栈顶的对象移除(出栈,先进后出)</li><li>当所有代码执行完毕后,栈中只剩下window(Global)</li></ul><p><a href="https://imgchr.com/i/yhL19H"><img src="https://s3.ax1x.com/2021/02/19/yhL19H.gif" alt="yhL19H.gif"></a></p><p>当我们使用递归时,因为栈可存放的函数是有<strong>限制</strong>的,一旦存放过多的函数且没有得到释放的话,就会出现爆栈的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/yhj58g"><img src="https://s3.ax1x.com/2021/02/19/yhj58g.png" alt="yhj58g.png"></a></p><h2 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h2><blockquote><p>异步代码执行顺序?解释什么是Event Loop?</p></blockquote><p>当我们执行JS代码的时候其实就是往执行栈中放入函数,如果遇到异步代码怎么办?其实当遇到异步的代码时,会被<code>挂起</code>并在需要执行的时候加入到<code>Task(有多种Task)队列</code>中。一旦执行栈为空,Evnet Loop就会从<code>Task队列</code>中拿出需要执行的代码放入到执行栈中执行,所以本质上来说JS中的异步还是同步行为</p><p><img src="https://s4.aconvert.com/convert/p3r68-cdx67/abrzj-dq7cc.png" alt="abrzj-dq7cc.png"></p><p>不同的任务源会被分配到不同的Task队列中,任务源可以分为<strong>微任务</strong>(microtask)和<strong>宏任务</strong>(macrotask)。在ES6规范中,microtask称为<code>jobs</code>,macrotask称为<code>task</code>,下面来看如下代码执行顺序:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start -&gt; async2 end -&gt; Promise -&gt; script end -&gt; async1 end -&gt; promise1 -&gt; promise2 -&gt; setTimeout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分析: 从上至下, 因为script start为script代码,必然会立刻执行;继续往下执行,发现async1被调用,async1函数中又调用了async2,所以第二个打印的必然是async2 end;async2执行完毕后,因为函数执行完如果没返回值默认return undefined;等同于resolve(undefined),所以async1 end会被放入微任务队列中;继续执行发现setTimeout,setTimeout会被放入到宏任务队列;new Promise()时,会立即调用,故会打印Promise、且promise1和promise2会被放入微任务队列等待打印;往下发现script end;最后会将微任务队列中所有任务执行完后,最后才会输出宏任务中的setTimeout;</span></span><br></pre></td></tr></table></figure><p>Event Loop中,每一次循环称为tick,每一次tick的任务:</p><ul><li><p><strong>js引擎是单线程,会先执行初始化同步代码,等同步代码执行完后再执行队列中的代码</strong></p></li><li><p>遇到宏任务中的异步代码时,会把其放入到宏任务队列中</p></li><li><p>遇到微任务时,会把微任务放到微任务队列中</p></li><li><p>当每次准备取出第一个宏队列中的任务执行前,都要将所有的微任务一个个取出来执行,等所有微任务执行完毕后再执行宏队列中的任务</p><p>微任务包括: <code>process.nextTick</code>, <code>promise</code>, <code>promise.then()或catch()</code>, <code>MutationObserver</code>, <code>queueMicrotask()</code><br>宏任务包括: <code>script</code>, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, <code>I/O</code>, <code>UI rendering</code></p></li></ul><p>这里有个误区,认为微任务快于宏任务,其实是错误的。因为宏任务中包括了<code>script</code>,浏览器会<strong>先执行一个宏任务</strong>,接下来有异步代码的话才会先执行微任务</p><h2 id="Node中的Event-Loop"><a href="#Node中的Event-Loop" class="headerlink" title="Node中的Event Loop"></a>Node中的Event Loop</h2><blockquote><p>Node中的Event Loop和浏览器中的有什么区别?process.nextTick执行顺序?</p></blockquote><p>Node的Evnet Loop分为6个阶段,它们会按照**<em>顺序**</em>反复运行。每当进入某一个阶段的时候,都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值,就会进入下一阶段</p><p><img src="https://s4.aconvert.com/convert/p3r68-cdx67/ajrzo-tflzt.png" alt="ajrzo-tflzt.png"></p><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>timers阶段会执行<code>setTimeout</code>和<code>setInterval</code>回调,并且是由<code>poll阶段</code>控制的。</p><p>同样,在Node中定时器指定的时间也不是准确时间,只能是<strong>尽快</strong>执行</p><h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>I/O阶段会处理一些上一轮循环中的少数未执行的I/O回调</p><h3 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle,prepare"></a>idle,prepare</h3><p>内部实现,忽略</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll是一个至关重要的阶段,这一阶段中,系统会做两件事情</p><ul><li>回到timer阶段执行回调</li><li>执行I/O回调</li></ul><p>并且在进入该阶段时如果没有设定timer的话,会发生以下两件事情</p><ul><li>如果poll队列不为空,会遍历回调队列并同步执行,直到队列为空或达到系统限制</li><li>如果poll队列为空,会有两件事发生<ol><li>如果有<code>setImmediate</code>回调需要执行,poll阶段会停止并进入到check阶段执行回调</li><li>如果没有<code>setImmediate</code>回调需要执行,会等待回调被加入到队列中并立即执行回调,同样会设置一个超时时间防止一直等待下去</li></ol></li></ul><p>当然设定了timer的话且poll队列为空,则会判断是否有timer超时,如果有的话会回到timer阶段执行回调</p><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>check阶段执行<code>setImmediate</code></p><h3 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h3><p>close callbacks阶段close事件</p><p>有些情况下,定时器的执行顺序其实是<strong>随机</strong>的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说,<code>setTimeout</code>可能执行在前,也可能执行在后</p><ul><li>首先<code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>,这是由源码决定的</li><li>进入事件循环也是需要成本的,如果在准备时候花费了大于1ms的时间,那么在timer阶段就会直接执行<code>setTimeout</code>回调</li><li>如果准备时间花费小于1ms,那么就是<code>setImmediate</code>回调先执行</li></ul><p>当然在某些情况下,它们的执行顺序一定是固定的,比如如下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(_filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述代码中,<code>setImmediate</code>永远<strong>先执行</strong>。因为两个代码写在IO回调中,IO回调是在poll阶段执行的,当回调执行完毕后队列为空,发现存在<code>setImmediate</code>回调,所有就直接跳转到check阶段去执行回调</p><p>对于microtask来说,它会在以上每个阶段完成前<strong>清空</strong>microtask队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说,其实和浏览器中的输出结果一样,microtask永远执行在macrotask前。</p><p>最后讲讲Node中的<code>process.nextTick</code>,这个函数其实是独立于Event Loop之外的,它有一个自己的队列,当每个阶段完成后,如果存在<code>nextTick队列</code>,就会<strong>清空队列中的所有回调函数</strong>,并且优先于其他microtask执行</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写Promise</title>
      <link href="2021/02/19/shou-xie-promise/"/>
      <url>2021/02/19/shou-xie-promise/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// 初始值</span></span><br><span class="line">  <span class="keyword">const</span> RESOLVED = <span class="string">&#x27;resolved&#x27;</span> <span class="comment">// 成功时</span></span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span> <span class="comment">// 失败时</span></span><br><span class="line">  <span class="comment">// 构造函数Promise,传递一个构造器函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">excutor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    self.status = PENDING <span class="comment">// 初始状态为pending,用于存放状态的属性</span></span><br><span class="line">    self.data = <span class="literal">undefined</span> <span class="comment">// 用于存储结果数据的属性</span></span><br><span class="line">    self.callbacks = [] <span class="comment">// 用于保存回调函数(&#123;onResolved(), onRejected()&#125;)</span></span><br><span class="line">    <span class="comment">// 函数resolve,指定成功的value</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前状态不为pending,直接退出执行</span></span><br><span class="line">      <span class="keyword">if</span>(self.status !== PENDING) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 将状态由pending ==&gt; resolved</span></span><br><span class="line">      self.status = RESOLVED</span><br><span class="line">      <span class="comment">// 将value数据存储到data中</span></span><br><span class="line">      self.data = value</span><br><span class="line">      <span class="comment">// 如果callbacks有值,异步执行onResolved回调函数</span></span><br><span class="line">      <span class="keyword">if</span>(self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          self.callbacks.forEach(<span class="function"><span class="params">cbsObj</span> =&gt;</span> &#123;</span><br><span class="line">            cbsObj.onResolved(value)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数reject,指定失败的reason</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前状态不为pending,直接退出执行</span></span><br><span class="line">      <span class="keyword">if</span>(self.status !== PENDING) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 将状态由pending ==&gt; rejected</span></span><br><span class="line">      self.status = REJECTED</span><br><span class="line">      <span class="comment">// 将reason数据存储到data中</span></span><br><span class="line">      self.data = reason</span><br><span class="line">      <span class="comment">// 如果callbacks有值,异步执行onRejected回调函数</span></span><br><span class="line">      <span class="keyword">if</span>(self.callbacks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          self.callbacks.forEach(<span class="function"><span class="params">cbsObj</span> =&gt;</span> &#123;</span><br><span class="line">            cbsObj.onRejected(reason)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器函数立即执行,传递两个函数参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      excutor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">      <span class="comment">// 在执行器中抛出异常,调用reject函数,将pending ==&gt; rejected,结果值为error</span></span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  用于指定成功/失败回调的方法</span></span><br><span class="line"><span class="comment">  1. 如果当前promise为resolved,异步执行成功的回调函数onResolved</span></span><br><span class="line"><span class="comment">  2. 如果当前promise为rejected,异步执行失败的回调函数onRejected</span></span><br><span class="line"><span class="comment">  3. 如果当前promises为pending,保存回调函数</span></span><br><span class="line"><span class="comment">  返回一个新的promise</span></span><br><span class="line"><span class="comment">    他的结果状态由onResolved和onRejected执行的结果决定</span></span><br><span class="line"><span class="comment">      1. 抛出error ==&gt; 状态变为rejected,结果值为error</span></span><br><span class="line"><span class="comment">      2. 返回值不是promise ==&gt; 状态变为resolved,结果值为返回值</span></span><br><span class="line"><span class="comment">      3. 返回的是promise ==&gt; 该promise对象的值决定新promise对象的结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将value向下传递,省略大括号return可以不写</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    <span class="comment">// 错误穿透,将reason向下传递</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装公共代码</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 回调函数执行的结果</span></span><br><span class="line">          <span class="keyword">const</span> result = callback(self.data)</span><br><span class="line">          <span class="comment">// 判断result是否为promise</span></span><br><span class="line">          <span class="keyword">if</span>(result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            result.then(</span><br><span class="line">              value =&gt; resolve(value),</span><br><span class="line">              reason =&gt; reject(reason)</span><br><span class="line">            )</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(self.status === RESOLVED) &#123;</span><br><span class="line">        <span class="comment">// 开启异步任务</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          handle(onResolved)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(self.status === REJECTED) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          handle(onRejected)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        self.callbacks.push(&#123;</span><br><span class="line">          <span class="function"><span class="title">onResolved</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            handle(onResolved)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="title">onRejected</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            handle(onRejected)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于指定失败回调函数的方法</span></span><br><span class="line">  <span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个指定成功value的promise</span></span><br><span class="line">  <span class="comment">// 返回值可能是promise也可能是一般值</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        value.then(</span><br><span class="line">          val =&gt; resolve(val),</span><br><span class="line">          reason =&gt; reject(reason)</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个指定失败reason的promise</span></span><br><span class="line">  <span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新的promise,传递一个包含多个promise对象的数组,只有当所有promise都成功则成功,否则失败</span></span><br><span class="line">  <span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 记录成功promise的个数</span></span><br><span class="line">    <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length) <span class="comment">// 记录成功promise的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">p, index</span>) =&gt;</span> &#123;</span><br><span class="line">        p.then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            count++ <span class="comment">// 每成功一次,count就加1</span></span><br><span class="line">            values[index] = value <span class="comment">// 根据下标存储每一项的值</span></span><br><span class="line">            <span class="comment">// 如果count等于promises数组的长度,说明全部成功</span></span><br><span class="line">            <span class="keyword">if</span>(count === promises.length) &#123;</span><br><span class="line">              resolve(values)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason =&gt; reject(reason)</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新的promise,传递一个包含多个promise对象的数组,第一个完成的promise的结果决定最终结果</span></span><br><span class="line">  <span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">        p.then(</span><br><span class="line">          value =&gt; resolve(value),</span><br><span class="line">          reason =&gt; reject(reason)</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露Promise</span></span><br><span class="line">  <span class="built_in">window</span>.Promise = <span class="built_in">Promise</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS异步编程知识点整理</title>
      <link href="2021/02/17/js-yi-bu-bian-cheng-zhi-shi-dian/"/>
      <url>2021/02/17/js-yi-bu-bian-cheng-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="并发和并行区别"><a href="#并发和并行区别" class="headerlink" title="并发和并行区别"></a>并发和并行区别</h2><blockquote><p>并发与并行的区别?</p></blockquote><ol><li><p><code>并发</code>是宏观概念,分别有任务A和任务B,在一段时间内<code>通过任务间的切换</code>完成了这两个任务,这种情况称之为并发</p></li><li><p><code>并行</code>是微观概念,假设CPU中存在两个核心,那么可以同时完成任务A、B。<code>同时完成多个任务</code>的情况称之为并行</p></li></ol><h2 id="回调函数-callback"><a href="#回调函数-callback" class="headerlink" title="回调函数(callback)"></a>回调函数(callback)</h2><blockquote><p>什么是回调函数?回调函数的缺点?如何解决回调地狱的问题?</p></blockquote><p>回调函数的三个特点</p><ul><li>函数是我定义的</li><li>我没有调用</li><li>但最终执行了</li></ul><p>回调函数的缺点</p><ul><li>容易写出回调地狱。假如多个请求存在依赖性,可能会写出以下代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">  ajax(url1, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//处理逻辑</span></span><br><span class="line">    ajax(url2, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//处理逻辑</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>不能使用<code>try...catch</code>捕获错误</li><li>不能直接<code>return</code></li></ul><p>回调地狱</p><ul><li>回调地狱是回调函数嵌套调用,外部回调函数异步执行的结果是嵌套回调函数执行的条件</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>Promise的特点是什么,分别有什么优缺点?什么是promise链?Promise构造函数执行和then函数执行有什么区别?</p></blockquote><ol><li>具体表达<ul><li>语法上: Promise是一个构造函数</li><li>功能上: prmise对象用来封装异步操作并恶意获取成功/失败的结果值</li></ul></li><li>promise的三种状态<ul><li>pending状态: 未确定的/初始的</li><li>resolved状态: 成功时,调用resolve()后的状态</li><li>rejected状态: 失败时,调用reject()后的状态</li><li>成功的结果一般为value,失败的结果一般为reason</li><li>抛出异常: pending ==&gt; rejected,返回一个一般值: pending ==&gt; resolved</li><li><strong>状态只能改变一次,由pending变成其他状态后就不再改变</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolv(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  <span class="comment">// 无效</span></span><br><span class="line">  reject(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li>Promise的优缺点<ul><li>优点:<ol><li>调用回调函数的方式更灵活,可以在请求发出甚至结束后指定回调函数</li><li>支持链式调用,可以解决回调地域问题</li></ol></li></ul></li></ol><ul><li>缺点:<ol><li>无法取消Promise</li><li>错误需要通过回调函数捕获(.then()/.catch())</li></ol></li></ul><ol start="4"><li>使用prmise封装ajax请求函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAjax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用xhr发送异步ajax请求</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">    xhr.send()</span><br><span class="line">    xhr.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果请求未完成,直接结束</span></span><br><span class="line">      <span class="keyword">if</span>(xhr.readyState !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 如果成功,调用resolve(),并指定成功的value</span></span><br><span class="line">      <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果失败,调用reject(),并指定失败的reason</span></span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请求失败&#x27;</span> + xhr.status))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>promise基本流程图解<br><a href="https://imgchr.com/i/yWq8OK"><img src="https://s3.ax1x.com/2021/02/18/yWq8OK.png" alt="yWq8OK.png"></a></li><li>Promise构造函数: Promise(excutor) {}<ul><li>excutor函数: 同步执行(resolve, reject) =&gt; {}</li><li>resolve()函数: 内部定义成功时调用的函数</li><li>reject()函数: 内部定义失败时调用的函数</li><li><strong>excutor会在Promise内部立即执行同步回调,异步操作在执行器中执行</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;222&#x27;</span>)</span><br><span class="line"><span class="comment">// 先打印111再打印222</span></span><br></pre></td></tr></table></figure></li></ul></li><li>Promise.prototype.then方法: (onResolved, onRejected) =&gt; {}<ul><li>onResolved函数: 成功的回调函数 value =&gt; {}</li><li>onRejected函数: 失败的回调函数 reason =&gt; {}</li><li><strong>指定用于得到成功value的成功回调和用于得到失败reason的失败回调返回一个新的promise对象</strong></li></ul></li><li>Promise.prototype.catch方法: (onRejected) =&gt; {}<ul><li><strong>用于得到失败reason的失败回调</strong></li></ul></li><li>Promise.prototype.finally方法: () =&gt; {}<ul><li><strong>表示无论是fulfilled还是rejected状态最终都会被执行的代码,finally方法不接受参数,一般可以做一些loading的关闭等</strong></li></ul></li><li>Promise.all()方法: (promises) =&gt; {}<ul><li>promises: 包含n个promise的数组</li><li><strong>返回一个新的promise,只有所有的promise都成功才成功,只要有一个失败则直接失败</strong></li></ul></li><li>Promise.race()方法: (promises) =&gt; {}</li></ol><ul><li>promises: 包含n个promise的数组</li><li><strong>返回一个新的promise,第一个完成的promise的结果状态决定最终的结果状态</strong></li></ul><ol start="11"><li>Promise.any()方法: (promises) =&gt; {}</li></ol><ul><li>promises: 包含n个promise的数组</li><li><strong>any方法会等到一个fulfilled状态,才会决定新Promise的状态</strong>;</li><li><strong>如果所有的Promise都是reject,那么也会等到所有的Promise都变成rejected状态</strong>;</li><li>如果所有的Promise都是reject,那么会报一个aggregateError的错误。</li></ul><ol start="12"><li>promise.then()返回的新promise的结果由什么决定</li></ol><ul><li>由then()指定的回调函数执行的结果决定</li><li>如果<code>抛出异常</code>,新promise的状态变为<code>rejected</code>,<code>reason</code>为抛出异常的值</li><li>如果返回的是<code>非promise的任意值</code>,新promise的状态变为<code>resolved</code>,<code>value</code>为返回的值</li><li>如果返回的是<code>新的promise</code>,当前promise的结果就会成为新promise的结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="number">2</span></span><br><span class="line">  &#125;, </span><br><span class="line">  reason =&gt; <span class="built_in">console</span>.log(reason)</span><br><span class="line">).then(</span><br><span class="line">  value =&gt; <span class="built_in">console</span>.log(value),</span><br><span class="line">  reason =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value =&gt; <span class="built_in">console</span>.log(value),<span class="comment">// 3</span></span><br><span class="line">  reason =&gt; <span class="built_in">console</span>.log(reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><ol start="13"><li>promise错误穿透</li></ol><ul><li>原理相当于在每个then()中抛出一个失败的回调,一层层向下传递(<code>reason =&gt; &#123;throw reason&#125;</code>)</li><li>当使用promise的链式调用时,可在最后指定失败的回调接收错误<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>前面任何操作出现问题,都会传到最后的失败回调中处理</li></ul><ol start="14"><li>中断promise链</li></ol><ul><li>在<code>回调函数</code>中返回一个pending状态的promise对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2></li></ul><blockquote><p>async和await的特点,优点和缺点分别是什么?<br>await原理是什么?</p></blockquote><p>一个函数如果加上<code>async</code>,那么该函数就会返回一个<code>Promise</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()) <span class="comment">// -&gt; Promise&#123;&lt;resolved: 1&gt;&#125;</span></span><br></pre></td></tr></table></figure><p><code>async</code>就是将函数返回值使用<code>Promise.resolve()</code>包裹,和<code>then</code>中处理返回值一样</p><p><code>await</code>表达式</p><ul><li><code>await</code>右侧的表达式一般为promise对象,但也可以是其他值</li><li>如果表达式是promise对象,<code>await</code>返回的是promise成功的值</li><li>如果表达式是其他值,直接将此值作为<code>await</code>的返回值</li></ul><p>注意点</p><ul><li><strong>async函数会立即执行结束,不会阻塞代码执行</strong></li><li><code>await</code>必须写在<code>async</code>函数中,但<code>async</code>函数中可以没有<code>await</code></li><li>如果<code>await</code>的promise失败了,就会抛出异常,需要通过<code>try...catch</code>来捕获处理</li></ul><p><code>async</code>和<code>await</code>可以说是异步终极解决方案,相比直接使用<code>Promise</code>来说,<code>优势</code>在于处理<code>then</code>的链式调用,能够更加清晰准确的写出代码,并且可以优雅的解决回调地狱问题,<code>缺点</code>在于,因为<code>await</code>将异步代码改造成同步代码,如果多个异步代码没有依赖性却使用了<code>await</code>会导致性能上的降低</p><p><code>await</code>就是<code>generator</code>加上<code>Promise</code>的语法糖,且内部实现了自动执行<code>generator</code></p><h2 id="常用的定时器函数"><a href="#常用的定时器函数" class="headerlink" title="常用的定时器函数"></a>常用的定时器函数</h2><blockquote><p>setTimeout、setInterval、requestAnimationFrame各有什么特点?</p></blockquote><p><code>setTimeout</code>一般是延时多久,就在多久后执行。但是JS是单线程执行,如果定时器之前有影响性能的代码,<code>setTimeout</code>就不会按期完成</p><p><code>setInterval</code>这个函数作用和<code>setTimeout</code>基本一致,只是该函数是每隔一段时间执行一次回调函数</p><p>一般来说不建议使用<code>setInterval</code>。它和<code>setTimeout</code>一样,不能保证在预期的时间执行任务。<br>其次,它存在执行累积的问题,如果定时器执行过程中出现了耗时操作,多个回调函数会在耗时操作结束后同时执行,可能会带来性能上的问题</p><p><code>requestAnimationFrame</code>自带函数节流功能,基本可以保证在16.6ms内只执行一次,并且该函数的延时效果是精确的,没有其他定时器时间不准的问题</p><ol><li><p>window.requestAnimationFrame(callback)</p><ul><li>该方法会告诉浏览器在下一次重绘重排之前调用所指定的函数</li><li>参数: 该方法使用一个回调函数作为参数,这个回调函数会在浏览器下次重绘之前调用</li><li>返回值: 用法和定时器的标识名差不多</li></ul></li><li><p>window.cancelAnimationFrame(requestID)</p><ul><li>取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求</li><li>requestID为调用window.requestAnimationFrame()方法的返回值</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6知识点整理</title>
      <link href="2021/02/15/es6-zhi-shi-dian/"/>
      <url>2021/02/15/es6-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="var、let以及const的区别"><a href="#var、let以及const的区别" class="headerlink" title="var、let以及const的区别"></a>var、let以及const的区别</h2><blockquote><p>什么是提升?什么是暂时性死区?var、let以及const的区别?</p></blockquote><p>什么是提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>从上述代码可以发现,虽然变量没有被声明,但却可以使用这个未被声明的变量,这种情况叫做提升,并且提升的是声明</p><p>可以将代码这样来看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>不仅var声明的变量会提升,函数声明也会被提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// f a() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>变量提升&amp;函数提升总结</p><ul><li>找到var后将var后面的变量提前声明,<strong>但不赋值</strong></li><li>找到function后定义对应的函数,<strong>函数在预解析的时候已经定义完毕</strong></li><li>注意: <strong>函数提升的优先级要高于变量提升</strong>,如果函数已经存在就会忽略跳过</li></ul><p>let和const</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>首先在全局作用域下使用<code>let</code>和<code>const</code>声明变量,变量不会挂在到<code>window</code>上</p><p>其次当我们在声明<code>a</code>之前如果使用了<code>a</code>,就会出现报错的情况<br><a href="https://imgchr.com/i/y6Tqk6"><img src="https://s3.ax1x.com/2021/02/15/y6Tqk6.png" alt="y6Tqk6.png"></a></p><p>报错的原因是因为存在暂时性死区,不能在<code>let</code>和<code>const</code>声明前就使用变量,这也是<code>let</code>和<code>const</code>优于<code>var</code>的一点</p><p>let&amp;const</p><ol><li>let使用及特点<ul><li>块级作用域声明</li><li>let变量不允许重复定义</li><li>变量提升:<ol><li>全局变量提升: 会创建一个变量对象(<code>script</code>)来收集全局作用域下的let定义的变量,但没有赋值</li><li>局部变量提升: 会将var、let定义的变量全部放在当前函数的变量对象中</li><li>和var变量提升的区别: let提升的变量在未赋值前不允许被使用</li></ol></li></ul></li><li>const使用及特点<ul><li>块级作用域声明常量</li><li>const定义的常量必须赋值,且不能再被更改</li></ul></li></ol><p>总结:</p><ul><li>函数提升优先于变量提升,函数提升会把整个函数挪到作用域顶部,变量提升只会把声明挪到作用于顶部</li><li><code>var</code>存在提升,我们能在声明之前使用。<code>let</code>、<code>const</code>因为暂时性死区的原因,不能在声明前使用</li><li><code>var</code>在全局作用域下声明变量会挂载到window上,其他两个不会</li></ul><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><blockquote><p>原型如何实现继承?</p></blockquote><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 父类的方法在子类中执行,如果直接调用,会导致window对象上添加了不必要的属性</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让子类的原型成为父类的实例,这样子类的实例就可以访问到父类原型上的方法了</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">child.getAll() <span class="comment">// &#x27;wbw&#x27;, 23</span></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该继承的方式核心是在子类的构造函数中通过<code>Person.call(this)</code>继承父类的属性,通过<code>Child.prototype = new Person()</code>改变Child的原型为父类的实例来继承父类的方法。</p><p>这种继承方式<code>优点</code>在于构造函数可以传参,不会与父类引用属性共享,可以复用父类的函数,<code>缺点</code>是继承父类函数的时候调用了父类构造函数,导致子类的原型上多了不需要的属性,存在内存上的浪费</p><p><a href="https://imgchr.com/i/ygEOYV"><img src="https://s3.ax1x.com/2021/02/16/ygEOYV.png" alt="ygEOYV.png"></a></p><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">Child, Person</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个新的对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">  <span class="comment">// 重写对象会导致constructor丢失问题</span></span><br><span class="line">  prototype.constructor = Child;</span><br><span class="line">  <span class="comment">// 将父类的原型副本赋值给子类的原型</span></span><br><span class="line">  Child.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">init(Child, Person);</span><br><span class="line">Child.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">&#x27;wbw&#x27;</span>, <span class="number">23</span>);</span><br><span class="line">child.sayName(); <span class="comment">// wbw</span></span><br><span class="line">child.sayAge(); <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该继承实现的核心是<code>将父类的原型赋值给了子类</code>,并将<code>构造函数设置为子类</code>,这样解决了无用的父类属性问题,还能正确找到子类的构造函数</p><p><a href="https://imgchr.com/i/ygEvSU"><img src="https://s3.ax1x.com/2021/02/16/ygEvSU.png" alt="ygEvSU.png"></a></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>为什么要使用模块化?都有哪几种方式可以实现模块化?各有什么特点?</p></blockquote><p>模块化带来的好处:</p><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>通过函数作用域解决命名冲突、污染全局作用域的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">variable</span>) </span>&#123;</span><br><span class="line">  variable.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 声明各种变量、函数都不会污染全局作用域</span></span><br><span class="line">&#125;)(variable)</span><br></pre></td></tr></table></figure><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>代理使用<code>Proxy</code>构造函数创建。这个构造函数接收两个参数: <strong>目标对象和处理程序对象</strong>。缺少任何一个参数都会抛出TypeError。要创建空代理,可以传一个简单的对象字面量作为处理程序对象,让所有操作畅通无阻的抵达目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&quot;target&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// 1. id属性会访问同一个值</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// proxy</span></span><br><span class="line"><span class="comment">// 2. 给目标赋值会反映到两个对象上,因为两个对象访问的都是同一个值</span></span><br><span class="line">target.id = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 3. 给代理对象赋值会反映到两个对象上,因为这个赋值会转移到目标对象</span></span><br><span class="line">proxy.id = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// bar</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 4. Proxy.prototype为undefined,所以不能通过instanceof判断,会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(target <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>); <span class="comment">//TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"><span class="comment">// 5. 严格模式可以区分代理和目标对象</span></span><br><span class="line"><span class="built_in">console</span>.log(target === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h3><p>使用代理的主要目的是可以定义<code>捕获器</code>。捕获器就是在处理程序对象中定义的<code>基本操作的拦截器</code>。每个<code>处理程序对象</code>可以有零个或多个捕获器,每个捕获器对应一个基本操作,可以直接或间接的在<code>代理对象上</code>调用。每次在<code>代理对象上</code>调用这些基本操作时,代理可以在这些操作传播到<code>目标对象</code>之前先调用捕获器函数取拦截并修改对应的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理程序对象</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 定义一个捕获器</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target[<span class="string">&#x27;id&#x27;</span>]); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy[<span class="string">&#x27;id&#x27;</span>]); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>如上可知,所有的操作只要发生在<code>代理对象</code>上,就会触发捕获器函数。在<code>目标对象</code>上执行这些操作仍然会产生正常行为。</p><h3 id="捕获器参数和反射API"><a href="#捕获器参数和反射API" class="headerlink" title="捕获器参数和反射API"></a>捕获器参数和反射API</h3><p>所有捕获器都可以访问相应的参数,基于这些参数可以重建被捕获方法的原始行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 三个参数分别为: 目标对象、要查询的属性和代理对象</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">targets, property, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(targets === target);</span><br><span class="line">    <span class="built_in">console</span>.log(property);</span><br><span class="line">    <span class="built_in">console</span>.log(receiver === proxy);</span><br><span class="line">    <span class="comment">// 重建被捕获方法的原始行为</span></span><br><span class="line">    <span class="keyword">return</span> targets[property];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.id; <span class="comment">// true target true</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// target</span></span><br></pre></td></tr></table></figure><p><code>处理程序对象</code>上所有可以捕获的方法都有对应的<code>反射(Reflect)API</code>方法。这些方法和捕获器拦截的方法有相同的名称和函数签名,并具有与被拦截方法相同的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="comment">// 第一种写法</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二种写法</span></span><br><span class="line">  get: <span class="built_in">Reflect</span>.get</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// target</span></span><br></pre></td></tr></table></figure><h3 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h3><p>Proxy暴露了<code>revocable()</code>方法,这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是<code>不可逆的</code>。撤销代理之后在调用代理会抛出<code>TypeError</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;good&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// good</span></span><br><span class="line"><span class="built_in">console</span>.log(target.id); <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line"><span class="built_in">console</span>.log(proxy.id); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="实用反射API"><a href="#实用反射API" class="headerlink" title="实用反射API"></a>实用反射API</h3><ol><li>反射API和对象API</li></ol><ul><li><code>反射API</code>并不限于捕获处理程序;</li><li>大多数<code>反射API</code>方法在Object类型上有对象的方法。</li><li><strong>通常,Object上的方法适用于通用程序,而反射方法适用于细粒度的对象控制与操作</strong></li></ul><ol start="2"><li><p>状态标记</p><p>很多反射方法返回称作<code>状态标记</code>的布尔值,表示意图执行的操作是否成功。</p></li></ol><ul><li>以下方法都会提供状态标记:<ol><li><code>Reflect.defineProperty()</code></li><li><code>Reflect.preventExtensions()</code></li><li><code>Reflect.setPrototypeOf()</code></li><li><code>Reflect.set()</code></li><li><code>Reflect.deleteProperty()</code></li></ol></li></ul><ol start="3"><li>以下反射方法提供只有通过操作符才能完成的操作</li></ol><ul><li>Reflect.get(): 可以替代对象属性访问操作符。</li><li>Reflect.set(): 可以替代=赋值操作符</li><li>Reflect.has(): 可以替代in操作符或with()。</li><li>Reflect.deleteProperty(): 可以替代delete操作符。</li><li>Reflect.construct(): 可以替代new操作符。</li></ul><h3 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h3><p>代理可以拦截反射API的操作,意味着可以创建一个代理,通过它去代理另一个代理。这样可以在一个目标对象上构建多层拦截网。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  id: <span class="string">&#x27;target&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;first proxy&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> Proxt(firstProxy, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;second proxy&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(secondProxy.id);</span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// target</span></span><br></pre></td></tr></table></figure><h3 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h3><h2 id="map-filter-reduce"><a href="#map-filter-reduce" class="headerlink" title="map,filter,reduce"></a>map,filter,reduce</h2><blockquote><p>map,filter,reduce各有什么作用?</p></blockquote><p><code>map</code>返回一个新的数组,数组中的元素为原始数组调用函数处理后的值(不会对空数组进行检测)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.map(value = value + <span class="number">1</span>) <span class="comment">// ==&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>map语法: map((item, index, arr) =&gt; {}),回调函数接收三个参数,分别是<code>当前索引元素</code>,<code>索引</code>,<code>原数组</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].map(<span class="built_in">parseInt</span>)</span><br></pre></td></tr></table></figure><ul><li>第一轮遍历<code>parseInt(&#39;1,&#39; 0) -&gt; 1</code></li><li>第二轮遍历<code>parseInt(&#39;2&#39;, 1) -&gt; NaN</code></li><li>第三轮遍历<code>parseInt(&#39;3&#39;, 2) -&gt; NaN</code></li></ul><p><code>filter</code>返回一个新的数组,在遍历数组的时候将返回值为true的元素放入新数组中,可以利用这个函数删除一些不需要的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure><p>filter语法: filter((item, index, arr) =&gt; {}),回调函数接收三个参数,分别是<code>当前索引元素</code>,<code>索引</code>,<code>原数组</code></p><p><code>reduce</code>接收一个函数作为累加器,数组中的每个值从左到右开始递减,最终计算为一个值并返回</p><p>如果想实现一个功能将函数里的元素全部相加得到一个值,可以这样写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  total += arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(total) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>如果使用<code>reduce</code>的话就可以将遍历部分代码优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">total, currentVal</span>) =&gt;</span> total + currentVal, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>语法: reduce((total, currentVal, currentIndex, arr) =&gt; {}, init),<strong>其中total为初始值或计算结束后的返回值;init为传递给函数的初始值(如果提供了init,total取值为init,currentVal;如果没有提供init,那么total去数组中的第一个值,currentVal取数组中第二个值)</strong></p><p>对于reduce来讲,它接收两个参数,分别是回调函数和初始值,接下来分解上述代码中<code>reduce</code>的过程</p><ul><li><p>首先初始值为<code>0</code>,该值会在执行第一次回调函数时作为第一个参数传入</p></li><li><p>回调函数接收四个参数,分别为<code>累加器</code>,<code>当前元素</code>,<code>当前索引</code>和<code>原数组</code></p></li><li><p>在第一次执行回调函数时,当前值和初始值相加得出结果<code>1</code>,该结果会在第二次执行回调函数当作第一个参数传入</p></li><li><p>在第二次执行回调函数时,相加的值就分别是<code>1</code>和<code>2</code>,以此类推,所以最终结果为<code>6</code>并返回</p><p>通过<code>reduce</code>来实现<code>map</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> mapArr = arr.map(<span class="function"><span class="params">itemVal</span> =&gt;</span> itemVal * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> reduceArr = arr.reduce(<span class="function">(<span class="params">total, currentVal</span>) =&gt;</span> &#123;</span><br><span class="line">  total.push(currentVal * <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> total <span class="comment">// 返回结果</span></span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(mapArr, reduceArr) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h2 id="some-和every-方法"><a href="#some-和every-方法" class="headerlink" title="some()和every()方法"></a>some()和every()方法</h2></li></ul><ol><li><code>some()</code>: 用于检测数组中<code>至少有一个或以上</code>的元素符合指定条件。不改变原数组,满足返回true,不满足返回false。</li><li><code>every()</code>: 用于检测数组中<code>所有</code>的元素是否都符合指定条件。不改变原数组,满足返回true,不满足返回false。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识点整理(二)</title>
      <link href="2021/02/08/js-ji-chu-zhi-shi-er/"/>
      <url>2021/02/08/js-ji-chu-zhi-shi-er/</url>
      
        <content type="html"><![CDATA[<h2 id="vs"><a href="#vs" class="headerlink" title="== vs ==="></a>== vs ===</h2><blockquote><p>== 和 === 有什么区别?</p></blockquote><ol><li>对于<code>==</code>来说,如果对比双方的类型<strong>不一样</strong>的话,就会进行<strong>类型转换</strong>,</li></ol><ul><li>假如需要对比x和y是否相同,就会进行如下判断<ol><li>首先会判断两者类型是否相同。相同的话就比较大小</li><li>类型不相同的话,那么就会进行类型转换</li><li>会先判断是否在对比<code>null</code>和<code>undefined</code>,是的话就会返回<code>true</code></li><li>判断两者类型是否为<code>string</code>和<code>number</code>,是的话就会将字符串转换为<code>number类型</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span> <span class="comment">// ==&gt; 1 == 1</span></span><br></pre></td></tr></table></figure></li><li>判断其中一方是否为<code>Boolean</code>,是的话就会把<code>Boolean</code>转为<code>number</code>再进行判断<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span> <span class="comment">// ==&gt; 第一步 &#x27;1&#x27; == 1 ==&gt; 第二步 1 == 1 </span></span><br></pre></td></tr></table></figure></li><li>判断其中一方是否为<code>object</code>且另一方为<code>string</code>、<code>number</code>或者<code>symbol</code>,是的话就会把<code>object</code>转为原始类型再进行判断<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == &#123;<span class="attr">name</span>: <span class="string">&#x27;wbw&#x27;</span>&#125; <span class="comment">// ==&gt; &#x27;1&#x27; == &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li>流程图:<br><a href="https://imgchr.com/i/y0wCfs"><img src="https://s3.ax1x.com/2021/02/10/y0wCfs.md.png" alt="y0wCfs.md.png"></a></li></ol><blockquote><p>对于[] == ![]的答案是什么?</p></blockquote><ul><li>根据运算符优先级: !的优先级是大于==的,所有会先执行![]</li><li>![]会先转换为boolean值,为false.相当于: [] == false</li><li>根据规则来看,boolean值会转换为number, 相当于: [] == 0</li><li>根据规则来看,如果一方为object另一方为string、number、symbol会将object转换为原始类型再判断,所以[]会通过.toString()方法转换为<code>&quot;&quot;</code>,相当于: “” == 0</li><li>根据规则来看,string类型会转换为number类型,相当于: 0 == 0</li><li>所以最终结果为<code>true</code></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>什么是闭包?</p></blockquote><ol><li><p>闭包的形成</p><ul><li>两个函数嵌套关系</li><li>内部函数可以访问外部函数的局部变量</li><li>使用内部函数(注意: 函数变量提升的时候如果内部函数没有被使用,在预解析的过程中就不会定义内部函数)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包的简单实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = A()</span><br><span class="line">b()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>什么是闭包?</p><ul><li>闭包是一个存在内部函数的引用关系</li><li>该引用指向的是外部函数的局部变量对象(前提是内部函数使用了外部函数的局部变量)</li></ul></li><li><p>闭包的作用</p><ul><li>延长外部函数的变量对象的生命周期</li><li>使用闭包能够间接从函数外部访问函数内部的私有变量</li></ul></li><li><p>使用闭包的注意点</p><ul><li>及时清除闭包,不然会造成内存泄露溢出(让内部函数成为垃圾对象被回收机制回收)</li></ul><blockquote><p>循环中使用闭包解决<code>var</code>定义函数的问题</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法1,使用闭包的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法2,使用let关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2></li></ol><blockquote><p>什么是浅拷贝?如何实现浅拷贝?什么是深拷贝?如何实现深拷贝?</p></blockquote><p>对象类型在赋值的过程中其实是复制了地址,从而导致改变了一方其他也都被改变的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>首先可以通过<code>Object.assign</code>来解决,<code>Object.assign</code>只会拷贝所有的属性值到新的对象中,如果属性值是对象或数组的话,拷贝的是地址,所以该方法为浅拷贝。</p><ul><li>语法: Object.assign(目标对象, 源对象…)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Object</span>.assign(b, a)</span><br><span class="line">a.age = <span class="number">23</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// &#123;age: 18&#125;</span></span><br></pre></td></tr></table></figure><p>还可以通过展开运算符<code>...</code>来实现浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但是浅拷贝只能解决第一层的问题,如果接下去的值中还有对象的话,两者享有相同的地址,那么<code>Object.assign</code>就解决不了了,需要用到<code>深拷贝</code>。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>可以通过<code>JSON.parse(JSON.stringify(object))</code>解决</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  job: &#123;</span><br><span class="line">    first: <span class="string">&#x27;student&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.job[first] = <span class="string">&#x27;Web&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.job.first) <span class="comment">// student</span></span><br></pre></td></tr></table></figure><p>该方法的局限性: </p><ul><li>会忽略undefined</li><li>会忽略symbol</li><li>不能序列化函数</li></ul><p><strong>实现简单的深拷贝</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkoutType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用对象原型上的方法toString,利用call将this指向改变,得到[xxx Xxx]最后使用slice截取字符串(例如: [object Object] ==&gt; Object)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义深克隆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">let</span> targetType = checkoutType(target)</span><br><span class="line">  <span class="comment">// 判断数据类型是Array、Object或其他(基本数据类型或函数)</span></span><br><span class="line">  <span class="keyword">if</span>(targetType === <span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">    result = []</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(targetType === <span class="string">&#x27;Object&#x27;</span>) &#123;</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果是其他类型,不做处理直接返回target</span></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过for...in...遍历数组或对象,for...of无法遍历对象</span></span><br><span class="line">  <span class="comment">// for...in遍历拿到的是属性名,for...of遍历拿到的是属性值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">// 得到数组或对象每一项的值</span></span><br><span class="line">    <span class="keyword">let</span> value = target[item]</span><br><span class="line">    <span class="comment">// 如果数组或对象内部嵌套引用数据类型,需要继续处理</span></span><br><span class="line">    <span class="keyword">if</span>(checkoutType(value) === <span class="string">&#x27;Array&#x27;</span> || <span class="string">&#x27;Object&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 递归方式</span></span><br><span class="line">      result[item] = deepClone(value)</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      result[item] = value <span class="comment">// 基本数据类型赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><blockquote><p>如何理解原型?如何理解原型链?</p></blockquote><h3 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h3><ol><li>每个<code>构造函数</code>都有一个<code>prototype属性</code>,该属性指向的是该构造函数的<code>原型对象</code>(显示原型对象,可以直接操作)</li><li><code>原型对象</code>上有一个<code>constructor属性</code>,该属性指回<code>构造函数</code></li><li>每个<code>实例对象</code>身上都有一个<code>__proto__</code>,该属性指向的也是<code>原型对象</code>(隐式原型对象,ES6之前不能直接操作)</li><li><code>构造函数</code>的显示原型对象 === 当前<code>构造函数</code>的实例对象的隐式原型对象</li><li>给<code>原型对象</code>添加方法/属性时,函数的<code>实例对象</code>自动拥有原型上的属性/方法(<strong>原型对象的作用,避免重复代码节省内存空间</strong>)</li><li><strong>所有的原型都是Object的实例</strong></li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol><li>查找对象的属性/方法的时候先在自身查找,如果没有,沿着__proto__找原型对象</li><li>如果原型对象上还没有,会继续沿着原型对象属性__proto__向上查找,直到找到Object的原型对象</li><li>如果还没有找到最终指向null,返回undefined</li><li>总结: <strong>沿着__proto__查找的这条链就是原型链</strong></li></ol><p>通过图解深入理解原型和原型链<br><a href="https://imgchr.com/i/y6hltg"><img src="https://s3.ax1x.com/2021/02/15/y6hltg.png" alt="y6hltg.png"></a></p><h2 id="补充原型"><a href="#补充原型" class="headerlink" title="补充原型"></a>补充原型</h2><ol><li>同一个构造函数创建的两个实例对象共享同一个原型对象</li></ol><p><a href="https://imgtu.com/i/gynjfK"><img src="https://z3.ax1x.com/2021/05/14/gynjfK.png" alt="gynjfK.png"></a></p><ol start="2"><li><p>Object类型有一个方法<code>Object.getPrototypeOf()</code>,返回参数的内部特性<code>[[Prototype]]</code>,返回给定对象的原型,如果没有继承属性,返回<code>null</code></p></li><li><p>Object类型还有一个<code>setPrototypeOf()</code>方法,可以向实例的私有特性<code>[[Prototype]]</code>写入一个<br>新值。但是Object.setPrototypeOf()可能会严重影响代码性能。为了避免这一情况,可以通过<br>Object.create()来创建一个新对象,同时为其指定原型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  num: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person = <span class="built_in">Object</span>.create(obj);</span><br><span class="line">person.name = <span class="string">&quot;bowen&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// bowen</span></span><br><span class="line"><span class="built_in">console</span>.log(person.num); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>只要给对象实例添加一个属性,这个属性就会遮蔽原型对象上的同名属性,因为原型链查找规则总会从自身出发,如果自身没有该属性才会在原型上查找。可以通过<code>delete</code>操作符删除实例上的属性解决。</p></li><li><p>调用<code>hasOwnProperty()</code>能够判断访问的是实例对象还是原型的属性。只有在实例上的属性才会返回<code>true</code>。</p></li><li><p>原型和in操作符</p></li></ol><ul><li>两种方式使用in操作符: 单独使用和在for-in循环使用。<ol><li>单独使用<code>in操作符</code>会在可以通过对象访问指定属性时返回<code>true</code>,无论该属性在实例上还是原型上。如果想确定某个属性是否存在于原型上,可以同时使用<code>hasOwnProperty()</code>和<code>in操作符</code>。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object为实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasProperty</span>(<span class="params">object, name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 前面判断name不在实例对象上,后面的判断确定name属性在原型上</span></span><br><span class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<code>for-in</code>循环中使用in操作符时,可以通过对象访问且可以被枚举的属性(<code>[[enumerable]]为true</code>)都会返回,包括实例和原型对象上的属性。</li></ol></li></ul><ol start="7"><li>每次定义一个属性和方法都会把Person.prototype重写一次,为了减少代码的冗余,可以这样写:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;bowen&quot;</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是这会导致Person.prototype上的constructor属性丢失,不能指回构造函数Person了。只能往上一级原型对象上找到constructor属性。</li></ol><p>可以通过<code>Object.defineProperty()</code>方法来定义constructor属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">// 设置该constructor属性为不可枚举的属性,for-in无法遍历</span></span><br><span class="line">  value: Person <span class="comment">// 使constructor指回Person构造函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="8"><li>原型和继承关系</li></ol><p>原型与实例的关系可以通过两种方式来确定</p><ul><li>使用<code>instanceof操作符</code>,用于检测构造函数的prototype是否在某个实例对象的原型链上。返回布尔值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A为实例,B为构造函数</span></span><br><span class="line">A <span class="keyword">instanceof</span> B;</span><br></pre></td></tr></table></figure></li><li>使用<code>isPrototypeOf()</code>方法。原型链中的每个原型都可以调用这个方法。只要原型链中包含这个原型,该方法就返回true。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A为实例,B为构造函数</span></span><br><span class="line">B.prototype.isPrototypeOf(A);</span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>关于方法</li></ol><ul><li>子类有时候需要覆盖父类的方法,或增加父类没有的方法。因此,<strong>这些方法必须在原型赋值之后再添加到原型上。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.prototype = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subPrototype = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.subPrototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 覆盖之前的新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(sub.getSubValue()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>以对象字面量方式创建原型方法会破坏之前的原型链,因为相当于重写了原型链。</li></ul><ol start="10"><li>原型链问题</li></ol><ul><li><p>原型中包含的引用值会在所有实例间共享,这也是为什么属性通常会在构造函数中定义而不是原型上。</p></li><li><p>子类在实例化时不能给父类的构造函数传参。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS基础知识点整理(一)</title>
      <link href="2021/02/03/js-ji-chu-zhi-shi-yi/"/>
      <url>2021/02/03/js-ji-chu-zhi-shi-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型-amp-引用数据类型"><a href="#基本数据类型-amp-引用数据类型" class="headerlink" title="基本数据类型&amp;引用数据类型"></a>基本数据类型&amp;引用数据类型</h2><blockquote><p>基本数据类型有哪几种? null是对象吗?</p></blockquote><ol><li><p>在JS中,存在着6种基本数据类型,分别是:</p><ul><li><code>Boolean</code></li><li><code>Null</code></li><li><code>undefined</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol</code></li></ul></li><li><p>基本数据类型的特征:</p><ul><li>存储的是该对象的实际数据</li><li>基本数据类型数据赋值给某一个变量之后值本身就不会再发生改变</li></ul></li><li><p>引用数据类型:</p><ul><li><code>Object</code></li><li><code>Array</code></li><li><code>Function</code></li></ul></li><li><p>引用数据类型的特征: </p><ul><li>存储的是该对象在栈中的引用(地址),真实的数据存放在堆内存中</li><li>引用数据类型的值可以通过其赋值的变量修改</li></ul></li><li><p>对于null来说,说它是个对象类型,其实是错误的。虽然<code>typeof null</code>会输出<code>object</code>,但是只是JS存在的一个悠久BUG。再JS最初版本中使用的是32位系统,为了性能考虑使用拉低存储变量的类型信息,<code>000</code>开头代表是对象,然而<code>null</code>表示为全零,所有误判为<code>object</code></p></li></ol><h2 id="对象-Object-类型"><a href="#对象-Object-类型" class="headerlink" title="对象(Object)类型"></a>对象(Object)类型</h2><blockquote><p>对象类型和原始类型的不同之处? 函数参数是对象会发生什么问题?</p></blockquote><ol><li>在JS中,除了原始类型其他的都是对象类型。对象类型和原始类型不同的是,原始类型存储的是值,对象类型存储的是地址(指针)。当创建了一个对象类型的时候,计算机会在内存中开辟一块空间存放值,但我们需要找到这个空间,这个空间会拥有一个地址(指针)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = []</span><br></pre></td></tr></table></figure>对于常量a来说,假设内存地址(指针)为<code>#001</code>,那么在地址<code>#001</code>的位置存放了值<code>[]</code>,常量<code>a</code>存放了地址(指针)<code>#001</code>,如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = []</span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line">b.push(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>将变量赋值给另外一个变量时,复制的是原本变量的地址(指针),也就是说当前变量<code>b</code>存放的地址(指针)也是<code>#001</code>,当进行数据修改的时候,就会修改存放在地址(指针)<code>#001</code>上的值,导致两个变量的值都发生了改变。</li><li>函数参数是对象的情况:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">Person</span>) </span>&#123;</span><br><span class="line">  person.age = <span class="number">23</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;wbw&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;lxd&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = test(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// -&gt; &#123;name: &#x27;lxd&#x27;, age: 23&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2) <span class="comment">// -&gt; &#123;name: &#x27;wbw&#x27;, age: 18&#125;</span></span><br></pre></td></tr></table></figure></li><li>Object实例的方法<ul><li><code>hasOwnProperty(propertyName)</code>: 用于判断当前对象实例(不是原型)是否存在给定的属性。要<code>检查的属性名必须是字符串</code>(o.hasOwnProperty(‘name’))或<code>符号</code></li><li><code>isPropertyOf(object)</code>: 用于判断当前对象是否为另一个对象的原型。</li></ul></li></ol><h2 id="参数引用传递和共享传递"><a href="#参数引用传递和共享传递" class="headerlink" title="参数引用传递和共享传递"></a>参数引用传递和共享传递</h2><ul><li>按<code>引用传递</code>是传递对象的引用,而按<code>共享传递</code>是传递对象的引用的副本！</li><li>可以理解为: 参数如果是基本类型是按值传递,如果是引用类型按共享传递。</li></ul><h2 id="typeof-vs-instanceof"><a href="#typeof-vs-instanceof" class="headerlink" title="typeof vs instanceof"></a>typeof vs instanceof</h2><blockquote><p>typeof是否能正确判断类型? instanceof能正确判断对象的原理是什么?</p></blockquote><ol><li><code>typeof</code>对于基本数据类型来说,除了<code>null</code>都可以显示正确的类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure></li><li><code>typeof</code>对于引用数据类型来说,除了函数都会显示<code>object</code>,所以<code>typeof</code>不能准确判断变量到底是什么类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure></li><li>如果想判断一个对象的正确类型,这时候可以考虑使用<code>instanceof</code>,因为内部机制是通过<code>原型链</code>来判断的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>注意: 对于基本数据类型来说,直接通过<code>instanceof</code>来判断类型是不行的</li></ol><h2 id="Symbol-符号-类型"><a href="#Symbol-符号-类型" class="headerlink" title="Symbol(符号)类型"></a>Symbol(符号)类型</h2><p>符号是原始值,且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符,不会发生属性冲突的危险。</p><p>符号是用来创建唯一记号,进而用作<code>非字符串形式</code>的对象属性</p><ol><li>符号的基本用法<ul><li>符号需要使用<code>Symbol()</code>函数初始化。因为符号本身是原始类型,所以<code>typeof</code>操作符对符号返回<code>Symbol</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sym) <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure></li><li>调用Symbol()函数时,可以传入一个<code>字符串参数</code>作为对<code>符号</code>的描述。但是这个字符串参数与符号定义或标识完全无关<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sym1 == sym2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li>符号没有<code>字面量语法</code>(例如: let obj = {})</li><li><code>Symbol()函数</code>不能与<code>new关键字</code>一起作为构造函数使用,避免创建符号包装对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure></li></ul></li><li>使用全局符号注册表<br>如果运行时的<code>不同部分</code>需要<code>共享和重用符号实例</code>,那么可以用一个字符串作为键,在全局符号注册表中创建并重用符号。需要使用<code>Symbol.for()</code>方法<br>未完！</li></ol><h2 id="类型转换-未完！"><a href="#类型转换-未完！" class="headerlink" title="类型转换(未完！)"></a>类型转换(未完！)</h2><ol><li><p>首先,在JS中类型转换只有三种情况,分别是:</p><ul><li>转换为布尔值(Boolean)</li><li>转换为数字(Number)</li><li>转换为字符串(String)</li></ul></li><li><p>转Boolean</p><ul><li>在条件判断时,除了<code>undefined</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>&#39;&#39;,</code> <code>0</code>, <code>-0</code>,其他所有值都能转为<code>true</code>,包括所有对象</li></ul><p><a href="https://imgtu.com/i/6w9F1A"><img src="https://s3.ax1x.com/2021/03/13/6w9F1A.png" alt="6w9F1A.png"></a></p></li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote><p>如何正确判断this? 箭头函数的this是什么?</p></blockquote><ol><li>this是一个关键字、变量</li><li>this的指向问题<ul><li>函数this不是函数定义时决定的</li><li>函数this指向看谁如何调用当前的函数</li></ul></li><li>this指向分类<ul><li>函数调用/自调用时<code>this</code>一定指向<code>window</code></li><li>匿名函数的<code>this</code>指向<code>window</code></li><li>在<code>事件当中</code>,回调函数中的this指向事件对象(比如点击事件)</li><li><code>对象.方法()</code>的this指向对象本身</li><li><code>构造函数</code>的this指向当前构造函数的实例对象</li><li><code>箭头函数</code>中没有this,一般它的this指向其外部作用域中的this,如果外部没有函数,this指向window(注意: <strong>箭头函数的this一旦被绑定,就不会再被任何方式改变</strong>)</li><li><code>fun.call/apply(obj)</code>,调用函数,指定函数中的this为第一参数的值,如果第一个参数为空,那么默认为window</li><li><code>ajax回调/定时器回调</code>中的this永远指向window</li></ul></li><li>注意点: 不管给函数<code>bind</code>几次,<code>fn</code>中的<code>this</code>永远由<code>第一次bind</code>决定,不会再更改<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// ==&gt; 输出的是window而不是a</span></span><br><span class="line">&#125;</span><br><span class="line">fn.bind().bind(a) </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
